This patch remembers backup file names patch has already created
in a binary tree, and prevents patch from overwriting backup
files it has created before. The bug can be reproduced as follows:

	$ cat > f
	< one

	$ cat > f.patch
	<--- f.orig      2003-04-09 01:48:01.000000000 +0200
	<+++ f   2003-04-09 01:49:17.000000000 +0200
	<@@ -2 +2 @@
	<-one
	<+two
	<--- f.orig      2003-04-09 01:48:01.000000000 +0200
	<+++ f   2003-04-09 01:49:17.000000000 +0200
	<@@ -2 +2 @@
	<-two
	<+three

	$ patch -p0 < f.patch
	> patching file f
	> Hunk #1 succeeded at 1 (offset -1 lines).
	> patching file f
	> Hunk #1 succeeded at 1 (offset -1 lines).

	$ cat f.orig
	> one

	$ rm f f.orig f.patch


Here is another test case with hard links between source files.

	$ cat > f
	< one

	$ ln f g
	$ cat > fg.patch
	<--- f.orig      2003-04-09 01:48:01.000000000 +0200
	<+++ f   2003-04-09 01:49:17.000000000 +0200
	<@@ -2 +2 @@
	<-one
	<+two
	<--- g.orig      2003-04-09 01:48:01.000000000 +0200
	<+++ g   2003-04-09 01:49:17.000000000 +0200
	<@@ -2 +2 @@
	<-one
	<+two

	$ patch -p0 < fg.patch
	> patching file f
	> Hunk #1 succeeded at 1 (offset -1 lines).
	> patching file g
	> Hunk #1 succeeded at 1 (offset -1 lines).

	$ cat f.orig
	> one

	$ cat g.orig
	> one

	$ rm f f.orig g g.orig fg.patch

Index: patch-2.5.9/Makefile.in
===================================================================
--- patch-2.5.9.orig/Makefile.in	2003-05-20 18:15:48.000000000 +0200
+++ patch-2.5.9/Makefile.in	2003-10-07 14:53:07.000000000 +0200
@@ -62,7 +62,7 @@ CONFIG_STATUS = config.status
 SHELL = /bin/sh
 
 LIBSRCS = error.c malloc.c memchr.c mkdir.c \
-	realloc.c rmdir.c strcasecmp.c strncasecmp.c
+	realloc.c rmdir.c strcasecmp.c strncasecmp.c hash.c
 SRCS = $(LIBSRCS) \
 	addext.c argmatch.c backupfile.c \
 	basename.c dirname.c \
@@ -78,12 +78,12 @@ OBJS = $(LIBOBJS) \
 	maketime.$(OBJEXT) partime.$(OBJEXT) \
 	patch.$(OBJEXT) pch.$(OBJEXT) \
 	quote.$(OBJEXT) quotearg.$(OBJEXT) quotesys.$(OBJEXT) \
-	util.$(OBJEXT) version.$(OBJEXT) xmalloc.$(OBJEXT)
+	util.$(OBJEXT) version.$(OBJEXT) xmalloc.$(OBJEXT) hash.$(OBJEXT)
 HDRS = argmatch.h backupfile.h common.h dirname.h \
 	error.h getopt.h gettext.h \
 	inp.h maketime.h partime.h pch.h \
 	quote.h quotearg.h quotesys.h \
-	unlocked-io.h util.h version.h xalloc.h
+	unlocked-io.h util.h version.h xalloc.h hash.h
 MISC = AUTHORS COPYING ChangeLog INSTALL Makefile.in NEWS README \
 	aclocal.m4 \
 	config.hin configure configure.ac \
Index: patch-2.5.9/configure.ac
===================================================================
--- patch-2.5.9.orig/configure.ac	2003-05-19 08:44:57.000000000 +0200
+++ patch-2.5.9/configure.ac	2003-10-07 16:48:30.000000000 +0200
@@ -64,6 +64,9 @@ gl_GETOPT
 gl_PREREQ_XMALLOC
 gl_QUOTE
 gl_QUOTEARG
+gl_HASH
+
+ag_CHECK_NANOSECOND_STAT
 
 dnl This should be in gnulib, but isn't for some reason.
 AC_DEFUN([jm_PREREQ_ADDEXT],
Index: patch-2.5.9/m4/hash.m4
===================================================================
--- patch-2.5.9.orig/m4/hash.m4	2003-10-07 14:53:07.000000000 +0200
+++ patch-2.5.9/m4/hash.m4	2003-10-07 14:53:07.000000000 +0200
@@ -0,0 +1,15 @@
+# hash.m4 serial 1
+dnl Copyright (C) 2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+AC_DEFUN([gl_HASH],
+[
+  dnl Prerequisites of lib/hash.c.
+  AC_CHECK_HEADERS_ONCE(stdlib.h)
+  AC_HEADER_STDBOOL
+  AC_CHECK_DECLS_ONCE(free malloc)
+])
Index: patch-2.5.9/util.c
===================================================================
--- patch-2.5.9.orig/util.c	2003-05-20 16:04:53.000000000 +0200
+++ patch-2.5.9/util.c	2003-10-07 17:24:24.000000000 +0200
@@ -45,9 +45,17 @@
 # define raise(sig) kill (getpid (), sig)
 #endif
 
+#if defined(HAVE_STAT_TIMEVAL)
+#include <time.h>
+#endif
+
 #include <stdarg.h>
+#include <hash.h>
 
 static void makedirs (char *);
+static bool fid_search (const char *, const struct stat *, bool);
+# define fid_exists(name, pst) fid_search (name, pst, false)
+# define insert_fid(name) fid_search (name, NULL, true)
 
 /* Move a file FROM (where *FROM_NEEDS_REMOVAL is nonzero if FROM
    needs removal when cleaning up at the end of execution)
@@ -64,7 +72,7 @@ move_file (char const *from, int volatil
   struct stat to_st;
   int to_errno = ! backup ? -1 : stat (to, &to_st) == 0 ? 0 : errno;
 
-  if (backup)
+  if (backup && (to_errno || ! fid_exists (to, &to_st)))
     {
       int try_makedirs_errno = 0;
       char *bakname;
@@ -165,6 +173,7 @@ move_file (char const *from, int volatil
 	      if (! to_dir_known_to_exist)
 		makedirs (to);
 	      copy_file (from, to, 0, mode);
+	      insert_fid (to);
 	      return;
 	    }
 
@@ -173,6 +182,7 @@ move_file (char const *from, int volatil
 	}
 
     rename_succeeded:
+      insert_fid (to);
       /* Do not clear *FROM_NEEDS_REMOVAL if it's possible that the
 	 rename returned zero because FROM and TO are hard links to
 	 the same file.  */
@@ -1011,3 +1021,105 @@ Fseek (FILE *stream, file_offset offset,
   if (file_seek (stream, offset, ptrname) != 0)
     pfatal ("fseek");
 }
+
+typedef struct
+{
+  dev_t		fid_dev;
+  ino_t		fid_ino;
+  time_t	fid_mtime;
+  unsigned long	fid_mtimensec;
+} file_id;
+
+unsigned
+file_id_hasher (file_id *entry, unsigned table_size)
+{
+  return ((unsigned long) entry->fid_ino +
+  	  (unsigned long) entry->fid_dev +
+  	  (unsigned long) entry->fid_mtime +
+	  (unsigned long) entry->fid_mtimensec) % table_size;
+}
+
+bool
+file_id_comparator (file_id *entry1, file_id *entry2)
+{
+  return (entry1->fid_dev	== entry2->fid_dev &&
+	  entry1->fid_ino	== entry2->fid_ino &&
+	  entry1->fid_mtime	== entry2->fid_mtime &&
+	  entry1->fid_mtimensec == entry2->fid_mtimensec);
+}
+
+void
+file_id_freer (file_id *entry)
+{
+  free (entry);
+}
+
+Hash_table *file_id_hash;
+
+/* Check if the file identified by FILENAME and PST was already seen. If the
+   file was already seen, returns TRUE.  If the file has not yet been seen
+   and INSERT is TRUE, it is inserted.  PST or FILENAME may be NULL (but not
+   both of them).  */
+
+static bool
+fid_search (const char *filename, const struct stat *pst, bool insert)
+{
+  struct stat st;
+
+  if (!file_id_hash)
+    {
+      file_id_hash = hash_initialize (0, NULL, (Hash_hasher) file_id_hasher,
+				      (Hash_comparator) file_id_comparator,
+				      (Hash_data_freer) file_id_freer);
+      if (!file_id_hash)
+	pfatal ("hash_initialize");
+    }
+
+  if (!pst)
+    {
+      if (stat (filename, &st) != 0)
+	pfatal ("%s", quotearg (filename));
+      pst = &st;
+    }
+
+  if (insert)
+    {
+      file_id *pfid = xmalloc (sizeof (file_id)), *old_pfid;
+      pfid->fid_dev	  = pst->st_dev;
+      pfid->fid_ino	  = pst->st_ino;
+      pfid->fid_mtime	  = pst->st_mtime;
+#if defined(HAVE_STAT_NSEC)
+      pfid->fid_mtimensec = pst->st_mtimensec;
+#elif defined(HAVE_STAT_TIMEVAL)
+      pfid->fid_mtimensec = pst->st_mtim.tv_nsec;
+#else
+      pfid->fid_mtimensec = 0;
+#endif
+      old_pfid = hash_insert (file_id_hash, pfid);
+      if (!old_pfid)
+	pfatal ("hash_insert");
+      else if (old_pfid != pfid)
+        {
+	  free (pfid);
+	  return true;
+	}
+      else
+	return false;
+    }
+  else
+    {
+      file_id fid;
+      fid.fid_dev	= pst->st_dev;
+      fid.fid_ino	= pst->st_ino;
+      fid.fid_mtime	= pst->st_mtime;
+#if defined(HAVE_STAT_NSEC)
+      fid.fid_mtimensec = pst->st_mtimensec;
+#elif defined(HAVE_STAT_TIMEVAL)
+      fid.fid_mtimensec = pst->st_mtim.tv_nsec;
+#else
+      fid.fid_mtimensec = 0;
+#endif
+      return hash_lookup (file_id_hash, &fid) != 0;
+    }
+}
+
Index: patch-2.5.9/hash.c
===================================================================
--- patch-2.5.9.orig/hash.c	2003-10-07 14:53:07.000000000 +0200
+++ patch-2.5.9/hash.c	2003-10-07 14:53:07.000000000 +0200
@@ -0,0 +1,1051 @@
+/* hash - hashing table processing.
+
+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003 Free Software
+   Foundation, Inc.
+
+   Written by Jim Meyering, 1992.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* A generic hash table package.  */
+
+/* Define USE_OBSTACK to 1 if you want the allocator to use obstacks instead
+   of malloc.  If you change USE_OBSTACK, you have to recompile!  */
+
+#if HAVE_CONFIG_H
+# include <config.h>
+#endif
+#if HAVE_STDLIB_H
+# include <stdlib.h>
+#endif
+
+#include <limits.h>
+#include <stdbool.h>
+#include <stdio.h>
+
+#ifndef HAVE_DECL_FREE
+"this configure-time declaration test was not run"
+#endif
+#if !HAVE_DECL_FREE
+void free ();
+#endif
+
+#ifndef HAVE_DECL_MALLOC
+"this configure-time declaration test was not run"
+#endif
+#if !HAVE_DECL_MALLOC
+char *malloc ();
+#endif
+
+#if USE_OBSTACK
+# include "obstack.h"
+# ifndef obstack_chunk_alloc
+#  define obstack_chunk_alloc malloc
+# endif
+# ifndef obstack_chunk_free
+#  define obstack_chunk_free free
+# endif
+#endif
+
+#include "hash.h"
+
+struct hash_table
+  {
+    /* The array of buckets starts at BUCKET and extends to BUCKET_LIMIT-1,
+       for a possibility of N_BUCKETS.  Among those, N_BUCKETS_USED buckets
+       are not empty, there are N_ENTRIES active entries in the table.  */
+    struct hash_entry *bucket;
+    struct hash_entry *bucket_limit;
+    unsigned n_buckets;
+    unsigned n_buckets_used;
+    unsigned n_entries;
+
+    /* Tuning arguments, kept in a physicaly separate structure.  */
+    const Hash_tuning *tuning;
+
+    /* Three functions are given to `hash_initialize', see the documentation
+       block for this function.  In a word, HASHER randomizes a user entry
+       into a number up from 0 up to some maximum minus 1; COMPARATOR returns
+       true if two user entries compare equally; and DATA_FREER is the cleanup
+       function for a user entry.  */
+    Hash_hasher hasher;
+    Hash_comparator comparator;
+    Hash_data_freer data_freer;
+
+    /* A linked list of freed struct hash_entry structs.  */
+    struct hash_entry *free_entry_list;
+
+#if USE_OBSTACK
+    /* Whenever obstacks are used, it is possible to allocate all overflowed
+       entries into a single stack, so they all can be freed in a single
+       operation.  It is not clear if the speedup is worth the trouble.  */
+    struct obstack entry_stack;
+#endif
+  };
+
+/* A hash table contains many internal entries, each holding a pointer to
+   some user provided data (also called a user entry).  An entry indistinctly
+   refers to both the internal entry and its associated user entry.  A user
+   entry contents may be hashed by a randomization function (the hashing
+   function, or just `hasher' for short) into a number (or `slot') between 0
+   and the current table size.  At each slot position in the hash table,
+   starts a linked chain of entries for which the user data all hash to this
+   slot.  A bucket is the collection of all entries hashing to the same slot.
+
+   A good `hasher' function will distribute entries rather evenly in buckets.
+   In the ideal case, the length of each bucket is roughly the number of
+   entries divided by the table size.  Finding the slot for a data is usually
+   done in constant time by the `hasher', and the later finding of a precise
+   entry is linear in time with the size of the bucket.  Consequently, a
+   larger hash table size (that is, a larger number of buckets) is prone to
+   yielding shorter chains, *given* the `hasher' function behaves properly.
+
+   Long buckets slow down the lookup algorithm.  One might use big hash table
+   sizes in hope to reduce the average length of buckets, but this might
+   become inordinate, as unused slots in the hash table take some space.  The
+   best bet is to make sure you are using a good `hasher' function (beware
+   that those are not that easy to write! :-), and to use a table size
+   larger than the actual number of entries.  */
+
+/* If an insertion makes the ratio of nonempty buckets to table size larger
+   than the growth threshold (a number between 0.0 and 1.0), then increase
+   the table size by multiplying by the growth factor (a number greater than
+   1.0).  The growth threshold defaults to 0.8, and the growth factor
+   defaults to 1.414, meaning that the table will have doubled its size
+   every second time 80% of the buckets get used.  */
+#define DEFAULT_GROWTH_THRESHOLD 0.8
+#define DEFAULT_GROWTH_FACTOR 1.414
+
+/* If a deletion empties a bucket and causes the ratio of used buckets to
+   table size to become smaller than the shrink threshold (a number between
+   0.0 and 1.0), then shrink the table by multiplying by the shrink factor (a
+   number greater than the shrink threshold but smaller than 1.0).  The shrink
+   threshold and factor default to 0.0 and 1.0, meaning that the table never
+   shrinks.  */
+#define DEFAULT_SHRINK_THRESHOLD 0.0
+#define DEFAULT_SHRINK_FACTOR 1.0
+
+/* Use this to initialize or reset a TUNING structure to
+   some sensible values. */
+static const Hash_tuning default_tuning =
+  {
+    DEFAULT_SHRINK_THRESHOLD,
+    DEFAULT_SHRINK_FACTOR,
+    DEFAULT_GROWTH_THRESHOLD,
+    DEFAULT_GROWTH_FACTOR,
+    false
+  };
+
+/* Information and lookup.  */
+
+/* The following few functions provide information about the overall hash
+   table organization: the number of entries, number of buckets and maximum
+   length of buckets.  */
+
+/* Return the number of buckets in the hash table.  The table size, the total
+   number of buckets (used plus unused), or the maximum number of slots, are
+   the same quantity.  */
+
+unsigned
+hash_get_n_buckets (const Hash_table *table)
+{
+  return table->n_buckets;
+}
+
+/* Return the number of slots in use (non-empty buckets).  */
+
+unsigned
+hash_get_n_buckets_used (const Hash_table *table)
+{
+  return table->n_buckets_used;
+}
+
+/* Return the number of active entries.  */
+
+unsigned
+hash_get_n_entries (const Hash_table *table)
+{
+  return table->n_entries;
+}
+
+/* Return the length of the longest chain (bucket).  */
+
+unsigned
+hash_get_max_bucket_length (const Hash_table *table)
+{
+  struct hash_entry *bucket;
+  unsigned max_bucket_length = 0;
+
+  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
+    {
+      if (bucket->data)
+	{
+	  struct hash_entry *cursor = bucket;
+	  unsigned bucket_length = 1;
+
+	  while (cursor = cursor->next, cursor)
+	    bucket_length++;
+
+	  if (bucket_length > max_bucket_length)
+	    max_bucket_length = bucket_length;
+	}
+    }
+
+  return max_bucket_length;
+}
+
+/* Do a mild validation of a hash table, by traversing it and checking two
+   statistics.  */
+
+bool
+hash_table_ok (const Hash_table *table)
+{
+  struct hash_entry *bucket;
+  unsigned n_buckets_used = 0;
+  unsigned n_entries = 0;
+
+  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
+    {
+      if (bucket->data)
+	{
+	  struct hash_entry *cursor = bucket;
+
+	  /* Count bucket head.  */
+	  n_buckets_used++;
+	  n_entries++;
+
+	  /* Count bucket overflow.  */
+	  while (cursor = cursor->next, cursor)
+	    n_entries++;
+	}
+    }
+
+  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)
+    return true;
+
+  return false;
+}
+
+void
+hash_print_statistics (const Hash_table *table, FILE *stream)
+{
+  unsigned n_entries = hash_get_n_entries (table);
+  unsigned n_buckets = hash_get_n_buckets (table);
+  unsigned n_buckets_used = hash_get_n_buckets_used (table);
+  unsigned max_bucket_length = hash_get_max_bucket_length (table);
+
+  fprintf (stream, "# entries:         %u\n", n_entries);
+  fprintf (stream, "# buckets:         %u\n", n_buckets);
+  fprintf (stream, "# buckets used:    %u (%.2f%%)\n", n_buckets_used,
+	   (100.0 * n_buckets_used) / n_buckets);
+  fprintf (stream, "max bucket length: %u\n", max_bucket_length);
+}
+
+/* If ENTRY matches an entry already in the hash table, return the
+   entry from the table.  Otherwise, return NULL.  */
+
+void *
+hash_lookup (const Hash_table *table, const void *entry)
+{
+  struct hash_entry *bucket
+    = table->bucket + table->hasher (entry, table->n_buckets);
+  struct hash_entry *cursor;
+
+  if (! (bucket < table->bucket_limit))
+    abort ();
+
+  if (bucket->data == NULL)
+    return NULL;
+
+  for (cursor = bucket; cursor; cursor = cursor->next)
+    if (table->comparator (entry, cursor->data))
+      return cursor->data;
+
+  return NULL;
+}
+
+/* Walking.  */
+
+/* The functions in this page traverse the hash table and process the
+   contained entries.  For the traversal to work properly, the hash table
+   should not be resized nor modified while any particular entry is being
+   processed.  In particular, entries should not be added or removed.  */
+
+/* Return the first data in the table, or NULL if the table is empty.  */
+
+void *
+hash_get_first (const Hash_table *table)
+{
+  struct hash_entry *bucket;
+
+  if (table->n_entries == 0)
+    return NULL;
+
+  for (bucket = table->bucket; ; bucket++)
+    if (! (bucket < table->bucket_limit))
+      abort ();
+    else if (bucket->data)
+      return bucket->data;
+}
+
+/* Return the user data for the entry following ENTRY, where ENTRY has been
+   returned by a previous call to either `hash_get_first' or `hash_get_next'.
+   Return NULL if there are no more entries.  */
+
+void *
+hash_get_next (const Hash_table *table, const void *entry)
+{
+  struct hash_entry *bucket
+    = table->bucket + table->hasher (entry, table->n_buckets);
+  struct hash_entry *cursor;
+
+  if (! (bucket < table->bucket_limit))
+    abort ();
+
+  /* Find next entry in the same bucket.  */
+  for (cursor = bucket; cursor; cursor = cursor->next)
+    if (cursor->data == entry && cursor->next)
+      return cursor->next->data;
+
+  /* Find first entry in any subsequent bucket.  */
+  while (++bucket < table->bucket_limit)
+    if (bucket->data)
+      return bucket->data;
+
+  /* None found.  */
+  return NULL;
+}
+
+/* Fill BUFFER with pointers to active user entries in the hash table, then
+   return the number of pointers copied.  Do not copy more than BUFFER_SIZE
+   pointers.  */
+
+unsigned
+hash_get_entries (const Hash_table *table, void **buffer,
+		  unsigned buffer_size)
+{
+  unsigned counter = 0;
+  struct hash_entry *bucket;
+  struct hash_entry *cursor;
+
+  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
+    {
+      if (bucket->data)
+	{
+	  for (cursor = bucket; cursor; cursor = cursor->next)
+	    {
+	      if (counter >= buffer_size)
+		return counter;
+	      buffer[counter++] = cursor->data;
+	    }
+	}
+    }
+
+  return counter;
+}
+
+/* Call a PROCESSOR function for each entry of a hash table, and return the
+   number of entries for which the processor function returned success.  A
+   pointer to some PROCESSOR_DATA which will be made available to each call to
+   the processor function.  The PROCESSOR accepts two arguments: the first is
+   the user entry being walked into, the second is the value of PROCESSOR_DATA
+   as received.  The walking continue for as long as the PROCESSOR function
+   returns nonzero.  When it returns zero, the walking is interrupted.  */
+
+unsigned
+hash_do_for_each (const Hash_table *table, Hash_processor processor,
+		  void *processor_data)
+{
+  unsigned counter = 0;
+  struct hash_entry *bucket;
+  struct hash_entry *cursor;
+
+  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
+    {
+      if (bucket->data)
+	{
+	  for (cursor = bucket; cursor; cursor = cursor->next)
+	    {
+	      if (!(*processor) (cursor->data, processor_data))
+		return counter;
+	      counter++;
+	    }
+	}
+    }
+
+  return counter;
+}
+
+/* Allocation and clean-up.  */
+
+/* Return a hash index for a NUL-terminated STRING between 0 and N_BUCKETS-1.
+   This is a convenience routine for constructing other hashing functions.  */
+
+#if USE_DIFF_HASH
+
+/* About hashings, Paul Eggert writes to me (FP), on 1994-01-01: "Please see
+   B. J. McKenzie, R. Harries & T. Bell, Selecting a hashing algorithm,
+   Software--practice & experience 20, 2 (Feb 1990), 209-224.  Good hash
+   algorithms tend to be domain-specific, so what's good for [diffutils'] io.c
+   may not be good for your application."  */
+
+unsigned
+hash_string (const char *string, unsigned n_buckets)
+{
+# define ROTATE_LEFT(Value, Shift) \
+  ((Value) << (Shift) | (Value) >> ((sizeof (unsigned) * CHAR_BIT) - (Shift)))
+# define HASH_ONE_CHAR(Value, Byte) \
+  ((Byte) + ROTATE_LEFT (Value, 7))
+
+  unsigned value = 0;
+
+  for (; *string; string++)
+    value = HASH_ONE_CHAR (value, *(const unsigned char *) string);
+  return value % n_buckets;
+
+# undef ROTATE_LEFT
+# undef HASH_ONE_CHAR
+}
+
+#else /* not USE_DIFF_HASH */
+
+/* This one comes from `recode', and performs a bit better than the above as
+   per a few experiments.  It is inspired from a hashing routine found in the
+   very old Cyber `snoop', itself written in typical Greg Mansfield style.
+   (By the way, what happened to this excellent man?  Is he still alive?)  */
+
+unsigned
+hash_string (const char *string, unsigned n_buckets)
+{
+  unsigned value = 0;
+
+  while (*string)
+    value = ((value * 31 + (int) *(const unsigned char *) string++)
+	     % n_buckets);
+  return value;
+}
+
+#endif /* not USE_DIFF_HASH */
+
+/* Return true if CANDIDATE is a prime number.  CANDIDATE should be an odd
+   number at least equal to 11.  */
+
+static bool
+is_prime (unsigned long candidate)
+{
+  unsigned long divisor = 3;
+  unsigned long square = divisor * divisor;
+
+  while (square < candidate && (candidate % divisor))
+    {
+      divisor++;
+      square += 4 * divisor;
+      divisor++;
+    }
+
+  return (candidate % divisor ? true : false);
+}
+
+/* Round a given CANDIDATE number up to the nearest prime, and return that
+   prime.  Primes lower than 10 are merely skipped.  */
+
+static unsigned long
+next_prime (unsigned long candidate)
+{
+  /* Skip small primes.  */
+  if (candidate < 10)
+    candidate = 10;
+
+  /* Make it definitely odd.  */
+  candidate |= 1;
+
+  while (!is_prime (candidate))
+    candidate += 2;
+
+  return candidate;
+}
+
+void
+hash_reset_tuning (Hash_tuning *tuning)
+{
+  *tuning = default_tuning;
+}
+
+/* For the given hash TABLE, check the user supplied tuning structure for
+   reasonable values, and return true if there is no gross error with it.
+   Otherwise, definitively reset the TUNING field to some acceptable default
+   in the hash table (that is, the user loses the right of further modifying
+   tuning arguments), and return false.  */
+
+static bool
+check_tuning (Hash_table *table)
+{
+  const Hash_tuning *tuning = table->tuning;
+
+  if (tuning->growth_threshold > 0.0
+      && tuning->growth_threshold < 1.0
+      && tuning->growth_factor > 1.0
+      && tuning->shrink_threshold >= 0.0
+      && tuning->shrink_threshold < 1.0
+      && tuning->shrink_factor > tuning->shrink_threshold
+      && tuning->shrink_factor <= 1.0
+      && tuning->shrink_threshold < tuning->growth_threshold)
+    return true;
+
+  table->tuning = &default_tuning;
+  return false;
+}
+
+/* Allocate and return a new hash table, or NULL upon failure.  The initial
+   number of buckets is automatically selected so as to _guarantee_ that you
+   may insert at least CANDIDATE different user entries before any growth of
+   the hash table size occurs.  So, if have a reasonably tight a-priori upper
+   bound on the number of entries you intend to insert in the hash table, you
+   may save some table memory and insertion time, by specifying it here.  If
+   the IS_N_BUCKETS field of the TUNING structure is true, the CANDIDATE
+   argument has its meaning changed to the wanted number of buckets.
+
+   TUNING points to a structure of user-supplied values, in case some fine
+   tuning is wanted over the default behavior of the hasher.  If TUNING is
+   NULL, the default tuning parameters are used instead.
+
+   The user-supplied HASHER function should be provided.  It accepts two
+   arguments ENTRY and TABLE_SIZE.  It computes, by hashing ENTRY contents, a
+   slot number for that entry which should be in the range 0..TABLE_SIZE-1.
+   This slot number is then returned.
+
+   The user-supplied COMPARATOR function should be provided.  It accepts two
+   arguments pointing to user data, it then returns true for a pair of entries
+   that compare equal, or false otherwise.  This function is internally called
+   on entries which are already known to hash to the same bucket index.
+
+   The user-supplied DATA_FREER function, when not NULL, may be later called
+   with the user data as an argument, just before the entry containing the
+   data gets freed.  This happens from within `hash_free' or `hash_clear'.
+   You should specify this function only if you want these functions to free
+   all of your `data' data.  This is typically the case when your data is
+   simply an auxiliary struct that you have malloc'd to aggregate several
+   values.  */
+
+Hash_table *
+hash_initialize (unsigned candidate, const Hash_tuning *tuning,
+		 Hash_hasher hasher, Hash_comparator comparator,
+		 Hash_data_freer data_freer)
+{
+  Hash_table *table;
+  struct hash_entry *bucket;
+
+  if (hasher == NULL || comparator == NULL)
+    return NULL;
+
+  table = (Hash_table *) malloc (sizeof (Hash_table));
+  if (table == NULL)
+    return NULL;
+
+  if (!tuning)
+    tuning = &default_tuning;
+  table->tuning = tuning;
+  if (!check_tuning (table))
+    {
+      /* Fail if the tuning options are invalid.  This is the only occasion
+	 when the user gets some feedback about it.  Once the table is created,
+	 if the user provides invalid tuning options, we silently revert to
+	 using the defaults, and ignore further request to change the tuning
+	 options.  */
+      free (table);
+      return NULL;
+    }
+
+  table->n_buckets
+    = next_prime (tuning->is_n_buckets ? candidate
+		  : (unsigned) (candidate / tuning->growth_threshold));
+
+  table->bucket = (struct hash_entry *)
+    malloc (table->n_buckets * sizeof (struct hash_entry));
+  if (table->bucket == NULL)
+    {
+      free (table);
+      return NULL;
+    }
+  table->bucket_limit = table->bucket + table->n_buckets;
+
+  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
+    {
+      bucket->data = NULL;
+      bucket->next = NULL;
+    }
+  table->n_buckets_used = 0;
+  table->n_entries = 0;
+
+  table->hasher = hasher;
+  table->comparator = comparator;
+  table->data_freer = data_freer;
+
+  table->free_entry_list = NULL;
+#if USE_OBSTACK
+  obstack_init (&table->entry_stack);
+#endif
+  return table;
+}
+
+/* Make all buckets empty, placing any chained entries on the free list.
+   Apply the user-specified function data_freer (if any) to the datas of any
+   affected entries.  */
+
+void
+hash_clear (Hash_table *table)
+{
+  struct hash_entry *bucket;
+
+  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
+    {
+      if (bucket->data)
+	{
+	  struct hash_entry *cursor;
+	  struct hash_entry *next;
+
+	  /* Free the bucket overflow.  */
+	  for (cursor = bucket->next; cursor; cursor = next)
+	    {
+	      if (table->data_freer)
+		(*table->data_freer) (cursor->data);
+	      cursor->data = NULL;
+
+	      next = cursor->next;
+	      /* Relinking is done one entry at a time, as it is to be expected
+		 that overflows are either rare or short.  */
+	      cursor->next = table->free_entry_list;
+	      table->free_entry_list = cursor;
+	    }
+
+	  /* Free the bucket head.  */
+	  if (table->data_freer)
+	    (*table->data_freer) (bucket->data);
+	  bucket->data = NULL;
+	  bucket->next = NULL;
+	}
+    }
+
+  table->n_buckets_used = 0;
+  table->n_entries = 0;
+}
+
+/* Reclaim all storage associated with a hash table.  If a data_freer
+   function has been supplied by the user when the hash table was created,
+   this function applies it to the data of each entry before freeing that
+   entry.  */
+
+void
+hash_free (Hash_table *table)
+{
+  struct hash_entry *bucket;
+  struct hash_entry *cursor;
+  struct hash_entry *next;
+
+  /* Call the user data_freer function.  */
+  if (table->data_freer && table->n_entries)
+    {
+      for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
+	{
+	  if (bucket->data)
+	    {
+	      for (cursor = bucket; cursor; cursor = cursor->next)
+		{
+		  (*table->data_freer) (cursor->data);
+		}
+	    }
+	}
+    }
+
+#if USE_OBSTACK
+
+  obstack_free (&table->entry_stack, NULL);
+
+#else
+
+  /* Free all bucket overflowed entries.  */
+  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
+    {
+      for (cursor = bucket->next; cursor; cursor = next)
+	{
+	  next = cursor->next;
+	  free (cursor);
+	}
+    }
+
+  /* Also reclaim the internal list of previously freed entries.  */
+  for (cursor = table->free_entry_list; cursor; cursor = next)
+    {
+      next = cursor->next;
+      free (cursor);
+    }
+
+#endif
+
+  /* Free the remainder of the hash table structure.  */
+  free (table->bucket);
+  free (table);
+}
+
+/* Insertion and deletion.  */
+
+/* Get a new hash entry for a bucket overflow, possibly by reclying a
+   previously freed one.  If this is not possible, allocate a new one.  */
+
+static struct hash_entry *
+allocate_entry (Hash_table *table)
+{
+  struct hash_entry *new;
+
+  if (table->free_entry_list)
+    {
+      new = table->free_entry_list;
+      table->free_entry_list = new->next;
+    }
+  else
+    {
+#if USE_OBSTACK
+      new = (struct hash_entry *)
+	obstack_alloc (&table->entry_stack, sizeof (struct hash_entry));
+#else
+      new = (struct hash_entry *) malloc (sizeof (struct hash_entry));
+#endif
+    }
+
+  return new;
+}
+
+/* Free a hash entry which was part of some bucket overflow,
+   saving it for later recycling.  */
+
+static void
+free_entry (Hash_table *table, struct hash_entry *entry)
+{
+  entry->data = NULL;
+  entry->next = table->free_entry_list;
+  table->free_entry_list = entry;
+}
+
+/* This private function is used to help with insertion and deletion.  When
+   ENTRY matches an entry in the table, return a pointer to the corresponding
+   user data and set *BUCKET_HEAD to the head of the selected bucket.
+   Otherwise, return NULL.  When DELETE is true and ENTRY matches an entry in
+   the table, unlink the matching entry.  */
+
+static void *
+hash_find_entry (Hash_table *table, const void *entry,
+		 struct hash_entry **bucket_head, bool delete)
+{
+  struct hash_entry *bucket
+    = table->bucket + table->hasher (entry, table->n_buckets);
+  struct hash_entry *cursor;
+
+  if (! (bucket < table->bucket_limit))
+    abort ();
+
+  *bucket_head = bucket;
+
+  /* Test for empty bucket.  */
+  if (bucket->data == NULL)
+    return NULL;
+
+  /* See if the entry is the first in the bucket.  */
+  if ((*table->comparator) (entry, bucket->data))
+    {
+      void *data = bucket->data;
+
+      if (delete)
+	{
+	  if (bucket->next)
+	    {
+	      struct hash_entry *next = bucket->next;
+
+	      /* Bump the first overflow entry into the bucket head, then save
+		 the previous first overflow entry for later recycling.  */
+	      *bucket = *next;
+	      free_entry (table, next);
+	    }
+	  else
+	    {
+	      bucket->data = NULL;
+	    }
+	}
+
+      return data;
+    }
+
+  /* Scan the bucket overflow.  */
+  for (cursor = bucket; cursor->next; cursor = cursor->next)
+    {
+      if ((*table->comparator) (entry, cursor->next->data))
+	{
+	  void *data = cursor->next->data;
+
+	  if (delete)
+	    {
+	      struct hash_entry *next = cursor->next;
+
+	      /* Unlink the entry to delete, then save the freed entry for later
+		 recycling.  */
+	      cursor->next = next->next;
+	      free_entry (table, next);
+	    }
+
+	  return data;
+	}
+    }
+
+  /* No entry found.  */
+  return NULL;
+}
+
+/* For an already existing hash table, change the number of buckets through
+   specifying CANDIDATE.  The contents of the hash table are preserved.  The
+   new number of buckets is automatically selected so as to _guarantee_ that
+   the table may receive at least CANDIDATE different user entries, including
+   those already in the table, before any other growth of the hash table size
+   occurs.  If TUNING->IS_N_BUCKETS is true, then CANDIDATE specifies the
+   exact number of buckets desired.  */
+
+bool
+hash_rehash (Hash_table *table, unsigned candidate)
+{
+  Hash_table *new_table;
+  struct hash_entry *bucket;
+  struct hash_entry *cursor;
+  struct hash_entry *next;
+
+  new_table = hash_initialize (candidate, table->tuning, table->hasher,
+			       table->comparator, table->data_freer);
+  if (new_table == NULL)
+    return false;
+
+  /* Merely reuse the extra old space into the new table.  */
+#if USE_OBSTACK
+  obstack_free (&new_table->entry_stack, NULL);
+  new_table->entry_stack = table->entry_stack;
+#endif
+  new_table->free_entry_list = table->free_entry_list;
+
+  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
+    if (bucket->data)
+      for (cursor = bucket; cursor; cursor = next)
+	{
+	  void *data = cursor->data;
+	  struct hash_entry *new_bucket
+	    = (new_table->bucket
+	       + new_table->hasher (data, new_table->n_buckets));
+
+	  if (! (new_bucket < new_table->bucket_limit))
+	    abort ();
+
+	  next = cursor->next;
+
+	  if (new_bucket->data)
+	    {
+	      if (cursor == bucket)
+		{
+		  /* Allocate or recycle an entry, when moving from a bucket
+		     header into a bucket overflow.  */
+		  struct hash_entry *new_entry = allocate_entry (new_table);
+
+		  if (new_entry == NULL)
+		    return false;
+
+		  new_entry->data = data;
+		  new_entry->next = new_bucket->next;
+		  new_bucket->next = new_entry;
+		}
+	      else
+		{
+		  /* Merely relink an existing entry, when moving from a
+		     bucket overflow into a bucket overflow.  */
+		  cursor->next = new_bucket->next;
+		  new_bucket->next = cursor;
+		}
+	    }
+	  else
+	    {
+	      /* Free an existing entry, when moving from a bucket
+		 overflow into a bucket header.  Also take care of the
+		 simple case of moving from a bucket header into a bucket
+		 header.  */
+	      new_bucket->data = data;
+	      new_table->n_buckets_used++;
+	      if (cursor != bucket)
+		free_entry (new_table, cursor);
+	    }
+	}
+
+  free (table->bucket);
+  table->bucket = new_table->bucket;
+  table->bucket_limit = new_table->bucket_limit;
+  table->n_buckets = new_table->n_buckets;
+  table->n_buckets_used = new_table->n_buckets_used;
+  table->free_entry_list = new_table->free_entry_list;
+  /* table->n_entries already holds its value.  */
+#if USE_OBSTACK
+  table->entry_stack = new_table->entry_stack;
+#endif
+  free (new_table);
+
+  return true;
+}
+
+/* If ENTRY matches an entry already in the hash table, return the pointer
+   to the entry from the table.  Otherwise, insert ENTRY and return ENTRY.
+   Return NULL if the storage required for insertion cannot be allocated.  */
+
+void *
+hash_insert (Hash_table *table, const void *entry)
+{
+  void *data;
+  struct hash_entry *bucket;
+
+  /* The caller cannot insert a NULL entry.  */
+  if (! entry)
+    abort ();
+
+  /* If there's a matching entry already in the table, return that.  */
+  if ((data = hash_find_entry (table, entry, &bucket, false)) != NULL)
+    return data;
+
+  /* ENTRY is not matched, it should be inserted.  */
+
+  if (bucket->data)
+    {
+      struct hash_entry *new_entry = allocate_entry (table);
+
+      if (new_entry == NULL)
+	return NULL;
+
+      /* Add ENTRY in the overflow of the bucket.  */
+
+      new_entry->data = (void *) entry;
+      new_entry->next = bucket->next;
+      bucket->next = new_entry;
+      table->n_entries++;
+      return (void *) entry;
+    }
+
+  /* Add ENTRY right in the bucket head.  */
+
+  bucket->data = (void *) entry;
+  table->n_entries++;
+  table->n_buckets_used++;
+
+  /* If the growth threshold of the buckets in use has been reached, increase
+     the table size and rehash.  There's no point in checking the number of
+     entries:  if the hashing function is ill-conditioned, rehashing is not
+     likely to improve it.  */
+
+  if (table->n_buckets_used
+      > table->tuning->growth_threshold * table->n_buckets)
+    {
+      /* Check more fully, before starting real work.  If tuning arguments
+	 became invalid, the second check will rely on proper defaults.  */
+      check_tuning (table);
+      if (table->n_buckets_used
+	  > table->tuning->growth_threshold * table->n_buckets)
+	{
+	  const Hash_tuning *tuning = table->tuning;
+	  unsigned candidate
+	    = (unsigned) (tuning->is_n_buckets
+			  ? (table->n_buckets * tuning->growth_factor)
+			  : (table->n_buckets * tuning->growth_factor
+			     * tuning->growth_threshold));
+
+	  /* If the rehash fails, arrange to return NULL.  */
+	  if (!hash_rehash (table, candidate))
+	    entry = NULL;
+	}
+    }
+
+  return (void *) entry;
+}
+
+/* If ENTRY is already in the table, remove it and return the just-deleted
+   data (the user may want to deallocate its storage).  If ENTRY is not in the
+   table, don't modify the table and return NULL.  */
+
+void *
+hash_delete (Hash_table *table, const void *entry)
+{
+  void *data;
+  struct hash_entry *bucket;
+
+  data = hash_find_entry (table, entry, &bucket, true);
+  if (!data)
+    return NULL;
+
+  table->n_entries--;
+  if (!bucket->data)
+    {
+      table->n_buckets_used--;
+
+      /* If the shrink threshold of the buckets in use has been reached,
+	 rehash into a smaller table.  */
+
+      if (table->n_buckets_used
+	  < table->tuning->shrink_threshold * table->n_buckets)
+	{
+	  /* Check more fully, before starting real work.  If tuning arguments
+	     became invalid, the second check will rely on proper defaults.  */
+	  check_tuning (table);
+	  if (table->n_buckets_used
+	      < table->tuning->shrink_threshold * table->n_buckets)
+	    {
+	      const Hash_tuning *tuning = table->tuning;
+	      unsigned candidate
+		= (unsigned) (tuning->is_n_buckets
+			      ? table->n_buckets * tuning->shrink_factor
+			      : (table->n_buckets * tuning->shrink_factor
+				 * tuning->growth_threshold));
+
+	      hash_rehash (table, candidate);
+	    }
+	}
+    }
+
+  return data;
+}
+
+/* Testing.  */
+
+#if TESTING
+
+void
+hash_print (const Hash_table *table)
+{
+  struct hash_entry *bucket;
+
+  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
+    {
+      struct hash_entry *cursor;
+
+      if (bucket)
+	printf ("%d:\n", bucket - table->bucket);
+
+      for (cursor = bucket; cursor; cursor = cursor->next)
+	{
+	  char *s = (char *) cursor->data;
+	  /* FIXME */
+	  if (s)
+	    printf ("  %s\n", s);
+	}
+    }
+}
+
+#endif /* TESTING */
Index: patch-2.5.9/hash.h
===================================================================
--- patch-2.5.9.orig/hash.h	2003-10-07 14:53:07.000000000 +0200
+++ patch-2.5.9/hash.h	2003-10-07 14:53:07.000000000 +0200
@@ -0,0 +1,93 @@
+/* hash - hashing table processing.
+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.
+   Written by Jim Meyering <meyering@ascend.com>, 1998.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* A generic hash table package.  */
+
+/* Make sure USE_OBSTACK is defined to 1 if you want the allocator to use
+   obstacks instead of malloc, and recompile `hash.c' with same setting.  */
+
+#ifndef HASH_H_
+# define HASH_H_
+
+# ifndef PARAMS
+#  if PROTOTYPES || __STDC__
+#   define PARAMS(Args) Args
+#  else
+#   define PARAMS(Args) ()
+#  endif
+# endif
+
+typedef unsigned (*Hash_hasher) PARAMS ((const void *, unsigned));
+typedef bool (*Hash_comparator) PARAMS ((const void *, const void *));
+typedef void (*Hash_data_freer) PARAMS ((void *));
+typedef bool (*Hash_processor) PARAMS ((void *, void *));
+
+struct hash_entry
+  {
+    void *data;
+    struct hash_entry *next;
+  };
+
+struct hash_tuning
+  {
+    /* This structure is mainly used for `hash_initialize', see the block
+       documentation of `hash_reset_tuning' for more complete comments.  */
+
+    float shrink_threshold;	/* ratio of used buckets to trigger a shrink */
+    float shrink_factor;	/* ratio of new smaller size to original size */
+    float growth_threshold;	/* ratio of used buckets to trigger a growth */
+    float growth_factor;	/* ratio of new bigger size to original size */
+    bool is_n_buckets;		/* if CANDIDATE really means table size */
+  };
+
+typedef struct hash_tuning Hash_tuning;
+
+struct hash_table;
+
+typedef struct hash_table Hash_table;
+
+/* Information and lookup.  */
+unsigned hash_get_n_buckets PARAMS ((const Hash_table *));
+unsigned hash_get_n_buckets_used PARAMS ((const Hash_table *));
+unsigned hash_get_n_entries PARAMS ((const Hash_table *));
+unsigned hash_get_max_bucket_length PARAMS ((const Hash_table *));
+bool hash_table_ok PARAMS ((const Hash_table *));
+void hash_print_statistics PARAMS ((const Hash_table *, FILE *));
+void *hash_lookup PARAMS ((const Hash_table *, const void *));
+
+/* Walking.  */
+void *hash_get_first PARAMS ((const Hash_table *));
+void *hash_get_next PARAMS ((const Hash_table *, const void *));
+unsigned hash_get_entries PARAMS ((const Hash_table *, void **, unsigned));
+unsigned hash_do_for_each PARAMS ((const Hash_table *, Hash_processor, void *));
+
+/* Allocation and clean-up.  */
+unsigned hash_string PARAMS ((const char *, unsigned));
+void hash_reset_tuning PARAMS ((Hash_tuning *));
+Hash_table *hash_initialize PARAMS ((unsigned, const Hash_tuning *,
+				     Hash_hasher, Hash_comparator,
+				     Hash_data_freer));
+void hash_clear PARAMS ((Hash_table *));
+void hash_free PARAMS ((Hash_table *));
+
+/* Insertion and deletion.  */
+bool hash_rehash PARAMS ((Hash_table *, unsigned));
+void *hash_insert PARAMS ((Hash_table *, const void *));
+void *hash_delete PARAMS ((Hash_table *, const void *));
+
+#endif
Index: patch-2.5.9/m4/nanosecond_stat.m4
===================================================================
--- patch-2.5.9.orig/m4/nanosecond_stat.m4	2003-10-07 16:47:24.000000000 +0200
+++ patch-2.5.9/m4/nanosecond_stat.m4	2003-10-07 17:14:48.000000000 +0200
@@ -0,0 +1,35 @@
+AC_DEFUN([ag_CHECK_NANOSECOND_STAT],
+  [AC_CACHE_CHECK([for nanosecond timestamps in struct stat],
+     [ac_cv_stat_nsec],
+     [AC_TRY_COMPILE(
+	[
+	  #include <sys/types.h>
+	  #include <sys/stat.h>
+	  #include <unistd.h>
+	  struct stat st;
+	],
+	[ return st.st_atimensec + st.st_mtimensec + st.st_ctimensec; ],
+	[ac_cv_stat_nsec=yes],
+	[ac_cv_stat_nsec=no])
+     ])
+   if test $ac_cv_stat_nsec = yes; then
+     AC_DEFINE(HAVE_STAT_NSEC, 1, [Define to 1 if struct stat has nanosecond timestamps.])
+   fi
+
+   AC_CACHE_CHECK([for nanosecond timestamps in struct stat],
+     [ac_cv_stat_timeval],
+     [AC_TRY_COMPILE(
+	[
+	  #include <time.h>
+	  #include <sys/types.h>
+	  #include <sys/stat.h>
+	  #include <unistd.h>
+	  struct stat st;
+	],
+	[ return st.st_atim.tv_nsec + st.st_mtim.tv_nsec + st.st_ctim.tv_nsec; ],
+	[ac_cv_stat_timeval=yes],
+	[ac_cv_stat_timeval=no])
+     ])
+   if test $ac_cv_stat_timeval = yes; then
+     AC_DEFINE(HAVE_STAT_TIMEVAL, 1, [Define to 1 if struct stat comtains struct timeval's.])
+   fi])

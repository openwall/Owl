--- ltrace-0.3.10/debian/copyright.orig	Mon Aug 30 15:09:49 1999
+++ ltrace-0.3.10/debian/copyright	Sun Jan 14 20:50:38 2001
@@ -9,6 +9,7 @@
 ARMLinux port: Copyright (C) 1998 Pat Beirne <pbeirne@home.com>
 m68k port: Copyright (C) 1998 Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de>
 Misc fixes: Copyright (C) 1999 Morten Eriksen <mortene@sim.no>
+SPARC port: Copyright (C) 1999 Jakub Jelinek <jakub@redhat.com>
 
 
 Autoconf stuff: Copyright 1992-1996 Free Software Foundation, Inc.
--- ltrace-0.3.10/sysdeps/linux-gnu/i386/breakpoint.c.orig	Fri Sep 25 13:13:56 1998
+++ ltrace-0.3.10/sysdeps/linux-gnu/i386/breakpoint.c	Sun Jan 14 20:50:38 2001
@@ -25,3 +25,8 @@
 	a |= sbp->orig_value[0];
 	ptrace(PTRACE_POKETEXT, pid, sbp->addr, a);
 }
+
+int hit_breakpoint(struct breakpoint * sbp, void * addr)
+{
+	return sbp->addr == addr;
+}
--- ltrace-0.3.10/sysdeps/linux-gnu/i386/ptrace.h.orig	Sun Jan 14 20:50:38 2001
+++ ltrace-0.3.10/sysdeps/linux-gnu/i386/ptrace.h	Sun Jan 14 20:50:38 2001
@@ -0,0 +1 @@
+#include <sys/ptrace.h>
--- ltrace-0.3.10/sysdeps/linux-gnu/i386/regs.c.orig	Fri Sep 25 13:53:28 1998
+++ ltrace-0.3.10/sysdeps/linux-gnu/i386/regs.c	Sun Jan 14 20:50:38 2001
@@ -5,6 +5,7 @@
 #include <sys/types.h>
 #include <sys/ptrace.h>
 #include <asm/ptrace.h>
+#include "ltrace.h"
 
 #if (!defined(PTRACE_PEEKUSER) && defined(PTRACE_PEEKUSR))
 # define PTRACE_PEEKUSER PTRACE_PEEKUSR
@@ -14,18 +15,18 @@
 # define PTRACE_POKEUSER PTRACE_POKEUSR
 #endif
 
-void * get_instruction_pointer(pid_t pid)
+void * get_instruction_pointer(struct process * proc)
 {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, 4*EIP, 0);
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, 4*EIP, 0);
 }
 
-void * get_stack_pointer(pid_t pid)
+void * get_stack_pointer(struct process * proc)
 {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, 4*UESP, 0);
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, 4*UESP, 0);
 }
 
-void * get_return_addr(pid_t pid, void * stack_pointer)
+void * get_return_addr(struct process * proc, void * stack_pointer)
 {
-	return (void *)ptrace(PTRACE_PEEKTEXT, pid, stack_pointer, 0);
+	return (void *)ptrace(PTRACE_PEEKTEXT, proc->pid, stack_pointer, 0);
 }
 
--- ltrace-0.3.10/sysdeps/linux-gnu/i386/trace.c.orig	Fri Sep 25 13:14:30 1998
+++ ltrace-0.3.10/sysdeps/linux-gnu/i386/trace.c	Sun Jan 14 20:50:38 2001
@@ -18,6 +18,10 @@
 # define PTRACE_POKEUSER PTRACE_POKEUSR
 #endif
 
+void get_arch_dep(struct process *proc)
+{
+}
+
 /* Returns 1 if syscall, 2 if sysret, 0 otherwise.
  */
 int syscall_p(struct process * proc, int status, int * sysnum)
@@ -47,15 +51,22 @@
 	}
 }
 
+int continue_enabling_breakpoint(struct process * proc, struct breakpoint * sbp)
+{
+	insert_breakpoint(proc->pid, sbp);
+	continue_process(proc->pid);
+	return 0;
+}
+
 long gimme_arg(enum tof type, struct process * proc, int arg_num)
 {
 	if (arg_num==-1) {		/* return value */
 		return ptrace(PTRACE_PEEKUSER, proc->pid, 4*EAX, 0);
 	}
 
-	if (type==LT_TOF_FUNCTION) {
+	if (type==LT_TOF_FUNCTION || type==LT_TOF_FUNCTIONR) {
 		return ptrace(PTRACE_PEEKTEXT, proc->pid, proc->stack_pointer+4*(arg_num+1), 0);
-	} else if (type==LT_TOF_SYSCALL) {
+	} else if (type==LT_TOF_SYSCALL || type==LT_TOF_SYSCALLR) {
 #if 0
 		switch(arg_num) {
 			case 0:	return ptrace(PTRACE_PEEKUSER, proc->pid, 4*EBX, 0);
@@ -78,17 +89,21 @@
 	return 0;
 }
 
+void save_register_args(enum tof type, struct process * proc)
+{
+}
+
 int umovestr(struct process * proc, void * addr, int len, void * laddr)
 {
-	long a;
+	union { long a; char c[sizeof(long)]; } a;
 	int i;
 	int offset=0;
 
 	while(offset<len) {
-		a = ptrace(PTRACE_PEEKTEXT, proc->pid, addr+offset, 0);
+		a.a = ptrace(PTRACE_PEEKTEXT, proc->pid, addr+offset, 0);
 		for(i=0; i<sizeof(long); i++) {
-			if (((char*)&a)[i] && offset+i < len) {
-				*(char *)(laddr+offset+i) = ((char*)&a)[i];
+			if (a.c[i] && offset+i < len) {
+				*(char *)(laddr+offset+i) = a.c[i];
 			} else {
 				*(char *)(laddr+offset+i) = '\0';
 				return 0;
--- ltrace-0.3.10/sysdeps/linux-gnu/arm/breakpoint.c.orig	Fri Sep 25 13:14:11 1998
+++ ltrace-0.3.10/sysdeps/linux-gnu/arm/breakpoint.c	Sun Jan 14 20:50:38 2001
@@ -25,3 +25,8 @@
 	a = sbp->orig_value[0] + (sbp->orig_value[1]<<8) + (sbp->orig_value[2]<<16) + (sbp->orig_value[3]<<24);
 	ptrace(PTRACE_POKETEXT, pid, sbp->addr, a);
 }
+
+int hit_breakpoint(struct breakpoint * sbp, void * addr)
+{
+	return sbp->addr == addr;
+}
--- ltrace-0.3.10/sysdeps/linux-gnu/arm/ptrace.h.orig	Sun Jan 14 20:50:38 2001
+++ ltrace-0.3.10/sysdeps/linux-gnu/arm/ptrace.h	Sun Jan 14 20:50:38 2001
@@ -0,0 +1 @@
+#include <sys/ptrace.h>
--- ltrace-0.3.10/sysdeps/linux-gnu/arm/regs.c.orig	Fri Sep 25 13:54:24 1998
+++ ltrace-0.3.10/sysdeps/linux-gnu/arm/regs.c	Sun Jan 14 20:50:38 2001
@@ -18,20 +18,20 @@
 #define off_lr 56
 #define off_sp 52
 
-void * get_instruction_pointer(pid_t pid)
+void * get_instruction_pointer(struct process * proc)
 {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, off_pc, 0);
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, off_pc, 0);
 }
 
-void * get_stack_pointer(pid_t pid)
+void * get_stack_pointer(struct process * proc)
 {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, off_sp, 0);
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, off_sp, 0);
 }
 
 /* really, this is given the *stack_pointer expecting
  * a CISC architecture; in our case, we don't need that */
-void * get_return_addr(pid_t pid, void * stack_pointer)
+void * get_return_addr(struct process * proc, void * stack_pointer)
 {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, off_lr, 0);
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, off_lr, 0);
 }
 
--- ltrace-0.3.10/sysdeps/linux-gnu/arm/trace.c.orig	Fri Sep 25 13:14:48 1998
+++ ltrace-0.3.10/sysdeps/linux-gnu/arm/trace.c	Sun Jan 14 20:50:38 2001
@@ -26,6 +26,10 @@
 #define off_ip 48
 #define off_pc 60
 
+void get_arch_dep(struct process *proc)
+{
+}
+
 /* Returns 1 if syscall, 2 if sysret, 0 otherwise.
  */
 int syscall_p(struct process * proc, int status, int * sysnum)
@@ -58,6 +62,13 @@
 	}
 }
 
+int continue_enabling_breakpoint(struct process * proc, struct breakpoint * sbp)
+{
+	insert_breakpoint(proc->pid, sbp);
+	continue_process(proc->pid);
+	return 0;
+}
+
 long gimme_arg(enum tof type, struct process * proc, int arg_num)
 {
 	if (arg_num==-1) {		/* return value */
@@ -65,13 +76,13 @@
 	}
 
 	/* deal with the ARM calling conventions */
-	if (type==LT_TOF_FUNCTION) {
+	if (type==LT_TOF_FUNCTION || type==LT_TOF_FUNCTIONR) {
 		if (arg_num<4) {
 			return ptrace(PTRACE_PEEKUSER, proc->pid, 4*arg_num, 0);
 		} else {
 			return ptrace(PTRACE_PEEKDATA, proc->pid, proc->stack_pointer+4*(arg_num-4), 0);
 		}
-	} else if (type==LT_TOF_SYSCALL) {
+	} else if (type==LT_TOF_SYSCALL || type==LT_TOF_SYSCALLR) {
 		if (arg_num<5) {
 			return ptrace(PTRACE_PEEKUSER, proc->pid, 4*arg_num, 0);
 		} else {
@@ -85,17 +96,21 @@
 	return 0;
 }
 
+void save_register_args(struct process * proc)
+{
+}
+
 int umovestr(struct process * proc, void * addr, int len, void * laddr)
 {
-	long a;
+	union { long a; char c[sizeof(long)]; } a;
 	int i;
 	int offset=0;
 
 	while(offset<len) {
-		a = ptrace(PTRACE_PEEKTEXT, proc->pid, addr+offset, 0);
+		a.a = ptrace(PTRACE_PEEKTEXT, proc->pid, addr+offset, 0);
 		for(i=0; i<sizeof(long); i++) {
-			if (((char*)&a)[i] && offset+i < len) {
-				*(char *)(laddr+offset+i) = ((char*)&a)[i];
+			if (a.c[i] && offset+i < len) {
+				*(char *)(laddr+offset+i) = a.c[i];
 			} else {
 				*(char *)(laddr+offset+i) = '\0';
 				return 0;
--- ltrace-0.3.10/sysdeps/linux-gnu/m68k/breakpoint.c.orig	Fri Sep 25 15:01:25 1998
+++ ltrace-0.3.10/sysdeps/linux-gnu/m68k/breakpoint.c	Sun Jan 14 20:50:38 2001
@@ -26,3 +26,8 @@
 	a |= (sbp->orig_value[0] << 24) | (sbp->orig_value[1] << 16);
 	ptrace(PTRACE_POKETEXT, pid, sbp->addr, a);
 }
+
+int hit_breakpoint(struct breakpoint * sbp, void * addr)
+{
+	return sbp->addr == addr;
+}
--- ltrace-0.3.10/sysdeps/linux-gnu/m68k/ptrace.h.orig	Sun Jan 14 20:50:38 2001
+++ ltrace-0.3.10/sysdeps/linux-gnu/m68k/ptrace.h	Sun Jan 14 20:50:38 2001
@@ -0,0 +1 @@
+#include <sys/ptrace.h>
--- ltrace-0.3.10/sysdeps/linux-gnu/m68k/regs.c.orig	Fri Sep 25 15:01:59 1998
+++ ltrace-0.3.10/sysdeps/linux-gnu/m68k/regs.c	Sun Jan 14 20:50:38 2001
@@ -14,18 +14,18 @@
 # define PTRACE_POKEUSER PTRACE_POKEUSR
 #endif
 
-void * get_instruction_pointer(pid_t pid)
+void * get_instruction_pointer(struct process * proc)
 {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, 4*PT_PC, 0);
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, 4*PT_PC, 0);
 }
 
-void * get_stack_pointer(pid_t pid)
+void * get_stack_pointer(struct process * proc)
 {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, 4*PT_USP, 0);
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, 4*PT_USP, 0);
 }
 
-void * get_return_addr(pid_t pid, void * stack_pointer)
+void * get_return_addr(struct process * proc, void * stack_pointer)
 {
-	return (void *)ptrace(PTRACE_PEEKTEXT, pid, stack_pointer, 0);
+	return (void *)ptrace(PTRACE_PEEKTEXT, proc->pid, stack_pointer, 0);
 }
 
--- ltrace-0.3.10/sysdeps/linux-gnu/m68k/trace.c.orig	Fri Sep 25 15:02:24 1998
+++ ltrace-0.3.10/sysdeps/linux-gnu/m68k/trace.c	Sun Jan 14 20:50:38 2001
@@ -18,6 +18,10 @@
 # define PTRACE_POKEUSER PTRACE_POKEUSR
 #endif
 
+void get_arch_dep(struct process *proc)
+{
+}
+
 /* Returns 1 if syscall, 2 if sysret, 0 otherwise.
  */
 int syscall_p(struct process * proc, int status, int * sysnum)
@@ -48,15 +52,22 @@
 	}
 }
 
+int continue_enabling_breakpoint(struct process * proc, struct breakpoint * sbp)
+{
+	insert_breakpoint(proc->pid, sbp);
+	continue_process(proc->pid);
+	return 0;
+}
+
 long gimme_arg(enum tof type, struct process * proc, int arg_num)
 {
 	if (arg_num==-1) {		/* return value */
 		return ptrace(PTRACE_PEEKUSER, proc->pid, 4*PT_D0, 0);
 	}
 
-	if (type==LT_TOF_FUNCTION) {
+	if (type==LT_TOF_FUNCTION || type==LT_TOF_FUNCTIONR) {
 		return ptrace(PTRACE_PEEKTEXT, proc->pid, proc->stack_pointer+4*(arg_num+1), 0);
-	} else if (type==LT_TOF_SYSCALL) {
+	} else if (type==LT_TOF_SYSCALL || type==LT_TOF_SYSCALLR) {
 #if 0
 		switch(arg_num) {
 			case 0:	return ptrace(PTRACE_PEEKUSER, proc->pid, 4*PT_D1, 0);
@@ -80,17 +91,21 @@
 	return 0;
 }
 
+void save_register_args(struct process * proc)
+{
+}
+
 int umovestr(struct process * proc, void * addr, int len, void * laddr)
 {
-	long a;
+	union { long a; char c[sizeof(long)]; } a;
 	int i;
 	int offset=0;
 
 	while(offset<len) {
-		a = ptrace(PTRACE_PEEKTEXT, proc->pid, addr+offset, 0);
+		a.a = ptrace(PTRACE_PEEKTEXT, proc->pid, addr+offset, 0);
 		for(i=0; i<sizeof(long); i++) {
-			if (((char*)&a)[i] && offset+i < len) {
-				*(char *)(laddr+offset+i) = ((char*)&a)[i];
+			if (a.c[i] && offset+i < len) {
+				*(char *)(laddr+offset+i) = a.c[i];
 			} else {
 				*(char *)(laddr+offset+i) = '\0';
 				return 0;
--- ltrace-0.3.10/sysdeps/linux-gnu/Makefile.orig	Thu Sep 24 14:38:46 1998
+++ ltrace-0.3.10/sysdeps/linux-gnu/Makefile	Sun Jan 14 20:50:38 2001
@@ -1,6 +1,6 @@
 ARCH	:=	$(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
 
-CFLAGS	+=	-I$(TOPDIR)/sysdeps/Linux/$(ARCH)
+CFLAGS	+=	-I$(TOPDIR)/sysdeps/linux-gnu/$(ARCH)
 
 OBJ	=	trace.o proc.o
 
--- ltrace-0.3.10/sysdeps/linux-gnu/sparc/Makefile.orig	Sun Jan 14 20:50:38 2001
+++ ltrace-0.3.10/sysdeps/linux-gnu/sparc/Makefile	Sun Jan 14 20:50:38 2001
@@ -0,0 +1,9 @@
+OBJ	=	breakpoint.o regs.o trace.o
+
+all:		arch.o
+
+arch.o:		$(OBJ)
+		$(LD) -r -o arch.o $(OBJ)
+
+clean:
+		$(RM) $(OBJ) arch.o
--- ltrace-0.3.10/sysdeps/linux-gnu/sparc/arch.h.orig	Sun Jan 14 20:50:38 2001
+++ ltrace-0.3.10/sysdeps/linux-gnu/sparc/arch.h	Sun Jan 14 20:50:38 2001
@@ -0,0 +1,4 @@
+#define BREAKPOINT_VALUE {0x91, 0xd0, 0x20, 0x01}
+#define BREAKPOINT_LENGTH 4
+#define DECR_PC_AFTER_BREAK 0
+
--- ltrace-0.3.10/sysdeps/linux-gnu/sparc/breakpoint.c.orig	Sun Jan 14 20:50:38 2001
+++ ltrace-0.3.10/sysdeps/linux-gnu/sparc/breakpoint.c	Sun Jan 14 20:54:26 2001
@@ -0,0 +1,34 @@
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "ptrace.h"
+#include "ltrace.h"
+
+extern FILE *output;
+extern int opt_d;
+
+void insert_breakpoint(pid_t pid, struct breakpoint * sbp)
+{
+	unsigned int a;
+	unsigned long addr = (unsigned long)sbp->addr;
+
+	if (sbp->plt) addr += 4;
+	a = ptrace(PTRACE_PEEKTEXT, pid, addr, 0);
+	*(unsigned int *)sbp->orig_value = a;
+	a = 0x91d02001;
+	ptrace(PTRACE_POKETEXT, pid, addr, a);
+}
+
+void delete_breakpoint(pid_t pid, struct breakpoint * sbp)
+{
+	unsigned long addr = (unsigned long)sbp->addr;
+
+	if (sbp->plt) addr += 4;
+	ptrace(PTRACE_POKETEXT, pid, addr, *(int *)sbp->orig_value);
+}
+
+int hit_breakpoint(struct breakpoint * sbp, void * addr)
+{
+	return (unsigned long)sbp->addr + (sbp->plt ? 4 : 0) == (unsigned long)addr;
+}
--- ltrace-0.3.10/sysdeps/linux-gnu/sparc/ptrace.h.orig	Sun Jan 14 20:50:38 2001
+++ ltrace-0.3.10/sysdeps/linux-gnu/sparc/ptrace.h	Sun Jan 14 20:50:38 2001
@@ -0,0 +1,22 @@
+#undef PTRACE_GETREGS
+#undef PTRACE_SETREGS
+#undef PTRACE_GETFPREGS
+#undef PTRACE_SETFPREGS
+#include <sys/ptrace.h>
+#ifndef PTRACE_SUNDETACH
+#define PTRACE_SUNDETACH 11
+#endif
+#undef PT_DETACH
+#undef PTRACE_DETACH
+#define PT_DETACH PTRACE_SUNDETACH
+#define PTRACE_DETACH PTRACE_SUNDETACH
+
+#include <asm/reg.h>
+#include "ltrace.h"
+
+typedef struct {
+	int valid;
+	struct regs regs;
+	unsigned int func_arg[6];
+	unsigned int sysc_arg[6];
+} proc_archdep;
--- ltrace-0.3.10/sysdeps/linux-gnu/sparc/regs.c.orig	Sun Jan 14 20:50:38 2001
+++ ltrace-0.3.10/sysdeps/linux-gnu/sparc/regs.c	Sun Jan 14 20:50:38 2001
@@ -0,0 +1,36 @@
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <sys/types.h>
+#include "ptrace.h"
+#include "ltrace.h"
+
+void * get_instruction_pointer(struct process * proc)
+{
+	proc_archdep *a = (proc_archdep *)(proc->arch_ptr);
+	if (a->valid)
+		return (void *)a->regs.r_pc;
+	return (void *)-1;
+}
+
+void * get_stack_pointer(struct process * proc)
+{
+	proc_archdep *a = (proc_archdep *)(proc->arch_ptr);
+	if (a->valid)
+		return (void *)a->regs.r_o6;
+	return (void *)-1;
+}
+
+void * get_return_addr(struct process * proc, void * stack_pointer)
+{
+	proc_archdep *a = (proc_archdep *)(proc->arch_ptr);
+	unsigned int t;
+	if (!a->valid)
+		return (void *)-1;
+	/* Work around structure returns */
+	t = ptrace(PTRACE_PEEKTEXT, proc->pid, a->regs.r_o7 + 8, 0);
+	if (t < 0x400000)
+		return (void *)a->regs.r_o7 + 12;
+	return (void *)a->regs.r_o7 + 8;
+}
--- ltrace-0.3.10/sysdeps/linux-gnu/sparc/signalent.h.orig	Sun Jan 14 20:50:38 2001
+++ ltrace-0.3.10/sysdeps/linux-gnu/sparc/signalent.h	Sun Jan 14 20:50:38 2001
@@ -0,0 +1,32 @@
+	"SIG_0",           /* 0 */
+	"SIGHUP",          /* 1 */
+	"SIGINT",          /* 2 */
+	"SIGQUIT",         /* 3 */
+	"SIGILL",          /* 4 */
+	"SIGTRAP",         /* 5 */
+	"SIGABRT",         /* 6 */
+	"SIGEMT",          /* 7 */
+	"SIGFPE",          /* 8 */
+	"SIGKILL",         /* 9 */
+	"SIGBUS",          /* 10 */
+	"SIGSEGV",         /* 11 */
+	"SIGSYS",          /* 12 */
+	"SIGPIPE",         /* 13 */
+	"SIGALRM",         /* 14 */
+	"SIGTERM",         /* 15 */
+	"SIGURG",          /* 16 */
+	"SIGSTOP",         /* 17 */
+	"SIGTSTP",         /* 18 */
+	"SIGCONT",         /* 19 */
+	"SIGCHLD",         /* 20 */
+	"SIGTTIN",         /* 21 */
+	"SIGTTOU",         /* 22 */
+	"SIGIO",           /* 23 */
+	"SIGXCPU",         /* 24 */
+	"SIGXFSZ",         /* 25 */
+	"SIGVTALRM",       /* 26 */
+	"SIGPROF",         /* 27 */
+	"SIGWINCH",        /* 28 */
+	"SIGLOST",         /* 29 */
+	"SIGUSR1",         /* 30 */
+	"SIGUSR2",         /* 31 */
--- ltrace-0.3.10/sysdeps/linux-gnu/sparc/syscallent.h.orig	Sun Jan 14 20:50:38 2001
+++ ltrace-0.3.10/sysdeps/linux-gnu/sparc/syscallent.h	Sun Jan 14 20:50:38 2001
@@ -0,0 +1,256 @@
+	"0",                               /* 0 */
+	"exit",                            /* 1 */
+	"fork",                            /* 2 */
+	"read",                            /* 3 */
+	"write",                           /* 4 */
+	"open",                            /* 5 */
+	"close",                           /* 6 */
+	"wait4",                           /* 7 */
+	"creat",                           /* 8 */
+	"link",                            /* 9 */
+	"unlink",                          /* 10 */
+	"execv",                           /* 11 */
+	"chdir",                           /* 12 */
+	"chown",                           /* 13 */
+	"mknod",                           /* 14 */
+	"chmod",                           /* 15 */
+	"lchown",                          /* 16 */
+	"brk",                             /* 17 */
+	"perfctr",                         /* 18 */
+	"lseek",                           /* 19 */
+	"getpid",                          /* 20 */
+	"capget",                          /* 21 */
+	"capset",                          /* 22 */
+	"setuid",                          /* 23 */
+	"getuid",                          /* 24 */
+	"25",                              /* 25 */
+	"ptrace",                          /* 26 */
+	"alarm",                           /* 27 */
+	"sigaltstack",                     /* 28 */
+	"pause",                           /* 29 */
+	"utime",                           /* 30 */
+	"31",                              /* 31 */
+	"32",                              /* 32 */
+	"access",                          /* 33 */
+	"nice",                            /* 34 */
+	"35",                              /* 35 */
+	"sync",                            /* 36 */
+	"kill",                            /* 37 */
+	"stat",                            /* 38 */
+	"sendfile",                        /* 39 */
+	"lstat",                           /* 40 */
+	"dup",                             /* 41 */
+	"pipe",                            /* 42 */
+	"times",                           /* 43 */
+	"44",                              /* 44 */
+	"umount2",                         /* 45 */
+	"setgid",                          /* 46 */
+	"getgid",                          /* 47 */
+	"signal",                          /* 48 */
+	"geteuid",                         /* 49 */
+	"getegid",                         /* 50 */
+	"acct",                            /* 51 */
+	"memory_ordering",                 /* 52 */
+	"53",                              /* 53 */
+	"ioctl",                           /* 54 */
+	"reboot",                          /* 55 */
+	"56",                              /* 56 */
+	"symlink",                         /* 57 */
+	"readlink",                        /* 58 */
+	"execve",                          /* 59 */
+	"umask",                           /* 60 */
+	"chroot",                          /* 61 */
+	"fstat",                           /* 62 */
+	"63",                              /* 63 */
+	"getpagesize",                     /* 64 */
+	"msync",                           /* 65 */
+	"vfork",                           /* 66 */
+	"pread",                           /* 67 */
+	"pwrite",                          /* 68 */
+	"69",                              /* 69 */
+	"70",                              /* 70 */
+	"mmap",                            /* 71 */
+	"72",                              /* 72 */
+	"munmap",                          /* 73 */
+	"mprotect",                        /* 74 */
+	"75",                              /* 75 */
+	"vhangup",                         /* 76 */
+	"77",                              /* 77 */
+	"78",                              /* 78 */
+	"getgroups",                       /* 79 */
+	"setgroups",                       /* 80 */
+	"getpgrp",                         /* 81 */
+	"82",                              /* 82 */
+	"setitimer",                       /* 83 */
+	"84",                              /* 84 */
+	"swapon",                          /* 85 */
+	"getitimer",                       /* 86 */
+	"87",                              /* 87 */
+	"sethostname",                     /* 88 */
+	"89",                              /* 89 */
+	"dup2",                            /* 90 */
+	"91",                              /* 91 */
+	"fcntl",                           /* 92 */
+	"select",                          /* 93 */
+	"94",                              /* 94 */
+	"fsync",                           /* 95 */
+	"setpriority",                     /* 96 */
+	"socket",                          /* 97 */
+	"connect",                         /* 98 */
+	"accept",                          /* 99 */
+	"getpriority",                     /* 100 */
+	"rt_sigreturn",                    /* 101 */
+	"rt_sigaction",                    /* 102 */
+	"rt_sigprocmask",                  /* 103 */
+	"rt_sigpending",                   /* 104 */
+	"rt_sigtimedwait",                 /* 105 */
+	"rt_sigqueueinfo",                 /* 106 */
+	"rt_sigsuspend",                   /* 107 */
+	"108",                             /* 108 */
+	"109",                             /* 109 */
+	"110",                             /* 110 */
+	"111",                             /* 111 */
+	"112",                             /* 112 */
+	"recvmsg",                         /* 113 */
+	"sendmsg",                         /* 114 */
+	"115",                             /* 115 */
+	"gettimeofday",                    /* 116 */
+	"getrusage",                       /* 117 */
+	"getsockopt",                      /* 118 */
+	"getcwd",                          /* 119 */
+	"readv",                           /* 120 */
+	"writev",                          /* 121 */
+	"settimeofday",                    /* 122 */
+	"fchown",                          /* 123 */
+	"fchmod",                          /* 124 */
+	"recvfrom",                        /* 125 */
+	"setreuid",                        /* 126 */
+	"setregid",                        /* 127 */
+	"rename",                          /* 128 */
+	"truncate",                        /* 129 */
+	"ftruncate",                       /* 130 */
+	"flock",                           /* 131 */
+	"132",                             /* 132 */
+	"sendto",                          /* 133 */
+	"shutdown",                        /* 134 */
+	"socketpair",                      /* 135 */
+	"mkdir",                           /* 136 */
+	"rmdir",                           /* 137 */
+	"utimes",                          /* 138 */
+	"139",                             /* 139 */
+	"140",                             /* 140 */
+	"getpeername",                     /* 141 */
+	"142",                             /* 142 */
+	"143",                             /* 143 */
+	"getrlimit",                       /* 144 */
+	"setrlimit",                       /* 145 */
+	"146",                             /* 146 */
+	"prctl",                           /* 147 */
+	"pciconfig_read",                  /* 148 */
+	"pciconfig_write",                 /* 149 */
+	"getsockname",                     /* 150 */
+	"151",                             /* 151 */
+	"152",                             /* 152 */
+	"poll",                            /* 153 */
+	"154",                             /* 154 */
+	"155",                             /* 155 */
+	"156",                             /* 156 */
+	"statfs",                          /* 157 */
+	"fstatfs",                         /* 158 */
+	"umount",                          /* 159 */
+	"160",                             /* 160 */
+	"161",                             /* 161 */
+	"getdomainname",                   /* 162 */
+	"setdomainname",                   /* 163 */
+	"utrap_install",                   /* 164 */
+	"quotactl",                        /* 165 */
+	"166",                             /* 166 */
+	"mount",                           /* 167 */
+	"ustat",                           /* 168 */
+	"169",                             /* 169 */
+	"170",                             /* 170 */
+	"171",                             /* 171 */
+	"172",                             /* 172 */
+	"173",                             /* 173 */
+	"getdents",                        /* 174 */
+	"setsid",                          /* 175 */
+	"fchdir",                          /* 176 */
+	"177",                             /* 177 */
+	"178",                             /* 178 */
+	"179",                             /* 179 */
+	"180",                             /* 180 */
+	"181",                             /* 181 */
+	"182",                             /* 182 */
+	"sigpending",                      /* 183 */
+	"query_module",                    /* 184 */
+	"setpgid",                         /* 185 */
+	"186",                             /* 186 */
+	"187",                             /* 187 */
+	"188",                             /* 188 */
+	"uname",                           /* 189 */
+	"init_module",                     /* 190 */
+	"personality",                     /* 191 */
+	"192",                             /* 192 */
+	"193",                             /* 193 */
+	"194",                             /* 194 */
+	"195",                             /* 195 */
+	"196",                             /* 196 */
+	"getppid",                         /* 197 */
+	"sigaction",                       /* 198 */
+	"sgetmask",                        /* 199 */
+	"ssetmask",                        /* 200 */
+	"sigsuspend",                      /* 201 */
+	"oldlstat",                        /* 202 */
+	"uselib",                          /* 203 */
+	"readdir",                         /* 204 */
+	"205",                             /* 205 */
+	"socketcall",                      /* 206 */
+	"syslog",                          /* 207 */
+	"208",                             /* 208 */
+	"209",                             /* 209 */
+	"idle",                            /* 210 */
+	"211",                             /* 211 */
+	"waitpid",                         /* 212 */
+	"swapoff",                         /* 213 */
+	"sysinfo",                         /* 214 */
+	"ipc",                             /* 215 */
+	"sigreturn",                       /* 216 */
+	"clone",                           /* 217 */
+	"218",                             /* 218 */
+	"adjtimex",                        /* 219 */
+	"sigprocmask",                     /* 220 */
+	"create_module",                   /* 221 */
+	"delete_module",                   /* 222 */
+	"get_kernel_syms",                 /* 223 */
+	"getpgid",                         /* 224 */
+	"bdflush",                         /* 225 */
+	"sysfs",                           /* 226 */
+	"afs_syscall",                     /* 227 */
+	"setfsuid",                        /* 228 */
+	"setfsgid",                        /* 229 */
+	"_newselect",                      /* 230 */
+	"time",                            /* 231 */
+	"232",                             /* 232 */
+	"stime",                           /* 233 */
+	"234",                             /* 234 */
+	"235",                             /* 235 */
+	"_llseek",                         /* 236 */
+	"mlock",                           /* 237 */
+	"munlock",                         /* 238 */
+	"mlockall",                        /* 239 */
+	"munlockall",                      /* 240 */
+	"sched_setparam",                  /* 241 */
+	"sched_getparam",                  /* 242 */
+	"sched_setscheduler",              /* 243 */
+	"sched_getscheduler",              /* 244 */
+	"sched_yield",                     /* 245 */
+	"sched_get_priority_max",          /* 246 */
+	"sched_get_priority_min",          /* 247 */
+	"sched_rr_get_interval",           /* 248 */
+	"nanosleep",                       /* 249 */
+	"mremap",                          /* 250 */
+	"_sysctl",                         /* 251 */
+	"getsid",                          /* 252 */
+	"fdatasync",                       /* 253 */
+	"nfsservctl",                      /* 254 */
+	"aplib",                           /* 255 */
--- ltrace-0.3.10/sysdeps/linux-gnu/sparc/trace.c.orig	Sun Jan 14 20:50:38 2001
+++ ltrace-0.3.10/sysdeps/linux-gnu/sparc/trace.c	Sun Jan 14 20:50:38 2001
@@ -0,0 +1,120 @@
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <signal.h>
+#include "ptrace.h"
+#include "ltrace.h"
+
+extern FILE *output;
+extern int opt_d;
+
+void get_arch_dep(struct process *proc)
+{
+	proc_archdep *a;
+	if (!proc->arch_ptr)
+		proc->arch_ptr = (void *)malloc(sizeof(proc_archdep));
+	a = (proc_archdep *)(proc->arch_ptr);
+	a->valid = (ptrace (PTRACE_GETREGS, proc->pid, &a->regs, 0) >= 0);
+}
+
+/* Returns syscall number if `pid' stopped because of a syscall.
+ * Returns -1 otherwise
+ */
+int syscall_p(struct process *proc, int status, int *sysnum)
+{
+	if (WIFSTOPPED(status) && WSTOPSIG(status)==SIGTRAP) {
+		void *ip = get_instruction_pointer(proc);
+		unsigned int insn;
+		if (ip == (void *)-1) return 0;
+		insn = ptrace(PTRACE_PEEKTEXT, proc->pid, ip, 0);
+		if ((insn & 0xc1f8007f) == 0x81d00010) {
+			*sysnum = ((proc_archdep *)proc->arch_ptr)->regs.r_g1;
+			if (proc->current_syscall!=*sysnum) {
+				return 1;
+			} else {
+				return 2;
+			}
+		}
+	}
+	return 0;
+}
+
+void continue_after_breakpoint(struct process * proc, struct breakpoint * sbp, int delete_it)
+{
+	delete_breakpoint(proc->pid, sbp);
+	if (delete_it) {
+		continue_process(proc->pid);
+	} else {
+		proc->breakpoint_being_enabled = sbp;
+		continue_process(proc->pid);
+	}
+}
+
+int continue_enabling_breakpoint(struct process * proc, struct breakpoint * sbp)
+{
+	insert_breakpoint(proc->pid, sbp);
+	return 1;
+}
+
+long gimme_arg(enum tof type, struct process * proc, int arg_num)
+{
+	proc_archdep * a = (proc_archdep *)proc->arch_ptr;
+	if (!a->valid) {
+		fprintf(stderr, "Could not get child registers\n");
+		exit(1);
+	}
+	if (arg_num==-1)		/* return value */
+		return a->regs.r_o0;
+
+	if (type==LT_TOF_FUNCTION || type==LT_TOF_SYSCALL || arg_num >= 6) {
+		if (arg_num < 6)
+			return ((int *)&a->regs.r_o0)[arg_num];
+		return ptrace(PTRACE_PEEKTEXT, proc->pid, proc->stack_pointer+64*(arg_num + 1));
+	} else if (type==LT_TOF_FUNCTIONR)
+		return a->func_arg[arg_num];
+	else if (type==LT_TOF_SYSCALLR)
+		return a->sysc_arg[arg_num];
+	else {
+		fprintf(stderr, "gimme_arg called with wrong arguments\n");
+		exit(1);
+	}
+	return 0;
+}
+
+void save_register_args(enum tof type, struct process * proc)
+{
+	proc_archdep * a = (proc_archdep *)proc->arch_ptr;
+	if (a->valid) {
+		if (type == LT_TOF_FUNCTION)
+			memcpy(a->func_arg, &a->regs.r_o0, sizeof(a->func_arg));
+		else
+			memcpy(a->sysc_arg, &a->regs.r_o0, sizeof(a->sysc_arg));
+	}
+}
+
+int umovestr(struct process * proc, void * addr, int len, void * laddr)
+{
+	int i;
+	union { int a; char c[4]; } a;
+	int offset;
+
+	offset = - ((long)addr & 3);
+	while(offset<len) {
+		a.a = ptrace(PTRACE_PEEKTEXT, proc->pid, addr+offset, 0);
+		for(i=offset < 0 ? -offset : 0; i<sizeof(int); i++) {
+			if (a.c[i] && offset+i < len) {
+				*(char *)(laddr+offset+i) = a.c[i];
+			} else {
+				*(char *)(laddr+offset+i) = '\0';
+				return 0;
+			}
+		}
+		offset += sizeof(int);
+	}
+	*(char *)(laddr+offset) = '\0';
+	return 0;
+}
--- ltrace-0.3.10/sysdeps/linux-gnu/trace.c.orig	Mon Mar 29 00:21:23 1999
+++ ltrace-0.3.10/sysdeps/linux-gnu/trace.c	Sun Jan 14 20:50:38 2001
@@ -2,7 +2,7 @@
 #include <string.h>
 #include <errno.h>
 #include <sys/types.h>
-#include <sys/ptrace.h>
+#include "ptrace.h"
 #include <asm/unistd.h>
 
 #include "ltrace.h"
@@ -72,10 +72,4 @@
 void continue_process(pid_t pid)
 {
 	continue_after_signal(pid, 0);
-}
-
-void continue_enabling_breakpoint(pid_t pid, struct breakpoint * sbp)
-{
-	insert_breakpoint(pid, sbp);
-	continue_process(pid);
 }
--- ltrace-0.3.10/README.orig	Mon Aug 30 15:09:18 1999
+++ ltrace-0.3.10/README	Sun Jan 14 20:50:38 2001
@@ -25,6 +25,7 @@
 * Pat Beirne <pbeirne@home.com> (ARM port)
 * Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de> (m68k port)
 * Morten Eriksen <mortene@sim.no> (misc fixes)
+* Jakub Jelinek <jakub@redhat.com> (SPARC port)
 
 1. Introduction
 ---------------
@@ -49,7 +50,7 @@
 4. Where does it work
 ---------------------
 At the time of writting, it works only with ELF32 executables. It only
-works in Linux, and it only works on i386, m68k, and ARM processors.
+works in Linux, and it only works on i386, m68k, sparc and ARM processors.
 
 5. Bugs
 -------
--- ltrace-0.3.10/display_args.c.orig	Sun Mar 28 23:47:11 1999
+++ ltrace-0.3.10/display_args.c	Sun Jan 14 20:50:38 2001
@@ -85,7 +85,7 @@
 static int display_string(enum tof type, struct process * proc, int arg_num)
 {
 	void * addr;
-	char * str1;
+	unsigned char * str1;
 	int i;
 	int len=0;
 
@@ -141,7 +141,7 @@
 static int display_format(enum tof type, struct process * proc, int arg_num)
 {
 	void * addr;
-	char * str1;
+	unsigned char * str1;
 	int i;
 	int len=0;
 
@@ -170,7 +170,7 @@
 	for(i=0; str1[i]; i++) {
 		if (str1[i]=='%') {
 			while(1) {
-				char c = str1[++i];
+				unsigned char c = str1[++i];
 				if (c == '%') {
 					break;
 				} else if (!c) {
--- ltrace-0.3.10/elf.c.orig	Fri Aug  6 18:17:51 1999
+++ ltrace-0.3.10/elf.c	Sun Jan 14 20:50:38 2001
@@ -98,8 +98,9 @@
 				perror("ltrace: malloc");
 				exit(1);
 			}
+			memset(&library_symbols->brk, 0, sizeof(library_symbols->brk));
 			library_symbols->brk.addr = (void *)((symtab+i)->st_value);
-			library_symbols->brk.enabled = 0;
+			library_symbols->brk.plt = 1;
 			library_symbols->name = strtab+(symtab+i)->st_name;
 			library_symbols->next = tmp;
 			if (opt_d>1) {
--- ltrace-0.3.10/ltrace.1.orig	Fri Jan 15 01:21:14 1999
+++ ltrace-0.3.10/ltrace.1	Sun Jan 14 20:50:38 2001
@@ -116,7 +116,7 @@
 .LP
 Option -f sometimes fails to trace some children.
 .LP
-It only works on Linux/i386, Linux/m68k, and Linux/arm
+It only works on Linux/i386, Linux/m68k, Linux/sparc and Linux/arm
 .LP
 Only ELF32 binaries are supported
 .PP
--- ltrace-0.3.10/ltrace.c.orig	Sat Sep 26 01:44:07 1998
+++ ltrace-0.3.10/ltrace.c	Sun Jan 14 20:50:38 2001
@@ -38,7 +38,8 @@
 	read_config_file("/etc/ltrace.conf");
 	if (getenv("HOME")) {
 		char path[PATH_MAX];
-		sprintf(path, getenv("HOME"));	/* FIXME: buffer overrun */
+		strncpy(path, getenv("HOME"), PATH_MAX - 14);
+		path[PATH_MAX - 14] = 0;
 		strcat(path, "/.ltrace.conf");
 		read_config_file(path);
 	}
--- ltrace-0.3.10/ltrace.h.orig	Sun Mar 28 23:48:21 1999
+++ ltrace-0.3.10/ltrace.h	Sun Jan 14 20:50:38 2001
@@ -16,7 +16,8 @@
 struct breakpoint {
 	void * addr;
 	unsigned char orig_value[BREAKPOINT_LENGTH];
-	int enabled;
+	int enabled:1;
+	int plt:1;
 };
 
 enum arg_type {
@@ -39,7 +40,9 @@
 enum tof {
 	LT_TOF_NONE=0,
 	LT_TOF_FUNCTION,	/* A real library function */
-	LT_TOF_SYSCALL		/* A syscall */
+	LT_TOF_FUNCTIONR,	/* Return from a real library function */
+	LT_TOF_SYSCALL,		/* A syscall */
+	LT_TOF_SYSCALLR,	/* Return from a syscall */
 };
 
 struct function {
@@ -76,6 +79,7 @@
 	void * stack_pointer;		/* To get return addr, args... */
 	void * return_addr;
 	struct breakpoint * breakpoint_being_enabled;
+	void * arch_ptr;
 
 	/* output: */
 	enum tof type_being_displayed;
@@ -122,19 +126,22 @@
 extern void trace_me(void);
 extern int trace_pid(pid_t pid);
 extern void untrace_pid(pid_t pid);
-extern void * get_instruction_pointer(pid_t pid);
-extern void * get_stack_pointer(pid_t pid);
-extern void * get_return_addr(pid_t pid, void * stack_pointer);
+extern void get_arch_dep(struct process * proc);
+extern void * get_instruction_pointer(struct process * proc);
+extern void * get_stack_pointer(struct process * proc);
+extern void * get_return_addr(struct process *, void * stack_pointer);
 extern void insert_breakpoint(pid_t pid, struct breakpoint * sbp);
 extern void delete_breakpoint(pid_t pid, struct breakpoint * sbp);
+extern int hit_breakpoint(struct breakpoint * sbp, void * addr);
 extern int fork_p(int sysnum);
 extern int exec_p(int sysnum);
 extern int syscall_p(struct process * proc, int status, int * sysnum);
 extern void continue_process(pid_t pid);
 extern void continue_after_signal(pid_t pid, int signum);
 extern void continue_after_breakpoint(struct process * proc, struct breakpoint * sbp, int delete_it);
-extern void continue_enabling_breakpoint(pid_t pid, struct breakpoint * sbp);
+extern int continue_enabling_breakpoint(struct process * proc, struct breakpoint * sbp);
 extern long gimme_arg(enum tof type, struct process * proc, int arg_num);
+extern void save_register_args(enum tof type, struct process * proc);
 extern int umovestr(struct process * proc, void * addr, int len, void * laddr);
 #if 0	/* not yet */
 extern int umoven(struct process * proc, void * addr, int len, void * laddr);
--- ltrace-0.3.10/output.c.orig	Mon Aug 30 15:44:19 1999
+++ ltrace-0.3.10/output.c	Sun Jan 14 20:50:38 2001
@@ -73,7 +73,7 @@
 		}
 	}
 	if (opt_i) {
-		if (type==LT_TOF_FUNCTION) {
+		if (type==LT_TOF_FUNCTION || type==LT_TOF_FUNCTIONR) {
 			current_column += fprintf(output, "[%08x] ",
 				(unsigned)proc->return_addr);
 		} else {
@@ -176,11 +176,12 @@
 		}
 		if (func->num_params>func->params_right) {
 			current_column += display_arg(type, proc, i, func->arg_types[i]);
-			if (func->params_right) {
+			if (func->params_right)
 				current_column += fprintf(output, ", ");
-			}
 		}
-		if (!func->params_right && func->return_type == ARGTYPE_VOID) {
+		if (func->params_right)
+			save_register_args(type, proc);
+		else if (func->return_type == ARGTYPE_VOID) {
 			current_column += fprintf(output, ") ");
 			tabto(opt_a);
 			fprintf(output, "= <void>\n");
--- ltrace-0.3.10/proc.c.orig	Fri Sep 25 13:13:01 1998
+++ ltrace-0.3.10/proc.c	Sun Jan 14 20:50:38 2001
@@ -20,13 +20,10 @@
 		perror("malloc");
 		exit(1);
 	}
+	memset (proc, 0, sizeof (struct process));
 	proc->filename = filename;
-	proc->pid = 0;
 	proc->breakpoints_enabled = -1;
 	proc->current_syscall = -1;
-	proc->current_symbol = NULL;
-	proc->breakpoint_being_enabled = NULL;
-	proc->next = NULL;
 	if (opt_L && filename) {
 		proc->list_of_symbols = read_elf(filename);
 		if (opt_e) {
@@ -48,8 +45,6 @@
 				}
 			}
 		}
-	} else {
-		proc->list_of_symbols = NULL;
 	}
 
 	proc->next = list_of_processes;
--- ltrace-0.3.10/process_event.c.orig	Fri Sep 25 13:13:09 1998
+++ ltrace-0.3.10/process_event.c	Sun Jan 14 20:50:38 2001
@@ -169,10 +169,10 @@
 static void process_sysret(struct event * event)
 {
 	if (opt_S) {
-		output_right(LT_TOF_SYSCALL, event->proc, sysname(event->e_un.sysnum));
+		output_right(LT_TOF_SYSCALLR, event->proc, sysname(event->e_un.sysnum));
 	}
 	if (exec_p(event->e_un.sysnum)) {
-		if (gimme_arg(LT_TOF_SYSCALL,event->proc,-1)==0) {
+		if (gimme_arg(LT_TOF_SYSCALLR,event->proc,-1)==0) {
 			event->proc->filename = pid2name(event->proc->pid);
 			event->proc->list_of_symbols = read_elf(event->proc->filename);
 			event->proc->breakpoints_enabled = -1;
@@ -182,7 +182,7 @@
 	}
 	if (fork_p(event->e_un.sysnum)) {
 		if (opt_f) {
-			pid_t child = gimme_arg(LT_TOF_SYSCALL,event->proc,-1);
+			pid_t child = gimme_arg(LT_TOF_SYSCALLR,event->proc,-1);
 			if (child>0) {
 				open_pid(child, 0);
 			}
@@ -196,17 +196,18 @@
 static void process_breakpoint(struct event * event)
 {
 	struct library_symbol * tmp;
+	int ret;
 
 	if (opt_d>1) {
 		output_line(0,"event: breakpoint (0x%08x)", event->e_un.brk_addr);
 	}
 	if (event->proc->breakpoint_being_enabled) {
-		continue_enabling_breakpoint(event->proc->pid, event->proc->breakpoint_being_enabled);
+		ret = continue_enabling_breakpoint(event->proc, event->proc->breakpoint_being_enabled);
 		event->proc->breakpoint_being_enabled = NULL;
-		return;
+		if (!ret) return;
 	}
-	if (event->proc->current_symbol && event->e_un.brk_addr == event->proc->return_value.addr) {
-		output_right(LT_TOF_FUNCTION, event->proc, event->proc->current_symbol->name);
+	if (event->proc->current_symbol && hit_breakpoint(&event->proc->return_value, event->e_un.brk_addr)) {
+		output_right(LT_TOF_FUNCTIONR, event->proc, event->proc->current_symbol->name);
 		continue_after_breakpoint(event->proc, &event->proc->return_value, 1);
 		event->proc->current_symbol = NULL;
 		return;
@@ -214,13 +215,13 @@
 
 	tmp = event->proc->list_of_symbols;
 	while(tmp) {
-		if (event->e_un.brk_addr == tmp->brk.addr) {
+		if (hit_breakpoint(&tmp->brk, event->e_un.brk_addr)) {
 			if (event->proc->current_symbol) {
 				delete_breakpoint(event->proc->pid, &event->proc->return_value);
 			}
 			event->proc->current_symbol = tmp;
-			event->proc->stack_pointer = get_stack_pointer(event->proc->pid);
-			event->proc->return_addr = get_return_addr(event->proc->pid, event->proc->stack_pointer);
+			event->proc->stack_pointer = get_stack_pointer(event->proc);
+			event->proc->return_addr = get_return_addr(event->proc, event->proc->stack_pointer);
 			output_left(LT_TOF_FUNCTION, event->proc, tmp->name);
 			event->proc->return_value.addr = event->proc->return_addr;
 			insert_breakpoint(event->proc->pid, &event->proc->return_value);
--- ltrace-0.3.10/wait_for_something.c.orig	Fri Sep 25 13:16:39 1998
+++ ltrace-0.3.10/wait_for_something.c	Sun Jan 14 20:50:38 2001
@@ -53,6 +53,7 @@
 		fprintf(stderr, "signal from wrong pid %u ?!?\n", pid);
 		exit(1);
 	}
+	get_arch_dep(event.proc);
 	event.proc->instruction_pointer = NULL;
 	if (opt_d>2) {
 		output_line(0,"signal from pid %u", pid);
@@ -64,7 +65,7 @@
 		return &event;
 	}
 	if (opt_i) {
-		event.proc->instruction_pointer = get_instruction_pointer(pid);
+		event.proc->instruction_pointer = get_instruction_pointer(event.proc);
 	}
 	switch(syscall_p(event.proc, status, &tmp)) {
 		case 1:	event.thing = LT_EV_SYSCALL;
@@ -96,7 +97,7 @@
 	}
 	event.thing = LT_EV_BREAKPOINT;
 	if (!event.proc->instruction_pointer) {
-		event.proc->instruction_pointer = get_instruction_pointer(pid);
+		event.proc->instruction_pointer = get_instruction_pointer(event.proc);
 	}
 	event.e_un.brk_addr = event.proc->instruction_pointer - DECR_PC_AFTER_BREAK;
 	return &event;
--- ltrace-0.3.10/TODO.orig	Sun Mar 28 23:13:22 1999
+++ ltrace-0.3.10/TODO	Sun Jan 14 20:50:38 2001
@@ -19,5 +19,5 @@
     \- Is this still true?
 * Option -T (print time spent in each libcall)
 * Option -c (summary)
-* More architectures: sparc, alpha
+* More architectures: sparc64, alpha
 * More operating systems (solaris?)

diff -urpN linux-2.6.18-408.el5.028stab120.1/Documentation/sysctl/fs.txt linux-2.6.18-408.el5.028stab120.1-owl/Documentation/sysctl/fs.txt
--- linux-2.6.18-408.el5.028stab120.1/Documentation/sysctl/fs.txt	2016-01-25 08:11:36 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/Documentation/sysctl/fs.txt	2017-06-06 21:06:19 +0000
@@ -26,6 +26,7 @@ Currently, these files are in /proc/sys/
 - nr_open
 - overflowuid
 - overflowgid
+- protected_hardlinks
 - suid_dumpable
 - super-max
 - super-nr
@@ -145,6 +146,26 @@ The default is 65534.
 
 ==============================================================
 
+protected_hardlinks:
+
+A long-standing class of security issues is the hardlink-based
+time-of-check-time-of-use race, most commonly seen in world-writable
+directories like /tmp. The common method of exploitation of this flaw
+is to cross privilege boundaries when following a given hardlink (i.e. a
+root process follows a hardlink created by another user). Additionally,
+on systems without separated partitions, this stops unauthorized users
+from "pinning" vulnerable setuid/setgid files against being upgraded by
+the administrator, or linking to special files.
+
+When set to "0", hardlink creation behavior is unrestricted.
+
+When set to "1" hardlinks cannot be created by users if they do not
+already own the source file, or do not have read/write access to it.
+
+This protection is based on the restrictions in Openwall and grsecurity.
+
+==============================================================
+
 suid_dumpable:
 
 This value can be used to query and set the core dump mode for setuid
diff -urpN linux-2.6.18-408.el5.028stab120.1/Documentation/sysctl/kernel.txt linux-2.6.18-408.el5.028stab120.1-owl/Documentation/sysctl/kernel.txt
--- linux-2.6.18-408.el5.028stab120.1/Documentation/sysctl/kernel.txt	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/Documentation/sysctl/kernel.txt	2016-08-23 15:41:27 +0000
@@ -142,8 +142,8 @@ dmesg(8) to view messages from the kerne
 dmesg_restrict is set to 0 there are no restrictions.  When
 dmesg_restrict is set to 1, users must have CAP_SYS_ADMIN to use
 dmesg(8) on the hardware node.
-Inside containers dmesg_restrict is ignored becasue virtualized dmesg buffer
-contains safe kernel messages only.
+Inside containers dmesg_restrict is ignored because the virtualized dmesg
+buffer contains safe kernel messages only.
 
 The kernel config option CONFIG_SECURITY_DMESG_RESTRICT sets the default
 value of dmesg_restrict.
diff -urpN linux-2.6.18-408.el5.028stab120.1/Makefile linux-2.6.18-408.el5.028stab120.1-owl/Makefile
--- linux-2.6.18-408.el5.028stab120.1/Makefile	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/Makefile	2017-06-19 15:03:44 +0000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 18
-EXTRAVERSION = -prep
+EXTRAVERSION = -408.el5.028stab120.1.owl11
 RHEL_MAJOR = 5
 RHEL_MINOR = 11
 NAME=Avast! A bilge rat!
diff -urpN linux-2.6.18-408.el5.028stab120.1/arch/i386/Kconfig linux-2.6.18-408.el5.028stab120.1-owl/arch/i386/Kconfig
--- linux-2.6.18-408.el5.028stab120.1/arch/i386/Kconfig	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/arch/i386/Kconfig	2016-08-23 15:41:27 +0000
@@ -63,7 +63,7 @@ config DMI
 	default y
 
 config ARCH_RANDOM
-	def_bool y
+	def_bool n
 	prompt "x86 architectural random number generator" if EXPERT
 	---help---
 	  Enable the x86 architectural RDRAND instruction
@@ -1246,7 +1246,6 @@ config SCx200HR_TIMER
 
 config K8_NB
 	def_bool y
-	depends on AGP_AMD64
 
 source "drivers/pcmcia/Kconfig"
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/arch/i386/Makefile linux-2.6.18-408.el5.028stab120.1-owl/arch/i386/Makefile
--- linux-2.6.18-408.el5.028stab120.1/arch/i386/Makefile	2016-01-25 08:11:36 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/arch/i386/Makefile	2016-08-23 15:41:27 +0000
@@ -20,11 +20,11 @@
 HAS_BIARCH      := $(call cc-option-yn, -m32)
 ifeq ($(HAS_BIARCH),y)
 AS              := $(AS) --32
-LD              := $(LD) -m elf_i386
+LD              := $(LD) -melf_i386
 CC              := $(CC) -m32
 endif
 
-LDFLAGS		:= -m elf_i386
+LDFLAGS		:= -melf_i386
 OBJCOPYFLAGS	:= -O binary -R .note -R .comment -S
 LDFLAGS_vmlinux := --emit-relocs
 CHECKFLAGS	+= -D__i386__
diff -urpN linux-2.6.18-408.el5.028stab120.1/arch/i386/kernel/Makefile linux-2.6.18-408.el5.028stab120.1-owl/arch/i386/kernel/Makefile
--- linux-2.6.18-408.el5.028stab120.1/arch/i386/kernel/Makefile	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/arch/i386/kernel/Makefile	2016-08-23 15:41:27 +0000
@@ -64,7 +64,7 @@ targets += vsyscall-note.o vsyscall.lds
 
 # The DSO images are built using a special linker script.
 quiet_cmd_syscall = SYSCALL $@
-      cmd_syscall = $(CC) -m elf_i386 -nostdlib $(SYSCFLAGS_$(@F)) \
+      cmd_syscall = $(CC) -melf_i386 -nostdlib $(SYSCFLAGS_$(@F)) \
 		          -Wl,-T,$(filter-out FORCE,$^) -o $@
 
 export CPPFLAGS_vsyscall.lds += -P -C -U$(ARCH)
diff -urpN linux-2.6.18-408.el5.028stab120.1/arch/i386/kernel/cpu/intel_cacheinfo.c linux-2.6.18-408.el5.028stab120.1-owl/arch/i386/kernel/cpu/intel_cacheinfo.c
--- linux-2.6.18-408.el5.028stab120.1/arch/i386/kernel/cpu/intel_cacheinfo.c	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/arch/i386/kernel/cpu/intel_cacheinfo.c	2016-08-23 15:41:27 +0000
@@ -47,10 +47,12 @@ static void wbinvd_on_cpu(int cpu)
 	smp_call_function_single(cpu, __wbinvd, NULL, 0, 1);
 }
 
+#if 0
 static int wbinvd_on_all_cpus(void)
 {
 	return on_each_cpu(__wbinvd, NULL, 0, 1);
 }
+#endif
 
 /* from arch/x86/kernel/cpu/amd.c upstream */
 static int amd_get_nb_id(int cpu)
diff -urpN linux-2.6.18-408.el5.028stab120.1/arch/i386/kernel/vmlinux.lds.S linux-2.6.18-408.el5.028stab120.1-owl/arch/i386/kernel/vmlinux.lds.S
--- linux-2.6.18-408.el5.028stab120.1/arch/i386/kernel/vmlinux.lds.S	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/arch/i386/kernel/vmlinux.lds.S	2016-08-23 15:41:27 +0000
@@ -253,6 +253,7 @@ SECTIONS
   /* Sections to be discarded */
   /DISCARD/ : {
 	*(.exitcall.exit)
+	*(.eh_frame)
 	}
 
   STABS_DEBUG
diff -urpN linux-2.6.18-408.el5.028stab120.1/arch/s390/kernel/head64.S linux-2.6.18-408.el5.028stab120.1-owl/arch/s390/kernel/head64.S
--- linux-2.6.18-408.el5.028stab120.1/arch/s390/kernel/head64.S	2016-01-25 08:11:36 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/arch/s390/kernel/head64.S	2016-10-22 15:45:06 +0000
@@ -295,7 +295,7 @@ startup_continue:
 	.long	0xb2b10000		# store facility list
 	tm	0xc8,0x08		# check bit for clearing-by-ASCE
 	bno	0f-.LPG1(%r13)
-	lhi	%r1,2094
+	lhi	%r1,2048
 	lhi	%r2,0
 	.long	0xb98e2001
 	oi	7(%r12),0x80		# set IDTE flag
diff -urpN linux-2.6.18-408.el5.028stab120.1/arch/x86_64/Kconfig linux-2.6.18-408.el5.028stab120.1-owl/arch/x86_64/Kconfig
--- linux-2.6.18-408.el5.028stab120.1/arch/x86_64/Kconfig	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/arch/x86_64/Kconfig	2016-08-23 15:41:27 +0000
@@ -95,7 +95,7 @@ config AUDIT_ARCH
 	default y
 
 config ARCH_RANDOM
-	def_bool y
+	def_bool n
 	prompt "x86 architectural random number generator" if EXPERT
 	---help---
 	  Enable the x86 architectural RDRAND instruction
@@ -485,6 +485,7 @@ config IOMMU
 	default y
 	select SWIOTLB
 	select AGP
+	select IOMMU_HELPER
 	depends on PCI && !X86_64_XEN
 	help
 	  Support for full DMA access of devices with 32bit memory access only
diff -urpN linux-2.6.18-408.el5.028stab120.1/arch/x86_64/Makefile linux-2.6.18-408.el5.028stab120.1-owl/arch/x86_64/Makefile
--- linux-2.6.18-408.el5.028stab120.1/arch/x86_64/Makefile	2016-01-25 08:11:36 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/arch/x86_64/Makefile	2016-08-23 15:41:27 +0000
@@ -21,7 +21,7 @@
 #
 # $Id: Makefile,v 1.31 2002/03/22 15:56:07 ak Exp $
 
-LDFLAGS		:= -m elf_x86_64
+LDFLAGS		:= -melf_x86_64
 OBJCOPYFLAGS	:= -O binary -R .note -R .comment -S
 LDFLAGS_vmlinux :=
 CHECKFLAGS      += -D__x86_64__ -m64
diff -urpN linux-2.6.18-408.el5.028stab120.1/arch/x86_64/kernel/ptrace.c linux-2.6.18-408.el5.028stab120.1-owl/arch/x86_64/kernel/ptrace.c
--- linux-2.6.18-408.el5.028stab120.1/arch/x86_64/kernel/ptrace.c	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/arch/x86_64/kernel/ptrace.c	2016-08-23 15:41:27 +0000
@@ -314,6 +314,10 @@ static int putreg(struct task_struct *ch
 			return -EIO;
 		value &= 0xffff;
 		break;
+	case offsetof(struct user_regs_struct,rip):
+		if (value >= TASK_SIZE_OF(child))
+			return -EIO;
+		break;
 	}
 	put_stack_long(child, regno - sizeof(struct pt_regs), value);
 	return 0;
diff -urpN linux-2.6.18-408.el5.028stab120.1/arch/x86_64/pci/mmconfig.c linux-2.6.18-408.el5.028stab120.1-owl/arch/x86_64/pci/mmconfig.c
--- linux-2.6.18-408.el5.028stab120.1/arch/x86_64/pci/mmconfig.c	2016-01-25 08:11:36 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/arch/x86_64/pci/mmconfig.c	2016-08-23 15:41:27 +0000
@@ -188,7 +188,7 @@ static unsigned long get_mmcfg_aper(stru
 #endif
 		/* trust acpi values for end & start bus number */
 		printk(KERN_INFO
-		       "PCI: Using acpi max pci bus value of 0x%lx \n",
+		       "PCI: Using acpi max pci bus value of 0x%x \n",
 		       cfg->end_bus_number - cfg->start_bus_number + 1);
 		mmcfg_aper = tmp_mmcfg_aper;
 		if (mmcfg_aper < MMCONFIG_APER_MIN) 
@@ -198,7 +198,7 @@ static unsigned long get_mmcfg_aper(stru
 	} else {
 		if (tmp_mmcfg_aper < MMCONFIG_APER_MAX) {
 			printk(KERN_ERR "Warning: pci_mmcfg_init marking %dMB "
-			       "space uncacheable.\nMCFG table requires %dMB "
+			       "space uncacheable.\nMCFG table requires %ldMB "
 			       "uncacheable only. Try booting with "
 			       "acpi_mcfg_max_pci_bus_num=on\n",
 			       MMCONFIG_APER_MAX >> 20, tmp_mmcfg_aper >> 20);
diff -urpN linux-2.6.18-408.el5.028stab120.1/arch/x86_64/vdso/Makefile linux-2.6.18-408.el5.028stab120.1-owl/arch/x86_64/vdso/Makefile
--- linux-2.6.18-408.el5.028stab120.1/arch/x86_64/vdso/Makefile	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/arch/x86_64/vdso/Makefile	2016-08-23 15:41:27 +0000
@@ -17,7 +17,7 @@ targets += vdso.so vdso.lds $(vobjs-y)
 
 # The DSO images are built using a special linker script.
 quiet_cmd_syscall = SYSCALL $@
-      cmd_syscall = $(CC) -m elf_x86_64 -nostdlib $(SYSCFLAGS_$(@F)) \
+      cmd_syscall = $(CC) -melf_x86_64 -nostdlib $(SYSCFLAGS_$(@F)) \
 		          -Wl,-T,$(filter-out FORCE,$^) -o $@
 
 export CPPFLAGS_vdso.lds += -P -C -U$(ARCH)
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/ata/Kconfig linux-2.6.18-408.el5.028stab120.1-owl/drivers/ata/Kconfig
--- linux-2.6.18-408.el5.028stab120.1/drivers/ata/Kconfig	2016-01-25 08:11:36 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/ata/Kconfig	2016-08-23 15:41:27 +0000
@@ -447,8 +447,8 @@ config PATA_MARVELL
 	help
 	  This option enables limited support for the Marvell 88SE61xx ATA
 	  controllers. If you wish to use only the SATA ports then select
-	  the AHCI driver alone. If you wish to the use the PATA port or
-	  both SATA and PATA include this driver.
+	  the AHCI driver alone. If you wish to use the PATA port or both
+	  SATA and PATA include this driver.
 
 	  If unsure, say N.
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/ata/ahci.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/ata/ahci.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/ata/ahci.c	2016-01-25 08:11:36 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/ata/ahci.c	2016-08-23 15:41:27 +0000
@@ -807,7 +807,7 @@ static void ahci_save_initial_config(str
 			   port_map,
 			   port_map & mv);
 		dev_printk(KERN_ERR, &pdev->dev,
-			  "Disabling your PATA port. Use the boot option 'ahci.marvell_enable=0' to avoid this.\n");
+			  "Disabling your PATA port on the Marvell SATA/PATA controller, which is unsupported by the AHCI driver. Use the boot option 'ahci.marvell_enable=0' to avoid this and let the likely slower Marvell PATA driver take over, supporting both SATA and PATA ports.\n");
 
 		port_map &= mv;
 	}
@@ -2916,8 +2916,11 @@ static int ahci_init_one(struct pci_dev
 	/* The AHCI driver can only drive the SATA ports, the PATA driver
 	   can drive them all so if both drivers are selected make sure
 	   AHCI stays out of the way */
-	if (pdev->vendor == PCI_VENDOR_ID_MARVELL && !marvell_enable)
+	if (pdev->vendor == PCI_VENDOR_ID_MARVELL && !marvell_enable) {
+		dev_printk(KERN_ERR, &pdev->dev,
+			  "Skipping the Marvell SATA/PATA controller in order to let the Marvell PATA driver take over. Use the boot option 'ahci.marvell_enable=1' to avoid this, likely gaining a bit of performance but losing support for your PATA port.\n");
 		return -ENODEV;
+	}
 
 	/* acquire resources */
 	rc = pcim_enable_device(pdev);
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/block/cciss.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/block/cciss.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/block/cciss.c	2016-01-25 08:11:36 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/block/cciss.c	2016-08-23 15:41:27 +0000
@@ -1068,6 +1068,15 @@ static CommandList_struct *cmd_special_a
 	return c;
 }
 
+static inline u32 cciss_tag_discard_error_bits(ctlr_info_t *h, u32 tag)
+{
+#define CCISS_PERF_ERROR_BITS ((1 << DIRECT_LOOKUP_SHIFT) - 1)
+#define CCISS_SIMPLE_ERROR_BITS 0x03
+	if (likely(h->transMethod & CFGTBL_Trans_Performant))
+		return tag & ~CCISS_PERF_ERROR_BITS;
+	return tag & ~CCISS_SIMPLE_ERROR_BITS;
+}
+
 static void cmd_special_free(ctlr_info_t *h, CommandList_struct *c)
 {
 	u64bit temp64;
@@ -1826,6 +1835,38 @@ static void cciss_check_queues(ctlr_info
 	}
 }
 
+static inline void complete_pc_buffers(struct bio *bio,
+	unsigned int nr_bytes, int status)
+{
+	unsigned int bytes_remaining = nr_bytes;
+
+	while (bio) {
+		struct bio *xbh = bio->bi_next;
+		unsigned int bytes_in_this_bio = bio_sectors(bio) << 9;
+
+		if (bytes_in_this_bio > bytes_remaining)
+			bytes_in_this_bio = bytes_remaining;
+
+		bio->bi_next = NULL;
+		bio_endio(bio, bytes_in_this_bio, status ? 0 : -EIO);
+		bio = xbh;
+
+		bytes_remaining -= bytes_in_this_bio;
+	}
+}
+
+static inline void complete_fs_buffers(struct bio *bio, int status)
+{
+	while (bio) {
+		struct bio *xbh = bio->bi_next;
+		unsigned int nr_bytes = bio_sectors(bio) << 9;
+ 
+		bio->bi_next = NULL;
+		bio_endio(bio, nr_bytes, status ? 0 : -EIO);
+		bio = xbh;
+	}
+}
+
 static void cciss_softirq_done(struct request *rq)
 {
 	CommandList_struct *c = rq->completion_data;
@@ -3288,15 +3329,6 @@ static inline u32 cciss_tag_to_index(u32
 	return tag >> DIRECT_LOOKUP_SHIFT;
 }
 
-static inline u32 cciss_tag_discard_error_bits(ctlr_info_t *h, u32 tag)
-{
-#define CCISS_PERF_ERROR_BITS ((1 << DIRECT_LOOKUP_SHIFT) - 1)
-#define CCISS_SIMPLE_ERROR_BITS 0x03
-	if (likely(h->transMethod & CFGTBL_Trans_Performant))
-		return tag & ~CCISS_PERF_ERROR_BITS;
-	return tag & ~CCISS_SIMPLE_ERROR_BITS;
-}
-
 static void inline cciss_mark_tag_indexed(u32 *tag)
 {
 	*tag |= DIRECT_LOOKUP_BIT;
@@ -5324,38 +5356,6 @@ err:
 
 }
 
-static inline void complete_pc_buffers(struct bio *bio,
-	unsigned int nr_bytes, int status)
-{
-	unsigned int bytes_remaining = nr_bytes;
-
-	while (bio) {
-		struct bio *xbh = bio->bi_next;
-		unsigned int bytes_in_this_bio = bio_sectors(bio) << 9;
-
-		if (bytes_in_this_bio > bytes_remaining)
-			bytes_in_this_bio = bytes_remaining;
-
-		bio->bi_next = NULL;
-		bio_endio(bio, bytes_in_this_bio, status ? 0 : -EIO);
-		bio = xbh;
-
-		bytes_remaining -= bytes_in_this_bio;
-	}
-}
-
-static inline void complete_fs_buffers(struct bio *bio, int status)
-{
-	while (bio) {
-		struct bio *xbh = bio->bi_next;
-		unsigned int nr_bytes = bio_sectors(bio) << 9;
- 
-		bio->bi_next = NULL;
-		bio_endio(bio, nr_bytes, status ? 0 : -EIO);
-		bio = xbh;
-	}
-}
-
 /**
  * blk_rq_bytes - Returns bytes left to complete in the entire request
  * @rq: the request being processed
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/block/pktcdvd.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/block/pktcdvd.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/block/pktcdvd.c	2016-01-25 08:11:36 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/block/pktcdvd.c	2016-08-23 15:41:27 +0000
@@ -1804,11 +1804,11 @@ static int pkt_media_speed(struct pktcdv
 		return ret;
 	}
 
-	if (!buf[6] & 0x40) {
+	if (!(buf[6] & 0x40)) {
 		printk("pktcdvd: Disc type is not CD-RW\n");
 		return 1;
 	}
-	if (!buf[6] & 0x4) {
+	if (!(buf[6] & 0x4)) {
 		printk("pktcdvd: A1 values on media are not valid, maybe not CDRW?\n");
 		return 1;
 	}
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/char/keyboard.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/char/keyboard.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/char/keyboard.c	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/char/keyboard.c	2016-08-23 15:41:27 +0000
@@ -1376,7 +1376,7 @@ int __init kbd_init(void)
 		kbd_table[i].lockstate = KBD_DEFLOCK;
 		kbd_table[i].slockstate = 0;
 		kbd_table[i].modeflags = KBD_DEFMODE;
-		kbd_table[i].kbdmode = VC_UNICODE;
+		kbd_table[i].kbdmode = VC_XLATE;
 	}
 
 	input_register_handler(&kbd_handler);
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/char/vt.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/char/vt.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/char/vt.c	2016-01-25 08:11:36 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/char/vt.c	2016-08-23 15:41:27 +0000
@@ -1499,7 +1499,7 @@ static void reset_terminal(struct vc_dat
 	vc->vc_charset		= 0;
 	vc->vc_need_wrap	= 0;
 	vc->vc_report_mouse	= 0;
-	vc->vc_utf		= 1;
+	vc->vc_utf		= 0;
 	vc->vc_utf_count	= 0;
 
 	vc->vc_disp_ctrl	= 0;
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/dca/Kconfig linux-2.6.18-408.el5.028stab120.1-owl/drivers/dca/Kconfig
--- linux-2.6.18-408.el5.028stab120.1/drivers/dca/Kconfig	2016-01-25 08:11:36 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/dca/Kconfig	2016-08-23 15:41:27 +0000
@@ -3,7 +3,7 @@
 #
 
 config DCA
-	tristate
+	tristate "DCA server configuration"
 	depends on DMA_ENGINE_V3 && PCI
 	default m
 	---help---
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/firmware/dell_rbu.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/firmware/dell_rbu.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/firmware/dell_rbu.c	2016-01-25 08:11:36 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/firmware/dell_rbu.c	2016-08-23 15:41:27 +0000
@@ -227,7 +227,7 @@ static int packetize_data(void *data, si
 	int packet_length;
 	u8 *temp;
 	u8 *end = (u8 *) data + length;
-	pr_debug("packetize_data: data length %d\n", length);
+	pr_debug("packetize_data: data length %lu\n", (unsigned long)length);
 	if (!rbu_data.packetsize) {
 		printk(KERN_WARNING
 			"dell_rbu: packetsize not specified\n");
@@ -249,7 +249,7 @@ static int packetize_data(void *data, si
 		if ((rc = create_packet(temp, packet_length)))
 			return rc;
 
-		pr_debug("%lu:%lu\n", temp, (end - temp));
+		pr_debug("%lu:%lu\n", (unsigned long)temp, (end - temp));
 		temp += packet_length;
 	}
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/message/fusion/Kconfig linux-2.6.18-408.el5.028stab120.1-owl/drivers/message/fusion/Kconfig
--- linux-2.6.18-408.el5.028stab120.1/drivers/message/fusion/Kconfig	2016-01-25 08:11:37 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/message/fusion/Kconfig	2016-08-23 15:41:27 +0000
@@ -56,6 +56,8 @@ config FUSION_SAS
 	  LSISAS1068
 	  LSISAS1064E
 	  LSISAS1068E
+	  LSISAS1068 8204ELP
+	  LSISAS1068 8208ELP
 	  LSISAS1078
 
 config FUSION_MAX_SGE
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/message/fusion/mptbase.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/message/fusion/mptbase.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/message/fusion/mptbase.c	2016-01-25 08:11:37 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/message/fusion/mptbase.c	2016-08-23 15:41:27 +0000
@@ -1611,6 +1611,9 @@ mpt_get_product_name(u16 vendor, u16 dev
 			break;
 		}
 		break;
+	case MPI_MANUFACTPAGE_DEVID_SAS1068_820XELP:
+		product_str = "LSISAS1068 820xELP";
+		break;
 	case MPI_MANUFACTPAGE_DEVID_SAS1078:
 		switch (revision)
 		{
@@ -1951,6 +1954,7 @@ mpt_attach(struct pci_dev *pdev, const s
 
 	case MPI_MANUFACTPAGE_DEVID_SAS1064E:
 	case MPI_MANUFACTPAGE_DEVID_SAS1068E:
+	case MPI_MANUFACTPAGE_DEVID_SAS1068_820XELP:
 	case MPI_MANUFACTPAGE_DEVID_SAS1078:
 		ioc->bus_type = SAS;
 		break;
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/message/fusion/mptsas.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/message/fusion/mptsas.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/message/fusion/mptsas.c	2016-01-25 08:11:37 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/message/fusion/mptsas.c	2016-08-23 15:41:27 +0000
@@ -444,6 +444,23 @@ mptsas_is_end_device(struct mptsas_devin
 		return 0;
 }
 
+static inline void
+mptsas_set_rphy(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_rphy *rphy)
+{
+	if (phy_info->port_details) {
+		phy_info->port_details->rphy = rphy;
+		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "sas_rphy_add: rphy=%p\n",
+		    ioc->name, rphy));
+	}
+
+	if (rphy) {
+		dsaswideprintk(ioc, dev_printk(KERN_DEBUG,
+		    &rphy->dev, MYIOC_s_FMT "add:", ioc->name));
+		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "rphy=%p release=%p\n",
+		    ioc->name, rphy, rphy->dev.release));
+	}
+}
+
 /* no mutex */
 static void
 mptsas_port_delete(MPT_ADAPTER *ioc, struct mptsas_portinfo_details * port_details)
@@ -482,23 +499,6 @@ mptsas_get_rphy(struct mptsas_phyinfo *p
 		return NULL;
 }
 
-static inline void
-mptsas_set_rphy(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_rphy *rphy)
-{
-	if (phy_info->port_details) {
-		phy_info->port_details->rphy = rphy;
-		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "sas_rphy_add: rphy=%p\n",
-		    ioc->name, rphy));
-	}
-
-	if (rphy) {
-		dsaswideprintk(ioc, dev_printk(KERN_DEBUG,
-		    &rphy->dev, MYIOC_s_FMT "add:", ioc->name));
-		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "rphy=%p release=%p\n",
-		    ioc->name, rphy, rphy->dev.release));
-	}
-}
-
 static inline struct sas_port *
 mptsas_get_port(struct mptsas_phyinfo *phy_info)
 {
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/net/Kconfig linux-2.6.18-408.el5.028stab120.1-owl/drivers/net/Kconfig
--- linux-2.6.18-408.el5.028stab120.1/drivers/net/Kconfig	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/net/Kconfig	2016-08-23 15:41:27 +0000
@@ -2657,6 +2657,8 @@ config NIU
 config BNX2X
 	tristate "Broadcom NetXtremeII 10Gb support"
 	depends on PCI
+	select CRYPTO_CRC32C
+	select MDIO
 	help
 	  This driver supports Broadcom NetXtremeII 10 gigabit Ethernet cards.
 	  To compile this driver as a module, choose M here: the module
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/net/bnx2x/bnx2x_main.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/net/bnx2x/bnx2x_main.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/net/bnx2x/bnx2x_main.c	2016-01-25 08:11:37 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/net/bnx2x/bnx2x_main.c	2016-08-23 15:41:27 +0000
@@ -7663,6 +7663,15 @@ static inline u16 bnx2x_cid_ilt_lines(st
 	return L2_ILT_LINES(bp);
 }
 
+#if __GNUC__ < 4
+/*
+ * gcc 3.4.5's __builtin_constant_p() appears to misbehave on the expressions
+ * passed into ilog2() by the function below.
+ */
+#undef ilog2
+#define ilog2 __ilog2_u32
+#endif
+
 void bnx2x_ilt_set_info(struct bnx2x *bp)
 {
 	struct ilt_client_info *ilt_client;
@@ -7760,6 +7769,10 @@ void bnx2x_ilt_set_info(struct bnx2x *bp
 	BUG_ON(line > ILT_MAX_LINES);
 }
 
+#if __GNUC__ < 4
+#undef ilog2
+#endif
+
 /**
  * bnx2x_pf_q_prep_init - prepare INIT transition parameters
  *
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/net/bonding/bond_main.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/net/bonding/bond_main.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/net/bonding/bond_main.c	2016-01-25 08:11:37 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/net/bonding/bond_main.c	2016-08-23 15:41:27 +0000
@@ -229,8 +229,6 @@ struct bond_parm_tbl pri_reselect_tbl[]
 /*-------------------------- Forward declarations ---------------------------*/
 
 static void bond_deinit(struct net_device *bond_dev);
-static inline int bond_slave_override(struct bonding *bond,
-                                      struct sk_buff *skb);
 
 /*---------------------------- General routines -----------------------------*/
 
@@ -4414,6 +4412,40 @@ unwind:
 	return res;
 }
 
+/*
+ * Lookup the slave that corresponds to a qid
+ */
+static inline int bond_slave_override(struct bonding *bond,
+				      struct sk_buff *skb)
+{
+	int i, res = 1;
+	struct slave *slave = NULL;
+	struct slave *check_slave;
+
+	read_lock(&bond->lock);
+
+	if (!BOND_IS_OK(bond) || !skb->nfmark)
+		goto out;
+
+	/* Find out if any slaves have the same mapping as this skb. */
+	bond_for_each_slave(bond, check_slave, i) {
+		if (check_slave->dev->ifindex == skb->nfmark) {
+			slave = check_slave;
+			break;
+		}
+	}
+
+	/* If the slave isn't UP, use default transmit policy. */
+	if (slave && IS_UP(slave->dev) &&
+	    (slave->link == BOND_LINK_UP)) {
+		res = bond_dev_queue_xmit(bond, skb, slave->dev);
+	}
+
+out:
+	read_unlock(&bond->lock);
+	return res;
+}
+
 static int bond_xmit_roundrobin(struct sk_buff *skb, struct net_device *bond_dev)
 {
 	struct bonding *bond = bond_dev->priv;
@@ -4677,40 +4709,6 @@ static void bond_set_xmit_hash_policy(st
 }
 
 /*
- * Lookup the slave that corresponds to a qid
- */
-static inline int bond_slave_override(struct bonding *bond,
-				      struct sk_buff *skb)
-{
-	int i, res = 1;
-	struct slave *slave = NULL;
-	struct slave *check_slave;
-
-	read_lock(&bond->lock);
-
-	if (!BOND_IS_OK(bond) || !skb->nfmark)
-		goto out;
-
-	/* Find out if any slaves have the same mapping as this skb. */
-	bond_for_each_slave(bond, check_slave, i) {
-		if (check_slave->dev->ifindex == skb->nfmark) {
-			slave = check_slave;
-			break;
-		}
-	}
-
-	/* If the slave isn't UP, use default transmit policy. */
-	if (slave && IS_UP(slave->dev) &&
-	    (slave->link == BOND_LINK_UP)) {
-		res = bond_dev_queue_xmit(bond, skb, slave->dev);
-	}
-
-out:
-	read_unlock(&bond->lock);
-	return res;
-}
-
-/*
  * set bond mode specific net device operations
  */
 void bond_set_mode_ops(struct bonding *bond, int mode)
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/net/loopback.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/net/loopback.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/net/loopback.c	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/net/loopback.c	2016-08-23 15:41:27 +0000
@@ -286,5 +286,13 @@ int __init loopback_init(void)
 	return register_netdev(&loopback_dev);
 };
 
+#if __GNUC__ >= 4
+/*
+ * With gcc 3.4.5:
+ * drivers/net/loopback.c:289: error: initializer element is not constant
+ * drivers/net/loopback.c:289: error: (near initialization for `__ksymtab_loopback_dev.value')
+ * drivers/net/loopback.c:289: error: __ksymtab_loopback_dev causes a section type conflict
+ */
 EXPORT_SYMBOL(loopback_dev);
+#endif
 EXPORT_SYMBOL(templ_loopback_dev);
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/net/wireless/airo.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/net/wireless/airo.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/net/wireless/airo.c	2016-01-25 08:11:38 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/net/wireless/airo.c	2016-08-23 15:41:27 +0000
@@ -6372,7 +6372,7 @@ static int airo_set_encode(struct net_de
 			set_wep_key(local, index, NULL, 0, perm, 1);
 		} else
 			/* Don't complain if only change the mode */
-			if(!dwrq->flags & IW_ENCODE_MODE) {
+			if (!(dwrq->flags & IW_ENCODE_MODE)) {
 				return -EINVAL;
 			}
 	}
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/net/wireless/atmel.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/net/wireless/atmel.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/net/wireless/atmel.c	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/net/wireless/atmel.c	2014-06-08 21:45:40 +0000
@@ -1766,7 +1766,7 @@ static int atmel_set_encode(struct net_d
 			priv->default_key = index;
 		} else
 			/* Don't complain if only change the mode */
-			if (!dwrq->flags & IW_ENCODE_MODE) {
+			if (!(dwrq->flags & IW_ENCODE_MODE)) {
 				return -EINVAL;
 			}
 	}
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/net/wireless/prism54/isl_ioctl.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/net/wireless/prism54/isl_ioctl.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/net/wireless/prism54/isl_ioctl.c	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/net/wireless/prism54/isl_ioctl.c	2014-06-08 21:48:02 +0000
@@ -1081,7 +1081,7 @@ prism54_set_encode(struct net_device *nd
 			    mgt_set_request(priv, DOT11_OID_DEFKEYID, 0,
 					    &index);
 		} else {
-			if (!dwrq->flags & IW_ENCODE_MODE) {
+			if (!(dwrq->flags & IW_ENCODE_MODE)) {
 				/* we cannot do anything. Complain. */
 				return -EINVAL;
 			}
@@ -2115,7 +2115,7 @@ prism2_ioctl_set_encryption(struct net_d
 			    mgt_set_request(priv, DOT11_OID_DEFKEYID, 0,
 					    &index);
 		} else {
-			if (!param->u.crypt.flags & IW_ENCODE_MODE) {
+			if (!(param->u.crypt.flags & IW_ENCODE_MODE)) {
 				/* we cannot do anything. Complain. */
 				return -EINVAL;
 			}
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/pci/dmar.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/pci/dmar.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/pci/dmar.c	2016-01-25 08:11:38 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/pci/dmar.c	2016-08-23 15:41:27 +0000
@@ -715,7 +715,7 @@ int alloc_iommu(struct dmar_drhd_unit *d
 	 * are few.
 	 */
 	if (cap_ndoms(iommu->cap) > 4*1024) {
-		pr_info("IOMMU %llx: Number of IOMMU domains reduced from %dK to 4K\n",
+		pr_info("IOMMU %llx: Number of IOMMU domains reduced from %luK to 4K\n",
 			(unsigned long long)drhd->reg_base_addr,
 			cap_ndoms(iommu->cap)/1024);
 		iommu->cap = (iommu->cap & (~(uint64_t)0x7)) | 0x04;
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/scsi/st.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/scsi/st.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/scsi/st.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/scsi/st.c	2016-08-23 15:41:27 +0000
@@ -2891,7 +2891,7 @@ static int st_int_ioctl(struct scsi_tape
 			    !(STp->use_pf & PF_TESTED)) {
 				/* Try the other possible state of Page Format if not
 				   already tried */
-				STp->use_pf = !STp->use_pf | PF_TESTED;
+				STp->use_pf = (STp->use_pf ^ USE_PF) | PF_TESTED;
 				st_release_request(SRpnt);
 				SRpnt = NULL;
 				return st_int_ioctl(STp, cmd_in, arg);
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/serial/8250_early.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/serial/8250_early.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/serial/8250_early.c	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/serial/8250_early.c	2014-06-08 18:20:52 +0000
@@ -74,7 +74,7 @@ static void __init wait_for_xmitr(struct
 	}
 }
 
-static void __init putc(struct uart_port *port, int c)
+static void __init uart_putc(struct uart_port *port, int c)
 {
 	wait_for_xmitr(port);
 	serial_out(port, UART_TX, c);
@@ -89,7 +89,7 @@ static void __init early_uart_write(stru
 	ier = serial_in(port, UART_IER);
 	serial_out(port, UART_IER, 0);
 
-	uart_console_write(port, s, count, putc);
+	uart_console_write(port, s, count, uart_putc);
 
 	/* Wait for transmitter to become empty and restore the IER */
 	wait_for_xmitr(port);
diff -urpN linux-2.6.18-408.el5.028stab120.1/drivers/video/fbmem.c linux-2.6.18-408.el5.028stab120.1-owl/drivers/video/fbmem.c
--- linux-2.6.18-408.el5.028stab120.1/drivers/video/fbmem.c	2006-11-29 19:28:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/drivers/video/fbmem.c	2016-10-22 15:45:06 +0000
@@ -1125,14 +1125,12 @@ fb_mmap(struct file *file, struct vm_are
 	struct fb_info *info = registered_fb[fbidx];
 	struct fb_ops *fb = info->fbops;
 	unsigned long off;
+	unsigned long mmio_pgoff;
 #if !defined(__sparc__) || defined(__sparc_v9__)
 	unsigned long start;
 	u32 len;
 #endif
 
-	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))
-		return -EINVAL;
-	off = vma->vm_pgoff << PAGE_SHIFT;
 	if (!fb)
 		return -ENODEV;
 	if (fb->fb_mmap) {
@@ -1151,27 +1149,22 @@ fb_mmap(struct file *file, struct vm_are
 	/* !sparc32... */
 	lock_kernel();
 
-	/* frame buffer memory */
+	/*
+	 * Ugh. This can be either the frame buffer mapping, or
+	 * if pgoff points past it, the mmio mapping.
+	 */
 	start = info->fix.smem_start;
-	len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);
-	if (off >= len) {
-		/* memory mapped io */
-		off -= len;
-		if (info->var.accel_flags) {
-			unlock_kernel();
-			return -EINVAL;
-		}
+	len = info->fix.smem_len;
+	mmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;
+	if (vma->vm_pgoff >= mmio_pgoff) {
+		vma->vm_pgoff -= mmio_pgoff;
 		start = info->fix.mmio_start;
-		len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);
+		len = info->fix.mmio_len;
 	}
 	unlock_kernel();
-	start &= PAGE_MASK;
-	if ((vma->vm_end - vma->vm_start + off) > len)
-		return -EINVAL;
-	off += start;
-	vma->vm_pgoff = off >> PAGE_SHIFT;
-	/* This is an IO map - tell maydump to skip this VMA */
+
 	vma->vm_flags |= VM_IO | VM_RESERVED;
+
 #if defined(__mc68000__)
 #if defined(CONFIG_SUN3)
 	pgprot_val(vma->vm_page_prot) |= SUN3_PAGE_NOCACHE;
@@ -1207,10 +1200,8 @@ fb_mmap(struct file *file, struct vm_are
 #else
 #warning What do we have to do here??
 #endif
-	if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
-			     vma->vm_end - vma->vm_start, vma->vm_page_prot))
-		return -EAGAIN;
-	return 0;
+
+	return vm_iomap_memory(vma, start, len);
 #endif /* !sparc32 */
 }
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/Kconfig linux-2.6.18-408.el5.028stab120.1-owl/fs/Kconfig
--- linux-2.6.18-408.el5.028stab120.1/fs/Kconfig	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/Kconfig	2016-08-23 15:41:27 +0000
@@ -473,6 +473,7 @@ config QFMT_V2
 config SIM_FS
 	tristate "VPS filesystem"
 	depends on VZ_QUOTA
+	select EXPORTFS
 	default m
 	help
 	  This file system is a part of Virtuozzo. It intoduces a fake
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/compat.c linux-2.6.18-408.el5.028stab120.1-owl/fs/compat.c
--- linux-2.6.18-408.el5.028stab120.1/fs/compat.c	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/compat.c	2017-06-19 14:56:34 +0000
@@ -57,6 +57,10 @@
 #include <asm/mmu_context.h>
 #include <asm/ioctls.h>
 
+#ifdef CONFIG_X86_32
+#include <asm/atomic64_32.h>
+#endif
+
 #ifdef CONFIG_QUOTA_COMPAT
 #include <linux/quota-compat.h>
 #endif
@@ -1734,6 +1738,8 @@ asmlinkage long sys32_quotactl(unsigned
 	return ret;
 }
 
+extern atomic64_t global_exec_counter;
+
 /*
  * compat_do_execve() is mostly a copy of do_execve(), with the exception
  * that it processes 32 bit argv and envp pointers.
@@ -1745,12 +1751,27 @@ int compat_do_execve(char * filename,
 {
 	struct linux_binprm *bprm;
 	struct file *file;
+	int have_old_rlim_stack = 0;
+	unsigned long old_rlim_stack = 0;
 	int retval;
 
 	retval = virtinfo_gencall(VIRTINFO_DOEXECVE, NULL);
 	if (retval)
 		return retval;
 
+	/*
+	 * We check for RLIMIT_NPROC in execve() instead of set_user() because
+	 * too many poorly written programs don't check setuid() return code.
+	 * The check in execve() does the same thing for programs doing
+	 * setuid()+execve(), but without similar security issues.
+	 */
+	if (atomic_read(&current->user->processes) >
+	    current->signal->rlim[RLIMIT_NPROC].rlim_cur &&
+	    current->uid != 0) {
+		retval = -EAGAIN;
+		goto out_ret;
+	}
+
 	retval = -ENOMEM;
 	bprm = kzalloc(sizeof(*bprm), GFP_KERNEL);
 	if (!bprm)
@@ -1787,6 +1808,15 @@ int compat_do_execve(char * filename,
 	if (retval < 0)
 		goto out;
 
+	if (bprm->e_uid != current->euid || bprm->e_gid != current->egid) {
+		old_rlim_stack = current->signal->rlim[RLIMIT_STACK].rlim_cur;
+		if (old_rlim_stack > MAX_RLIMIT_STACK_SUGID) {
+			current->signal->rlim[RLIMIT_STACK].rlim_cur =
+			    MAX_RLIMIT_STACK_SUGID;
+			have_old_rlim_stack = 1;
+		}
+	}
+
 	retval = copy_strings_kernel(1, &bprm->filename, bprm);
 	if (retval < 0)
 		goto out;
@@ -1808,6 +1838,7 @@ int compat_do_execve(char * filename,
 	retval = search_binary_handler(bprm, regs);
 	if (retval >= 0) {
 		/* execve success */
+		current->exec_id = atomic64_inc_return(&global_exec_counter);
 		security_bprm_free(bprm);
 		acct_update_integrals(current);
 		kfree(bprm);
@@ -1815,6 +1846,9 @@ int compat_do_execve(char * filename,
 	}
 
 out:
+	if (have_old_rlim_stack)
+		current->signal->rlim[RLIMIT_STACK].rlim_cur = old_rlim_stack;
+
 	if (bprm->security)
 		security_bprm_free(bprm);
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/dcache.c linux-2.6.18-408.el5.028stab120.1-owl/fs/dcache.c
--- linux-2.6.18-408.el5.028stab120.1/fs/dcache.c	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/dcache.c	2016-10-22 15:45:06 +0000
@@ -2009,6 +2009,7 @@ struct dentry *d_materialise_unique(stru
 			if (d_isparent(alias, dentry)) {
 				/* Check for loops */
 				actual = ERR_PTR(-ELOOP);
+				spin_unlock(&dcache_lock);
 			} else if (IS_ROOT(alias)) {
 				/* Is this an anonymous mountpoint that we
 				 * could splice into our tree? */
@@ -2033,7 +2034,7 @@ struct dentry *d_materialise_unique(stru
 					       inode->i_sb->s_id);
 				dput(alias);
 			}
-			goto out_unlock_dcache;
+			goto out;
 		}
 	}
 
@@ -2049,8 +2050,8 @@ found_lock:
 found:
 	_d_rehash(actual);
 	spin_unlock(&actual->d_lock);
-out_unlock_dcache:
 	spin_unlock(&dcache_lock);
+out:
 	if (actual == dentry) {
 		security_d_instantiate(dentry, inode);
 		return NULL;
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/exec.c linux-2.6.18-408.el5.028stab120.1-owl/fs/exec.c
--- linux-2.6.18-408.el5.028stab120.1/fs/exec.c	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/exec.c	2017-06-19 14:56:27 +0000
@@ -62,6 +62,10 @@
 #include <asm/mmu_context.h>
 #include <asm/tlb.h>
 
+#ifdef CONFIG_X86_32
+#include <asm/atomic64_32.h>
+#endif
+
 #ifdef CONFIG_KMOD
 #include <linux/kmod.h>
 #endif
@@ -231,7 +235,11 @@ struct page *get_arg_page(struct linux_b
 		 *  - the program will have a reasonable amount of stack left
 		 *    to work from.
 		 */
-		if (size > rlim[RLIMIT_STACK].rlim_cur / 4) {
+		if (size > rlim[RLIMIT_STACK].rlim_cur / 4 ||
+		    size > MAX_ARG_STACK ||
+		    (size > MAX_ARG_STACK_SUGID &&
+		    (bprm->e_uid != current->euid ||
+		    bprm->e_gid != current->egid))) {
 			put_page(page);
 			return NULL;
 		}
@@ -1459,6 +1467,8 @@ int search_binary_handler(struct linux_b
 
 EXPORT_SYMBOL(search_binary_handler);
 
+atomic64_t global_exec_counter = ATOMIC64_INIT(0);
+
 /*
  * sys_execve() executes a new program.
  */
@@ -1469,12 +1479,27 @@ int do_execve(char * filename,
 {
 	struct linux_binprm *bprm;
 	struct file *file;
+	int have_old_rlim_stack = 0;
+	unsigned long old_rlim_stack = 0;
 	int retval;
 
 	retval = virtinfo_gencall(VIRTINFO_DOEXECVE, NULL);
 	if (retval)
 		return retval;
 
+	/*
+	 * We check for RLIMIT_NPROC in execve() instead of set_user() because
+	 * too many poorly written programs don't check setuid() return code.
+	 * The check in execve() does the same thing for programs doing
+	 * setuid()+execve(), but without similar security issues.
+	 */
+	if (atomic_read(&current->user->processes) >
+	    current->signal->rlim[RLIMIT_NPROC].rlim_cur &&
+	    current->uid != 0) {
+		retval = -EAGAIN;
+		goto out_ret;
+	}
+
 	retval = -ENOMEM;
 	bprm = kzalloc(sizeof(*bprm), GFP_KERNEL);
 	if (!bprm)
@@ -1511,6 +1536,15 @@ int do_execve(char * filename,
 	if (retval < 0)
 		goto out;
 
+	if (bprm->e_uid != current->euid || bprm->e_gid != current->egid) {
+		old_rlim_stack = current->signal->rlim[RLIMIT_STACK].rlim_cur;
+		if (old_rlim_stack > MAX_RLIMIT_STACK_SUGID) {
+			current->signal->rlim[RLIMIT_STACK].rlim_cur =
+			    MAX_RLIMIT_STACK_SUGID;
+			have_old_rlim_stack = 1;
+		}
+	}
+
 	retval = copy_strings_kernel(1, &bprm->filename, bprm);
 	if (retval < 0)
 		goto out;
@@ -1532,6 +1566,7 @@ int do_execve(char * filename,
 	retval = search_binary_handler(bprm,regs);
 	if (retval >= 0) {
 		/* execve success */
+		current->exec_id = atomic64_inc_return(&global_exec_counter);
 		free_arg_pages(bprm);
 		security_bprm_free(bprm);
 		acct_update_integrals(current);
@@ -1540,6 +1575,9 @@ int do_execve(char * filename,
 	}
 
 out:
+	if (have_old_rlim_stack)
+		current->signal->rlim[RLIMIT_STACK].rlim_cur = old_rlim_stack;
+
 	free_arg_pages(bprm);
 	if (bprm->security)
 		security_bprm_free(bprm);
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/ext4/mballoc.c linux-2.6.18-408.el5.028stab120.1-owl/fs/ext4/mballoc.c
--- linux-2.6.18-408.el5.028stab120.1/fs/ext4/mballoc.c	2016-01-25 08:11:39 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/ext4/mballoc.c	2016-10-22 15:45:06 +0000
@@ -2030,7 +2030,11 @@ repeat:
 			struct ext4_group_info *grp;
 			struct ext4_group_desc *desc;
 
-			if (group == ngroups)
+			/*
+			 * Artificially restricted ngroups for non-extent
+			 * files makes group > ngroups possible on first loop.
+			 */
+			if (group >= ngroups)
 				group = 0;
 
 			/* quick check to skip empty groups */
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/filesystems.c linux-2.6.18-408.el5.028stab120.1-owl/fs/filesystems.c
--- linux-2.6.18-408.el5.028stab120.1/fs/filesystems.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/filesystems.c	2016-08-23 15:41:27 +0000
@@ -252,7 +252,7 @@ int check_fs_presence(const char *name)
 	res = fs_index(name);
 	set_fs(curr_fs);
 
-	return (res < 0) ? : 0;
+	return (res < 0) ? res : 0;
 }
 EXPORT_SYMBOL(check_fs_presence);
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/fuse/dir.c linux-2.6.18-408.el5.028stab120.1-owl/fs/fuse/dir.c
--- linux-2.6.18-408.el5.028stab120.1/fs/fuse/dir.c	2016-01-25 08:11:39 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/fuse/dir.c	2016-10-22 15:45:06 +0000
@@ -388,7 +388,7 @@ static int fuse_create_open(struct inode
 	struct fuse_conn *fc = get_fuse_conn(dir);
 	struct fuse_req *req;
 	struct fuse_req *forget_req;
-	struct fuse_open_in inarg;
+	struct fuse_create_in inarg;
 	struct fuse_open_out outopen;
 	struct fuse_entry_out outentry;
 	struct fuse_file *ff;
@@ -412,15 +412,20 @@ static int fuse_create_open(struct inode
 	if (!ff)
 		goto out_put_request;
 
+	if (!fc->dont_mask)
+		mode &= ~current->fs->umask;
+
 	flags &= ~O_NOCTTY;
 	memset(&inarg, 0, sizeof(inarg));
 	memset(&outentry, 0, sizeof(outentry));
 	inarg.flags = flags;
 	inarg.mode = mode;
+	inarg.umask = current->fs->umask;
 	req->in.h.opcode = FUSE_CREATE;
 	req->in.h.nodeid = get_node_id(dir);
 	req->in.numargs = 2;
-	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].size = fc->minor < 12 ? sizeof(struct fuse_open_in) :
+						sizeof(inarg);
 	req->in.args[0].value = &inarg;
 	req->in.args[1].size = entry->d_name.len + 1;
 	req->in.args[1].value = entry->d_name.name;
@@ -557,12 +562,17 @@ static int fuse_mknod(struct inode *dir,
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
+	if (!fc->dont_mask)
+		mode &= ~current->fs->umask;
+
 	memset(&inarg, 0, sizeof(inarg));
 	inarg.mode = mode;
 	inarg.rdev = new_encode_dev(rdev);
+	inarg.umask = current->fs->umask;
 	req->in.h.opcode = FUSE_MKNOD;
 	req->in.numargs = 2;
-	req->in.args[0].size = sizeof(inarg);
+	req->in.args[0].size = fc->minor < 12 ? FUSE_COMPAT_MKNOD_IN_SIZE :
+						sizeof(inarg);
 	req->in.args[0].value = &inarg;
 	req->in.args[1].size = entry->d_name.len + 1;
 	req->in.args[1].value = entry->d_name.name;
@@ -589,8 +599,12 @@ static int fuse_mkdir(struct inode *dir,
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 
+	if (!fc->dont_mask)
+		mode &= ~current->fs->umask;
+
 	memset(&inarg, 0, sizeof(inarg));
 	inarg.mode = mode;
+	inarg.umask = current->fs->umask;
 	req->in.h.opcode = FUSE_MKDIR;
 	req->in.numargs = 2;
 	req->in.args[0].size = sizeof(inarg);
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/fuse/fuse_i.h linux-2.6.18-408.el5.028stab120.1-owl/fs/fuse/fuse_i.h
--- linux-2.6.18-408.el5.028stab120.1/fs/fuse/fuse_i.h	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/fuse/fuse_i.h	2016-10-22 15:45:06 +0000
@@ -391,6 +391,9 @@ struct fuse_conn {
 	/** Is bmap not implemented by fs? */
 	unsigned no_bmap:1;
 
+	/** Don't apply umask to creation modes */
+	unsigned dont_mask:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/fuse/inode.c linux-2.6.18-408.el5.028stab120.1-owl/fs/fuse/inode.c
--- linux-2.6.18-408.el5.028stab120.1/fs/fuse/inode.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/fuse/inode.c	2016-10-22 15:45:06 +0000
@@ -535,6 +535,8 @@ static void process_init_reply(struct fu
 				fc->no_lock = 1;
 			if (arg->flags & FUSE_ATOMIC_O_TRUNC)
 				fc->atomic_o_trunc = 1;
+			if (arg->flags & FUSE_DONT_MASK)
+				fc->dont_mask = 1;
 		} else {
 			ra_pages = fc->max_read / PAGE_CACHE_SIZE;
 			fc->no_lock = 1;
@@ -557,7 +559,8 @@ static void fuse_send_init(struct fuse_c
 	arg->major = FUSE_KERNEL_VERSION;
 	arg->minor = FUSE_KERNEL_MINOR_VERSION;
 	arg->max_readahead = fc->bdi.ra_pages * PAGE_CACHE_SIZE;
-	arg->flags |= FUSE_ASYNC_READ | FUSE_POSIX_LOCKS | FUSE_ATOMIC_O_TRUNC;
+	arg->flags |= FUSE_ASYNC_READ | FUSE_POSIX_LOCKS | FUSE_ATOMIC_O_TRUNC |
+		FUSE_DONT_MASK;
 	req->in.h.opcode = FUSE_INIT;
 	req->in.numargs = 1;
 	req->in.args[0].size = sizeof(*arg);
@@ -619,6 +622,11 @@ static int fuse_fill_super(struct super_
 	if (!fc)
 		return -ENOMEM;
 
+	/* Handle umasking inside the fuse code */
+	if (sb->s_flags & MS_POSIXACL)
+		fc->dont_mask = 1;
+	sb->s_flags |= MS_POSIXACL;
+
 	fc->flags = d.flags;
 	fc->user_id = d.user_id;
 	fc->group_id = d.group_id;
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/gfs2/inode.c linux-2.6.18-408.el5.028stab120.1-owl/fs/gfs2/inode.c
--- linux-2.6.18-408.el5.028stab120.1/fs/gfs2/inode.c	2016-01-25 08:11:39 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/gfs2/inode.c	2016-10-22 15:45:06 +0000
@@ -283,7 +283,7 @@ static void gfs2_set_nlink(struct inode
 static int gfs2_dinode_in(struct gfs2_inode *ip, const void *buf)
 {
 	const struct gfs2_dinode *str = buf;
-	struct timespec atime;
+	struct timespec footime;
 	u16 height, depth;
 
 	if (unlikely(ip->i_no_addr != be64_to_cpu(str->di_num.no_addr)))
@@ -305,14 +305,20 @@ static int gfs2_dinode_in(struct gfs2_in
 	ip->i_disksize = be64_to_cpu(str->di_size);
 	i_size_write(&ip->i_inode, ip->i_disksize);
 	gfs2_set_inode_blocks(&ip->i_inode, be64_to_cpu(str->di_blocks));
-	atime.tv_sec = be64_to_cpu(str->di_atime);
-	atime.tv_nsec = be32_to_cpu(str->di_atime_nsec);
-	if (timespec_compare(&ip->i_inode.i_atime, &atime) < 0)
-		ip->i_inode.i_atime = atime;
-	ip->i_inode.i_mtime.tv_sec = be64_to_cpu(str->di_mtime);
-	ip->i_inode.i_mtime.tv_nsec = be32_to_cpu(str->di_mtime_nsec);
-	ip->i_inode.i_ctime.tv_sec = be64_to_cpu(str->di_ctime);
-	ip->i_inode.i_ctime.tv_nsec = be32_to_cpu(str->di_ctime_nsec);
+	footime.tv_sec = be64_to_cpu(str->di_atime);
+	footime.tv_nsec = be32_to_cpu(str->di_atime_nsec);
+	if (timespec_compare(&ip->i_inode.i_atime, &footime) < 0)
+		ip->i_inode.i_atime = footime;
+
+	footime.tv_sec = be64_to_cpu(str->di_mtime);
+	footime.tv_nsec = be32_to_cpu(str->di_mtime_nsec);
+	if (timespec_compare(&ip->i_inode.i_mtime, &footime) < 0)
+		ip->i_inode.i_mtime = footime;
+
+	footime.tv_sec = be64_to_cpu(str->di_ctime);
+	footime.tv_nsec = be32_to_cpu(str->di_ctime_nsec);
+	if (timespec_compare(&ip->i_inode.i_ctime, &footime) < 0)
+		ip->i_inode.i_ctime = footime;
 
 	ip->i_goal = be64_to_cpu(str->di_goal_meta);
 	ip->i_generation = be64_to_cpu(str->di_generation);
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/namei.c linux-2.6.18-408.el5.028stab120.1-owl/fs/namei.c
--- linux-2.6.18-408.el5.028stab120.1/fs/namei.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/namei.c	2017-06-07 23:55:16 +0000
@@ -665,6 +665,72 @@ static inline void path_to_nameidata(str
 	nd->dentry = path->dentry;
 }
 
+int sysctl_protected_hardlinks __read_mostly = 1;
+
+/**
+ * safe_hardlink_source - Check for safe hardlink conditions
+ * @nd: the source to hardlink from
+ *
+ * Return false if at least one of the following conditions:
+ *    - inode is not a regular file
+ *    - inode is setuid
+ *    - inode is setgid and group-exec
+ *    - access failure for read and write
+ *
+ * Otherwise returns true.
+ */
+static bool safe_hardlink_source(struct nameidata *nd)
+{
+	struct inode *inode = nd->dentry->d_inode;
+	umode_t mode = inode->i_mode;
+
+	/* Special files should not get pinned to the filesystem. */
+	if (!S_ISREG(mode))
+		return false;
+
+	/* Setuid files should not get pinned to the filesystem. */
+	if (mode & S_ISUID)
+		return false;
+
+	/* Executable setgid files should not get pinned to the filesystem. */
+	if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))
+		return false;
+
+	/* Hardlinking to unreadable or unwritable sources is dangerous. */
+	if (vfs_permission(nd, MAY_READ | MAY_WRITE))
+		return false;
+
+	return true;
+}
+
+/**
+ * may_linkat - Check permissions for creating a hardlink
+ * @nd: the source to hardlink from
+ *
+ * Block hardlink when all of:
+ *  - sysctl_protected_hardlinks enabled
+ *  - fsuid does not match inode
+ *  - hardlink source is unsafe (see safe_hardlink_source() above)
+ *  - not CAP_FOWNER in a namespace with the inode owner uid mapped
+ *
+ * Returns 0 if successful, -ve on error.
+ */
+static int may_linkat(struct nameidata *nd)
+{
+	if (!sysctl_protected_hardlinks)
+		return 0;
+
+	/* Source inode owner (or CAP_FOWNER) can hardlink all they like,
+	 * otherwise, it must be a safe source.
+	 */
+	if (current->fsuid == nd->dentry->d_inode->i_uid ||
+	    capable(CAP_FOWNER) ||
+	    safe_hardlink_source(nd))
+		return 0;
+
+	return -EPERM;
+}
+
 static __always_inline int __do_follow_link(struct vfs_path *path, struct nameidata *nd)
 {
 	int error;
@@ -2629,6 +2695,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	error = -EXDEV;
 	if (old_nd.mnt != nd.mnt)
 		goto out_release;
+	error = may_linkat(&old_nd);
+	if (error)
+		goto out_release;
 	new_dentry = lookup_create(&nd, 0);
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/namespace.c linux-2.6.18-408.el5.028stab120.1-owl/fs/namespace.c
--- linux-2.6.18-408.el5.028stab120.1/fs/namespace.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/namespace.c	2016-08-23 15:41:27 +0000
@@ -1031,7 +1031,7 @@ void replace_mount(struct vfsmount *src_
 	path_release(&dst_nd);
 	release_mounts(&umount_list);
 
-	return 0;
+	return;
 }
 EXPORT_SYMBOL_GPL(replace_mount);
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/nfs/inode.c linux-2.6.18-408.el5.028stab120.1-owl/fs/nfs/inode.c
--- linux-2.6.18-408.el5.028stab120.1/fs/nfs/inode.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/nfs/inode.c	2016-08-23 15:41:27 +0000
@@ -513,26 +513,30 @@ nfs_fhget(struct super_block *sb, struct
 			inode->i_uid = fattr->uid;
 		if (fattr->valid & NFS_ATTR_FATTR_GROUP)
 			inode->i_gid = fattr->gid;
-		if (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)
-			blocks = fattr->du.nfs2.blocks;
-		if (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {
-			/*
-			 * report the blocks in 512byte units
-			 */
-			blocks = nfs_calc_block_size(fattr->du.nfs3.used);
-		}
-		if (qi && qi->inode) {
-			inode->i_blocks = 0;
-			/* Before I forgot this _again_. inode is still
-			 * not attached to dentry. If vzquota is on, it
-			 * is OK, it is initialized already.
-			 * But if it was initialized to be out of quota
-			 * subtree, vzquota tries to reinitialize it.
-			 * And fails.
-			 */
-			DQUOT_SYNC_BLOCKS(inode, blocks);
-		} else {
-			inode->i_blocks = blocks;
+		if (fattr->valid &
+		    (NFS_ATTR_FATTR_BLOCKS_USED | NFS_ATTR_FATTR_SPACE_USED)) {
+			if (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED) {
+				blocks = fattr->du.nfs2.blocks;
+			} else {
+				/*
+				 * report the blocks in 512byte units
+				 */
+				blocks = nfs_calc_block_size(
+				    fattr->du.nfs3.used);
+			}
+			if (qi && qi->inode) {
+				inode->i_blocks = 0;
+				/* Before I forgot this _again_. inode is still
+				 * not attached to dentry. If vzquota is on, it
+				 * is OK, it is initialized already.
+				 * But if it was initialized to be out of quota
+				 * subtree, vzquota tries to reinitialize it.
+				 * And fails.
+				 */
+				DQUOT_SYNC_BLOCKS(inode, blocks);
+			} else {
+				inode->i_blocks = blocks;
+			}
 		}
 		nfsi->attrtimeo = NFS_MINATTRTIMEO(inode);
 		nfsi->attrtimeo_timestamp = jiffies;
@@ -930,17 +934,16 @@ static void nfs_sync_blocks(struct inode
 {
 	blkcnt_t blocks;
 
-	if (unlikely((fattr->valid & NFS_ATTR_FATTR) == 0))
-		return;
-
+	if (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED) {
+		blocks = fattr->du.nfs2.blocks;
+	} else
 	if (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {
 		/*
 		 * report the blocks in 512byte units
 		 */
 		blocks = nfs_calc_block_size(fattr->du.nfs3.used);
- 	}
-	if (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)
-		blocks = fattr->du.nfs2.blocks;
+ 	} else
+		return;
 
 	DQUOT_SYNC_BLOCKS(inode, blocks);
 }
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/proc/base.c linux-2.6.18-408.el5.028stab120.1-owl/fs/proc/base.c
--- linux-2.6.18-408.el5.028stab120.1/fs/proc/base.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/proc/base.c	2016-08-23 15:41:27 +0000
@@ -276,7 +276,7 @@ static struct pid_entry tgid_base_stuff[
 	E(PROC_TGID_IO,             "io",  S_IFREG|S_IRUSR),
 #endif
 #ifdef CONFIG_STACKTRACE_PROC
-	E(PROC_TGID_STACK,     "stack",   S_IFREG|S_IRUGO),
+	E(PROC_TGID_STACK,     "stack",   S_IFREG|S_IRUSR),
 #endif
 
 	{0,0,NULL,0}
@@ -327,7 +327,7 @@ static struct pid_entry tid_base_stuff[]
 	E(PROC_TID_IO,         "io",      S_IFREG|S_IRUSR),
 #endif
 #ifdef CONFIG_STACKTRACE_PROC
-	E(PROC_TID_STACK,      "stack",   S_IFREG|S_IRUGO),
+	E(PROC_TID_STACK,      "stack",   S_IFREG|S_IRUSR),
 #endif
 
 	{0,0,NULL,0}
@@ -1052,6 +1052,9 @@ static ssize_t mem_read(struct file * fi
 	if (file->private_data != (void*)((long)current->self_exec_id))
 		goto out_put;
 
+	if (!mm->dumpable && task == current)
+		goto out_put;
+
 	ret = 0;
  
 	while (count > 0) {
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/proc/proc_misc.c linux-2.6.18-408.el5.028stab120.1-owl/fs/proc/proc_misc.c
--- linux-2.6.18-408.el5.028stab120.1/fs/proc/proc_misc.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/proc/proc_misc.c	2016-08-23 15:41:27 +0000
@@ -902,7 +902,7 @@ void __init proc_misc_init(void)
 	create_seq_entry("interrupts", 0, &proc_interrupts_operations);
 	create_seq_entry("softirqs", 0, &proc_softirqs_operations);
 #ifdef CONFIG_SLAB
-	create_seq_entry("slabinfo",S_IWUSR|S_IRUGO,&proc_slabinfo_operations);
+	create_seq_entry("slabinfo",S_IRUSR,&proc_slabinfo_operations);
 #ifdef CONFIG_DEBUG_SLAB_LEAK
 	create_seq_entry("slab_allocators", 0 ,&proc_slabstats_operations);
 #endif
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/proc/task_mmu.c linux-2.6.18-408.el5.028stab120.1-owl/fs/proc/task_mmu.c
--- linux-2.6.18-408.el5.028stab120.1/fs/proc/task_mmu.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/proc/task_mmu.c	2016-08-23 15:41:27 +0000
@@ -166,7 +166,7 @@ static int show_map_internal(struct seq_
 	struct proc_maps_private *priv = m->private;
 	struct task_struct *task = priv->task;
 #ifdef __i386__
-	struct mm_struct *tmm = get_task_mm(task);
+	struct mm_struct *tmm;
 #endif
 	struct vm_area_struct *vma = v;
 	struct mm_struct *mm = vma->vm_mm;
@@ -177,6 +177,13 @@ static int show_map_internal(struct seq_
 	dev_t dev = 0;
 	int len;
 
+	if (current->exec_id != m->exec_id)
+		return 0;
+
+#ifdef __i386__
+	tmm = get_task_mm(task);
+#endif
+
 	if (file) {
 		struct inode *inode = vma->vm_file->f_dentry->d_inode;
 		dev = inode->i_sb->s_dev;
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/seq_file.c linux-2.6.18-408.el5.028stab120.1-owl/fs/seq_file.c
--- linux-2.6.18-408.el5.028stab120.1/fs/seq_file.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/seq_file.c	2016-08-23 15:41:27 +0000
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/seq_file.h>
 #include <linux/slab.h>
+#include <linux/sched.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -39,6 +40,7 @@ int seq_open(struct file *file, struct s
 	memset(p, 0, sizeof(*p));
 	mutex_init(&p->lock);
 	p->op = op;
+	p->exec_id = current->exec_id;
 
 	/*
 	 * Wrappers around seq_open(e.g. swaps_open) need to be
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/sysfs/file.c linux-2.6.18-408.el5.028stab120.1-owl/fs/sysfs/file.c
--- linux-2.6.18-408.el5.028stab120.1/fs/sysfs/file.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/sysfs/file.c	2016-08-23 15:41:27 +0000
@@ -159,8 +159,8 @@ sysfs_read_file(struct file *file, char
 		if ((retval = fill_read_buffer(file->f_dentry,buffer)))
 			goto out;
 	}
-	pr_debug("%s: count = %d, ppos = %lld, buf = %s\n",
-		 __FUNCTION__,count,*ppos,buffer->page);
+	pr_debug("%s: count = %lu, ppos = %lld, buf = %s\n",
+		 __FUNCTION__,(unsigned long)count,*ppos,buffer->page);
 	retval = flush_read_buffer(buffer,buf,count,ppos);
 out:
 	up(&buffer->sem);
diff -urpN linux-2.6.18-408.el5.028stab120.1/fs/sysfs/inode.c linux-2.6.18-408.el5.028stab120.1-owl/fs/sysfs/inode.c
--- linux-2.6.18-408.el5.028stab120.1/fs/sysfs/inode.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/fs/sysfs/inode.c	2016-08-23 15:41:27 +0000
@@ -16,7 +16,15 @@
 #include <linux/security.h>
 #include "sysfs.h"
 
-static inline void set_inode_attr(struct inode * inode, struct iattr * iattr);
+static inline void set_inode_attr(struct inode * inode, struct iattr * iattr)
+{
+	inode->i_mode = iattr->ia_mode;
+	inode->i_uid = iattr->ia_uid;
+	inode->i_gid = iattr->ia_gid;
+	inode->i_atime = iattr->ia_atime;
+	inode->i_mtime = iattr->ia_mtime;
+	inode->i_ctime = iattr->ia_ctime;
+}
 
 static const struct address_space_operations sysfs_aops = {
 	.readpage	= simple_readpage,
@@ -189,16 +197,6 @@ static inline void set_default_inode_att
 	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 }
 
-static inline void set_inode_attr(struct inode * inode, struct iattr * iattr)
-{
-	inode->i_mode = iattr->ia_mode;
-	inode->i_uid = iattr->ia_uid;
-	inode->i_gid = iattr->ia_gid;
-	inode->i_atime = iattr->ia_atime;
-	inode->i_mtime = iattr->ia_mtime;
-	inode->i_ctime = iattr->ia_ctime;
-}
-
 /*
  * sysfs has a different i_mutex lock order behavior for i_mutex than other
  * filesystems; sysfs i_mutex is called in many places with subsystem locks
diff -urpN linux-2.6.18-408.el5.028stab120.1/include/asm-s390/pgtable.h linux-2.6.18-408.el5.028stab120.1-owl/include/asm-s390/pgtable.h
--- linux-2.6.18-408.el5.028stab120.1/include/asm-s390/pgtable.h	2016-01-25 08:11:39 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/include/asm-s390/pgtable.h	2016-10-22 15:45:06 +0000
@@ -53,6 +53,11 @@ extern void paging_init(void);
  */
 extern char empty_zero_page[PAGE_SIZE];
 #define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
+
+/* TODO: s390 cannot support io_remap_pfn_range... */
+#define io_remap_pfn_range(vma, vaddr, pfn, size, prot) 	       \
+	remap_pfn_range(vma, vaddr, pfn, size, prot)
+
 #endif /* !__ASSEMBLY__ */
 
 /*
diff -urpN linux-2.6.18-408.el5.028stab120.1/include/asm-s390/tlbflush.h linux-2.6.18-408.el5.028stab120.1-owl/include/asm-s390/tlbflush.h
--- linux-2.6.18-408.el5.028stab120.1/include/asm-s390/tlbflush.h	2016-01-25 08:11:39 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/include/asm-s390/tlbflush.h	2016-10-22 15:45:06 +0000
@@ -62,11 +62,11 @@ static inline void __tlb_flush_full(stru
 /*
  * Flush all tlb entries of a page table on all cpus.
  */
-static inline void __tlb_flush_idte(pgd_t *pgd)
+static inline void __tlb_flush_idte(unsigned long asce)
 {
 	asm volatile(
 		"	.insn	rrf,0xb98e0000,0,%0,%1,0"
-		: : "a" (2048), "a" (__pa(pgd) & PAGE_MASK) : "cc" );
+		: : "a" (2048), "a" (asce) : "cc" );
 }
 
 static inline void __tlb_flush_mm(struct mm_struct * mm)
@@ -79,7 +79,13 @@ static inline void __tlb_flush_mm(struct
 	 * only ran on the local cpu.
 	 */
 	if (MACHINE_HAS_IDTE) {
-		__tlb_flush_idte(mm->pgd);
+		unsigned long asce_bits;
+#ifndef __s390x__
+		asce_bits = _SEGMENT_TABLE | USER_STD_MASK;
+#else /* __s390x__ */
+		asce_bits = _REGION_TABLE | USER_STD_MASK;
+#endif /* __s390x__ */
+		__tlb_flush_idte(__pa(mm->pgd) | asce_bits);
 		return;
 	}
 	__tlb_flush_full(mm);
diff -urpN linux-2.6.18-408.el5.028stab120.1/include/linux/binfmts.h linux-2.6.18-408.el5.028stab120.1-owl/include/linux/binfmts.h
--- linux-2.6.18-408.el5.028stab120.1/include/linux/binfmts.h	2016-01-25 08:11:39 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/include/linux/binfmts.h	2017-06-19 14:40:12 +0000
@@ -13,7 +13,10 @@ struct pt_regs;
  */
 #define MAX_ARG_PAGES 32
 #define MAX_ARG_STRLEN (PAGE_SIZE * 32)
-#define MAX_ARG_STRINGS 0x7FFFFFFF
+#define MAX_ARG_STACK (0xC0000000UL / 4)
+#define MAX_ARG_STRINGS (MAX_ARG_STACK / 5)
+#define MAX_ARG_STACK_SUGID (512 * 1024)
+#define MAX_RLIMIT_STACK_SUGID (10 * 1024 * 1024)
 
 /* sizeof(linux_binprm->buf) */
 #define BINPRM_BUF_SIZE 128
diff -urpN linux-2.6.18-408.el5.028stab120.1/include/linux/dmar.h linux-2.6.18-408.el5.028stab120.1-owl/include/linux/dmar.h
--- linux-2.6.18-408.el5.028stab120.1/include/linux/dmar.h	2016-01-25 08:11:39 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/include/linux/dmar.h	2016-08-23 15:41:27 +0000
@@ -125,10 +125,6 @@ extern int irq_remapped(int irq);
 extern struct intel_iommu *map_dev_to_ir(struct pci_dev *dev);
 extern struct intel_iommu *map_ioapic_to_ir(int apic);
 #else
-static inline int enable_drhd_fault_handling(void)
-{
-	return -1;
-}
 static inline int alloc_irte(struct intel_iommu *iommu, int irq, u16 count)
 {
 	return -1;
diff -urpN linux-2.6.18-408.el5.028stab120.1/include/linux/fs.h linux-2.6.18-408.el5.028stab120.1-owl/include/linux/fs.h
--- linux-2.6.18-408.el5.028stab120.1/include/linux/fs.h	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/include/linux/fs.h	2017-06-07 23:55:16 +0000
@@ -51,6 +51,7 @@ extern int leases_enable, lease_break_ti
 extern int odirect_enable;
 extern int snapapi_enable;
 extern int lsyscall_enable;
+extern int sysctl_protected_hardlinks;
 
 #ifdef CONFIG_DNOTIFY
 extern int dir_notify_enable;
diff -urpN linux-2.6.18-408.el5.028stab120.1/include/linux/fuse.h linux-2.6.18-408.el5.028stab120.1-owl/include/linux/fuse.h
--- linux-2.6.18-408.el5.028stab120.1/include/linux/fuse.h	2016-01-25 08:11:39 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/include/linux/fuse.h	2016-10-22 15:45:06 +0000
@@ -20,6 +20,9 @@
  *
  * 7.10
  *  - add nonseekable open flag
+ *
+ * 7.11
+ *  - add umask flag to input argument of open, mknod and mkdir
  */
 
 #ifndef _LINUX_FUSE_H
@@ -32,7 +35,7 @@
 #define FUSE_KERNEL_VERSION 7
 
 /** Minor version number of this interface */
-#define FUSE_KERNEL_MINOR_VERSION 10
+#define FUSE_KERNEL_MINOR_VERSION 12
 
 /** The node ID of the root inode */
 #define FUSE_ROOT_ID 1
@@ -112,11 +115,13 @@ struct fuse_file_lock {
 
 /**
  * INIT request/reply flags
+ * FUSE_DONT_MASK: don't apply umask to file mode on create operations
  */
 #define FUSE_ASYNC_READ		(1 << 0)
 #define FUSE_POSIX_LOCKS	(1 << 1)
 #define FUSE_FILE_OPS		(1 << 2)
 #define FUSE_ATOMIC_O_TRUNC	(1 << 3)
+#define FUSE_DONT_MASK		(1 << 6)
 
 /**
  * Release flags
@@ -225,14 +230,18 @@ struct fuse_attr_out {
 	struct fuse_attr attr;
 };
 
+#define FUSE_COMPAT_MKNOD_IN_SIZE 8
+
 struct fuse_mknod_in {
 	__u32	mode;
 	__u32	rdev;
+	__u32	umask;
+	__u32	padding;
 };
 
 struct fuse_mkdir_in {
 	__u32	mode;
-	__u32	padding;
+	__u32	umask;
 };
 
 struct fuse_rename_in {
@@ -264,7 +273,14 @@ struct fuse_setattr_in {
 
 struct fuse_open_in {
 	__u32	flags;
+	__u32	unused;
+};
+
+struct fuse_create_in {
+	__u32	flags;
 	__u32	mode;
+	__u32	umask;
+	__u32	padding;
 };
 
 struct fuse_open_out {
diff -urpN linux-2.6.18-408.el5.028stab120.1/include/linux/mm.h linux-2.6.18-408.el5.028stab120.1-owl/include/linux/mm.h
--- linux-2.6.18-408.el5.028stab120.1/include/linux/mm.h	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/include/linux/mm.h	2017-01-25 09:20:33 +0000
@@ -1193,6 +1193,8 @@ int remap_pfn_range(struct vm_area_struc
 int vm_insert_page(struct vm_area_struct *, unsigned long addr, struct page *);
 int vm_insert_pfn(struct vm_area_struct *vma, unsigned long addr,
 			unsigned long pfn);
+int vm_iomap_memory(struct vm_area_struct *vma, unsigned long start, unsigned long len);
+
 
 struct page *follow_page(struct vm_area_struct *, unsigned long address,
 			unsigned int foll_flags);
@@ -1200,6 +1202,7 @@ struct page *follow_page(struct vm_area_
 #define FOLL_TOUCH	0x02	/* mark page accessed */
 #define FOLL_GET	0x04	/* do get_page on page */
 #define FOLL_ANON	0x08	/* give ZERO_PAGE if no pgtable */
+#define FOLL_COW	0x4000	/* internal GUP flag */
 
 #ifdef CONFIG_XEN
 typedef int (*pte_fn_t)(pte_t *pte, struct page *pmd_page, unsigned long addr,
diff -urpN linux-2.6.18-408.el5.028stab120.1/include/linux/sched.h linux-2.6.18-408.el5.028stab120.1-owl/include/linux/sched.h
--- linux-2.6.18-408.el5.028stab120.1/include/linux/sched.h	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/include/linux/sched.h	2016-08-23 15:41:27 +0000
@@ -1232,6 +1232,8 @@ struct task_struct {
 	unsigned char fpu_counter;
 #endif
 #endif /* CONFIG_X86 */
+
+	u64 exec_id;
 };
 
 static inline pid_t process_group(struct task_struct *tsk)
diff -urpN linux-2.6.18-408.el5.028stab120.1/include/linux/seq_file.h linux-2.6.18-408.el5.028stab120.1-owl/include/linux/seq_file.h
--- linux-2.6.18-408.el5.028stab120.1/include/linux/seq_file.h	2016-01-25 08:11:39 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/include/linux/seq_file.h	2016-08-23 15:41:27 +0000
@@ -22,6 +22,7 @@ struct seq_file {
 	struct mutex lock;
 	struct seq_operations *op;
 	void *private;
+	u64 exec_id;
 };
 
 struct seq_operations {
diff -urpN linux-2.6.18-408.el5.028stab120.1/include/linux/sysctl.h linux-2.6.18-408.el5.028stab120.1-owl/include/linux/sysctl.h
--- linux-2.6.18-408.el5.028stab120.1/include/linux/sysctl.h	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/include/linux/sysctl.h	2016-08-23 15:41:27 +0000
@@ -476,6 +476,7 @@ enum
 	NET_IPV4_LOCAL_RESERVED_PORTS=125,
 	NET_TCP_PORT_FORWARD_RANGE=150,
 	NET_TCP_USE_SG=245,
+	NET_PING_GROUP_RANGE=246,
 };
 
 enum {
diff -urpN linux-2.6.18-408.el5.028stab120.1/include/linux/ve.h linux-2.6.18-408.el5.028stab120.1-owl/include/linux/ve.h
--- linux-2.6.18-408.el5.028stab120.1/include/linux/ve.h	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/include/linux/ve.h	2016-08-23 15:41:27 +0000
@@ -216,6 +216,7 @@ struct ve_struct {
 	struct ctl_table_header	*forward_header;
 	struct ctl_table	*forward_table;
 	unsigned long		rt_flush_required;
+	unsigned int 		ping_group_range[2];
 	struct neigh_table	*ve_arp_tbl;
 #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
 	struct ipv6_devconf	*_ipv6_devconf;
diff -urpN linux-2.6.18-408.el5.028stab120.1/include/net/ping.h linux-2.6.18-408.el5.028stab120.1-owl/include/net/ping.h
--- linux-2.6.18-408.el5.028stab120.1/include/net/ping.h	1970-01-01 00:00:00 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/include/net/ping.h	2011-02-10 18:44:33 +0000
@@ -0,0 +1,68 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the "ping" module.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _PING_H
+#define _PING_H
+
+//#include <net/netns/hash.h>
+#include <net/inet_sock.h>
+
+#ifdef CONFIG_IP_PING_DEBUG
+#define ping_debug(fmt, x...) printk(KERN_INFO fmt, ## x)
+#else
+#define ping_debug(fmt, x...) do {} while (0)
+#endif
+
+/* PING_HTABLE_SIZE must be power of 2 */
+#define PING_HTABLE_SIZE 	64
+#define PING_HTABLE_MASK 	(PING_HTABLE_SIZE-1)
+
+#define ping_portaddr_for_each_entry(__sk, node, list) \
+	hlist_nulls_for_each_entry(__sk, node, list, sk_nulls_node)
+
+#define MAX_PING_IDENT 	65536
+
+
+struct ping_table {
+	struct hlist_head	hash[PING_HTABLE_SIZE];
+	rwlock_t		lock;
+};
+
+struct ping_iter_state {
+	int			bucket;
+};
+
+extern struct proto ping_prot;
+
+
+#ifdef CONFIG_IP_PING
+#define icmp_echoreply ping_rcv
+#else
+#define icmp_echoreply icmp_discard
+#endif
+
+extern void ping_rcv(struct sk_buff *);
+extern void ping_err(struct sk_buff *, u32 info);
+
+int ipv4_ping_group_range(ctl_table *table, int write, struct file *filep,
+				 void __user *buffer,
+				 size_t *lenp, loff_t *ppos);
+
+#ifdef CONFIG_PROC_FS
+extern int __init ping_proc_init(void);
+extern void ping_proc_exit(void);
+#endif
+
+void __init ping_init(void);
+
+
+#endif /* _PING_H */
diff -urpN linux-2.6.18-408.el5.028stab120.1/include/net/sock.h linux-2.6.18-408.el5.028stab120.1-owl/include/net/sock.h
--- linux-2.6.18-408.el5.028stab120.1/include/net/sock.h	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/include/net/sock.h	2016-08-23 15:41:27 +0000
@@ -497,27 +497,6 @@ static inline void __sk_add_backlog(stru
 	skb->next = NULL;
 }
 
-/*
- * Take into account size of receive queue and backlog queue
- */
-static inline bool sk_rcvqueues_full(const struct sock *sk, const struct sk_buff *skb)
-{
-	unsigned int qsize = sk_extended(sk)->sk_backlog.len +
-			     atomic_read(&sk->sk_rmem_alloc);
-
-	return qsize + skb->truesize > sk->sk_rcvbuf;
-}
-
-/* The per-socket spinlock must be held here. */
-static inline __must_check int sk_add_backlog(struct sock *sk, struct sk_buff *skb)
-{
-	if (sk_rcvqueues_full(sk, skb))
-		return -ENOBUFS;
-
-	__sk_add_backlog(sk, skb);
-	sk_extended(sk)->sk_backlog.len += skb->truesize;
-	return 0;
-}
 
 #define sk_wait_event(__sk, __timeo, __condition)		\
 ({	int rc;							\
@@ -645,6 +624,28 @@ static inline struct sock_extended *sk_e
 	return (struct sock_extended *) (((char *) sk) + obj_size);
 }
 
+/*
+ * Take into account size of receive queue and backlog queue
+ */
+static inline bool sk_rcvqueues_full(const struct sock *sk, const struct sk_buff *skb)
+{
+	unsigned int qsize = sk_extended(sk)->sk_backlog.len +
+			     atomic_read(&sk->sk_rmem_alloc);
+
+	return qsize + skb->truesize > sk->sk_rcvbuf;
+}
+
+/* The per-socket spinlock must be held here. */
+static inline __must_check int sk_add_backlog(struct sock *sk, struct sk_buff *skb)
+{
+	if (sk_rcvqueues_full(sk, skb))
+		return -ENOBUFS;
+
+	__sk_add_backlog(sk, skb);
+	sk_extended(sk)->sk_backlog.len += skb->truesize;
+	return 0;
+}
+
 #ifdef SOCK_REFCNT_DEBUG
 static inline void sk_refcnt_debug_inc(struct sock *sk)
 {
diff -urpN linux-2.6.18-408.el5.028stab120.1/init/do_mounts.c linux-2.6.18-408.el5.028stab120.1-owl/init/do_mounts.c
--- linux-2.6.18-408.el5.028stab120.1/init/do_mounts.c	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/init/do_mounts.c	2011-07-27 04:03:04 +0000
@@ -13,6 +13,10 @@
 #include <linux/nfs_fs_sb.h>
 #include <linux/nfs_mount.h>
 
+#ifdef CONFIG_BLK_DEV_IDECD
+#include <linux/ide.h>
+#endif
+
 #include "do_mounts.h"
 
 extern int get_filesystem_list(char * buf);
@@ -267,10 +271,63 @@ static void __init get_fs_names(char *pa
 
 static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 {
-	int err = sys_mount(name, "/root", fs, flags, data);
+	int err = -ENODEV;
+
+	if (!strcmp(saved_root_name, "/dev/cdrom")) {
+		char realname[10];
+#ifdef CONFIG_BLK_DEV_IDECD
+		int h, unit;
+		for (h = 0; h < MAX_HWIFS; h++) {
+			ide_hwif_t *hwif = &ide_hwifs[h];
+			if (!hwif->present)
+				continue;
+			for (unit = 0; unit < MAX_DRIVES; unit++) {
+				ide_drive_t *drive = &hwif->drives[unit];
+				if (!drive->present ||
+				    drive->media != ide_cdrom)
+					continue;
+				snprintf(realname, sizeof(realname),
+				    "/dev/%s", drive->name);
+				printk(KERN_INFO "Trying to mount %s...\n",
+				    realname);
+				create_dev(name,
+				    MKDEV(hwif->major, unit << PARTN_BITS));
+				err = sys_mount(name, "/root", fs, flags, data);
+				if (!err)
+					goto ok;
+			}
+		}
+#endif
+#ifdef CONFIG_BLK_DEV_SR
+		strcpy(realname, "/dev/scd0");
+		while (realname[8] < '8') {
+			int retries = root_delay;
+retry:
+			printk(KERN_INFO "Trying to mount %s...\n", realname);
+			if (retries == root_delay)
+				create_dev(name,
+				    MKDEV(SCSI_CDROM_MAJOR, realname[8] - '0'));
+			err = sys_mount(name, "/root", fs, flags, data);
+			if (!err)
+				goto ok;
+			if (err == -ENXIO || err == -ENODEV) {
+				if (retries-- <= 0)
+					return err;
+				printk(KERN_INFO "Retrying in 1 sec...\n");
+				ssleep(1);
+				goto retry;
+			}
+			realname[8]++;
+		}
+#endif
+		return err;
+	}
+
+	err = sys_mount(name, "/root", fs, flags, data);
 	if (err)
 		return err;
 
+ok:
 	sys_chdir("/root");
 	ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
 	printk("VFS: Mounted root (%s filesystem)%s.\n",
@@ -397,7 +454,7 @@ void __init prepare_namespace(void)
 {
 	int is_floppy;
 
-	if (root_delay) {
+	if (root_delay && strcmp(saved_root_name, "/dev/cdrom")) {
 		printk(KERN_INFO "Waiting %dsec before mounting root device...\n",
 		       root_delay);
 		ssleep(root_delay);
diff -urpN linux-2.6.18-408.el5.028stab120.1/init/do_mounts_md.c linux-2.6.18-408.el5.028stab120.1-owl/init/do_mounts_md.c
--- linux-2.6.18-408.el5.028stab120.1/init/do_mounts_md.c	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/init/do_mounts_md.c	2011-07-27 04:03:04 +0000
@@ -122,6 +122,7 @@ static void __init md_setup_drive(void)
 
 	for (ent = 0; ent < md_setup_ents ; ent++) {
 		int fd;
+		int disknum = 0;
 		int err = 0;
 		char *devname;
 		mdu_disk_info_t dinfo;
@@ -144,7 +145,7 @@ static void __init md_setup_drive(void)
 
 			p = strchr(devname, ',');
 			if (p)
-				*p++ = 0;
+				*p = 0;
 
 			dev = name_to_dev_t(devname);
 			if (strncmp(devname, "/dev/", 5) == 0)
@@ -154,17 +155,22 @@ static void __init md_setup_drive(void)
 			if (rdev)
 				dev = new_decode_dev(rdev);
 			if (!dev) {
-				printk(KERN_WARNING "md: Unknown device name: %s\n", devname);
-				break;
+				printk(KERN_WARNING "md: Skipping unknown device name: %s\n", devname);
+				if (p)
+					*p++ = ',';
+				devname = p;
+				continue;
 			}
 
-			devices[i] = dev;
+			devices[disknum++] = dev;
 
+			if (p)
+				*p++ = ',';
 			devname = p;
 		}
-		devices[i] = 0;
+		devices[disknum] = 0;
 
-		if (!i)
+		if (!disknum)
 			continue;
 
 		printk(KERN_INFO "md: Loading md%s%d: %s\n",
diff -urpN linux-2.6.18-408.el5.028stab120.1/kernel/exit.c linux-2.6.18-408.el5.028stab120.1-owl/kernel/exit.c
--- linux-2.6.18-408.el5.028stab120.1/kernel/exit.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/kernel/exit.c	2016-08-23 15:41:27 +0000
@@ -956,12 +956,28 @@ fastcall NORET_TYPE void do_exit(long co
 	int group_dead;
 	unsigned int mycpu;
 
+	/*
+	 * Check this first since set_fs() below depends on
+	 * current_thread_info(), which we better not access when we're in
+	 * interrupt context.  Other than that, we want to do the set_fs()
+	 * as early as possible.
+	 */
+	if (unlikely(in_interrupt()))
+		panic("Aiee, killing interrupt handler!");
+
+	/*
+	 * If do_exit is called because this process Oops'ed, it's possible
+	 * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before
+	 * continuing. Amongst other possible reasons, this is to prevent
+	 * mm_release()->clear_child_tid() from writing to a user-controlled
+	 * kernel address.
+	 */
+	set_fs(USER_DS);
+
 	profile_task_exit(tsk);
 
 	WARN_ON(atomic_read(&tsk->fs_excl));
 
-	if (unlikely(in_interrupt()))
-		panic("Aiee, killing interrupt handler!");
 	if (unlikely(!tsk->pid))
 		panic("Attempted to kill the idle task!");
 #ifdef CONFIG_VE
diff -urpN linux-2.6.18-408.el5.028stab120.1/kernel/kallsyms.c linux-2.6.18-408.el5.028stab120.1-owl/kernel/kallsyms.c
--- linux-2.6.18-408.el5.028stab120.1/kernel/kallsyms.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/kernel/kallsyms.c	2016-08-23 15:41:27 +0000
@@ -421,7 +421,7 @@ static int __init kallsyms_init(void)
 {
 	struct proc_dir_entry *entry;
 
-	entry = create_proc_entry("kallsyms", 0444, NULL);
+	entry = create_proc_entry("kallsyms", 0400, NULL);
 	if (entry)
 		entry->proc_fops = &kallsyms_operations;
 	return 0;
diff -urpN linux-2.6.18-408.el5.028stab120.1/kernel/module.c linux-2.6.18-408.el5.028stab120.1-owl/kernel/module.c
--- linux-2.6.18-408.el5.028stab120.1/kernel/module.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/kernel/module.c	2016-08-23 15:41:27 +0000
@@ -1729,7 +1729,7 @@ static struct module *load_module(void _
 	mod = (void *)sechdrs[modindex].sh_addr;
 	mod->gpgsig_ok = gpgsig_ok;
 
-#if CONFIG_MODULE_SIG
+#ifdef CONFIG_MODULE_SIG
 	if (!mod->gpgsig_ok)
 		add_taint_module(mod, TAINT_UNSIGNED_MODULE);
 #endif
@@ -2347,7 +2347,7 @@ static char *taint_flags(unsigned int ta
 			buf[bx++] = 'P';
 		if (taints & TAINT_FORCED_MODULE)
 			buf[bx++] = 'F';
-#if CONFIG_MODULE_SIG
+#ifdef CONFIG_MODULE_SIG
 		if (taints & TAINT_UNSIGNED_MODULE)
 			buf[bx++] = 'U';
 #endif
diff -urpN linux-2.6.18-408.el5.028stab120.1/kernel/mutex.c linux-2.6.18-408.el5.028stab120.1-owl/kernel/mutex.c
--- linux-2.6.18-408.el5.028stab120.1/kernel/mutex.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/kernel/mutex.c	2016-08-23 15:41:27 +0000
@@ -58,7 +58,7 @@ EXPORT_SYMBOL(__mutex_init);
  * We also put the fastpath first in the kernel image, to make sure the
  * branch is predicted by the CPU as default-untaken.
  */
-static void fastcall noinline __sched
+void fastcall noinline __sched
 __mutex_lock_slowpath(atomic_t *lock_count);
 
 /***
@@ -95,7 +95,7 @@ void inline fastcall __sched mutex_lock(
 EXPORT_SYMBOL(mutex_lock);
 #endif
 
-static void fastcall noinline __sched
+void fastcall noinline __sched
 __mutex_unlock_slowpath(atomic_t *lock_count);
 
 /***
@@ -260,7 +260,7 @@ __mutex_unlock_common_slowpath(atomic_t
 /*
  * Release the lock, slowpath:
  */
-static fastcall noinline void
+fastcall noinline void
 __mutex_unlock_slowpath(atomic_t *lock_count)
 {
 	__mutex_unlock_common_slowpath(lock_count, 1);
@@ -294,7 +294,7 @@ int fastcall __sched mutex_lock_interrup
 
 EXPORT_SYMBOL(mutex_lock_interruptible);
 
-static void fastcall noinline __sched
+void fastcall noinline __sched
 __mutex_lock_slowpath(atomic_t *lock_count)
 {
 	struct mutex *lock = container_of(lock_count, struct mutex, count);
diff -urpN linux-2.6.18-408.el5.028stab120.1/kernel/panic.c linux-2.6.18-408.el5.028stab120.1-owl/kernel/panic.c
--- linux-2.6.18-408.el5.028stab120.1/kernel/panic.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/kernel/panic.c	2016-08-23 15:41:27 +0000
@@ -20,7 +20,7 @@
 #include <linux/kexec.h>
 #include <linux/debug_locks.h>
 
-int panic_on_oops = 1;
+int panic_on_oops;
 int tainted = 1;
 static int pause_on_oops;
 static int pause_on_oops_flag;
diff -urpN linux-2.6.18-408.el5.028stab120.1/kernel/printk.c linux-2.6.18-408.el5.028stab120.1-owl/kernel/printk.c
--- linux-2.6.18-408.el5.028stab120.1/kernel/printk.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/kernel/printk.c	2016-08-23 15:41:27 +0000
@@ -256,10 +256,6 @@ int do_syslog(int type, char __user *buf
 	if (!ve_is_super(get_exec_env()) && (type == 6 || type == 7))
 		goto out;
 
-	error = security_syslog(type);
-	if (error)
-		return error;
-
 	switch (type) {
 	case 0:		/* Close log */
 		break;
@@ -391,6 +387,12 @@ out:
 
 asmlinkage long sys_syslog(int type, char __user *buf, int len)
 {
+	int error;
+
+	error = security_syslog(type);
+	if (error)
+		return error;
+		
 	return do_syslog(type, buf, len);
 }
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/kernel/ptrace.c linux-2.6.18-408.el5.028stab120.1-owl/kernel/ptrace.c
--- linux-2.6.18-408.el5.028stab120.1/kernel/ptrace.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/kernel/ptrace.c	2016-10-23 19:55:50 +0000
@@ -41,7 +41,7 @@ static int __access_process_vm(struct ta
 	struct page *page;
 	void *old_buf = buf;
 
-	down_read(&mm->mmap_sem);
+	down_write(&mm->mmap_sem);
 	/* ignore errors, just check how much was sucessfully transfered */
 	while (len) {
 		int bytes, ret, offset;
@@ -72,7 +72,7 @@ static int __access_process_vm(struct ta
 		buf += bytes;
 		addr += bytes;
 	}
-	up_read(&mm->mmap_sem);
+	up_write(&mm->mmap_sem);
 	
 	return buf - old_buf;
 }
@@ -1470,7 +1470,7 @@ found:
 	BUG_ON(state->parent != tsk);
 	rcu_read_unlock();
 
-	pr_debug("%d ptrace_do_wait (%d) found %d code %x (%u/%d)\n",
+	pr_debug("%d ptrace_do_wait (%d) found %d code %x (%ld/%d)\n",
 		 current->pid, tsk->pid, p->pid, exit_code,
 		 p->exit_state, p->exit_signal);
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/kernel/relay.c linux-2.6.18-408.el5.028stab120.1-owl/kernel/relay.c
--- linux-2.6.18-408.el5.028stab120.1/kernel/relay.c	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/kernel/relay.c	2016-08-23 15:41:27 +0000
@@ -502,6 +502,7 @@ static inline void setup_callbacks(struc
 	chan->cb = cb;
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
 /**
  *
  * 	relay_hotcpu_callback - CPU hotplug callback
@@ -542,6 +543,7 @@ static int __cpuinit relay_hotcpu_callba
 	}
 	return NOTIFY_OK;
 }
+#endif
 
 /**
  *	relay_open - create a new relay channel
diff -urpN linux-2.6.18-408.el5.028stab120.1/kernel/sched.c linux-2.6.18-408.el5.028stab120.1-owl/kernel/sched.c
--- linux-2.6.18-408.el5.028stab120.1/kernel/sched.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/kernel/sched.c	2016-10-22 16:21:22 +0000
@@ -857,7 +857,9 @@ done_noswitch:
 
 idle:
 	fairsched_switch(prev_node, &fairsched_idle_node, cycles);
+#ifdef CONFIG_SCHEDSTATS
 	vcpu_rq(cur_vcpu)->sched_goidle++;
+#endif
 	vcpu = task_vcpu(this_pcpu()->idle);
 	__vcpu_get(vcpu);
 	spin_unlock(&fairsched_lock);
@@ -2219,7 +2221,9 @@ find_idlest_group(struct sched_domain *s
 		}
 
 		/* Adjust by relative CPU power of the group */
-		avg_load = (avg_load * SCHED_LOAD_SCALE) / group->cpu_power;
+		avg_load = (avg_load * SCHED_LOAD_SCALE);
+		if (group->cpu_power != 0)
+			avg_load /= group->cpu_power;
 
 		if (local_group) {
 			this_load = avg_load;
@@ -3744,7 +3748,9 @@ find_busiest_group(struct sched_domain *
 		total_pwr += group->cpu_power;
 
 		/* Adjust by relative CPU power of the group */
-		avg_load = (avg_load * SCHED_LOAD_SCALE) / group->cpu_power;
+		avg_load = (avg_load * SCHED_LOAD_SCALE);
+		if (group->cpu_power != 0)
+			avg_load /= group->cpu_power;
 
 		group_capacity = group->cpu_power / SCHED_LOAD_SCALE;
 
@@ -3901,7 +3907,9 @@ small_imbalance:
 		pwr_now /= SCHED_LOAD_SCALE;
 
 		/* Amount of load we'd subtract */
-		tmp = busiest_load_per_task*SCHED_LOAD_SCALE/busiest->cpu_power;
+		tmp = busiest_load_per_task*SCHED_LOAD_SCALE;
+		if (busiest->cpu_power != 0)
+			tmp /= busiest->cpu_power;
 		if (max_load > tmp)
 			pwr_move += busiest->cpu_power *
 				min(busiest_load_per_task, max_load - tmp);
@@ -3909,9 +3917,11 @@ small_imbalance:
 		/* Amount of load we'd add */
 		if (max_load*busiest->cpu_power <
 				busiest_load_per_task*SCHED_LOAD_SCALE)
-			tmp = max_load*busiest->cpu_power/this->cpu_power;
+			tmp = max_load*busiest->cpu_power;
 		else
-			tmp = busiest_load_per_task*SCHED_LOAD_SCALE/this->cpu_power;
+			tmp = busiest_load_per_task*SCHED_LOAD_SCALE;
+		if (this->cpu_power != 0)
+			tmp /= this->cpu_power;
 		pwr_move += this->cpu_power*min(this_load_per_task, this_load + tmp);
 		pwr_move /= SCHED_LOAD_SCALE;
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/kernel/sys.c linux-2.6.18-408.el5.028stab120.1-owl/kernel/sys.c
--- linux-2.6.18-408.el5.028stab120.1/kernel/sys.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/kernel/sys.c	2016-08-23 15:41:27 +0000
@@ -1013,13 +1013,8 @@ int set_user(uid_t new_ruid, int dumpcle
 	struct user_struct *new_user;
 
 	new_user = alloc_uid(new_ruid);
-	if (!new_user)
-		return -EAGAIN;
-
-	if (atomic_read(&new_user->processes) >=
-				current->signal->rlim[RLIMIT_NPROC].rlim_cur &&
-			new_ruid != 0) {
-		free_uid(new_user);
+	if (!new_user) {
+		force_sig(SIGKILL, current);
 		return -EAGAIN;
 	}
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/kernel/sysctl.c linux-2.6.18-408.el5.028stab120.1-owl/kernel/sysctl.c
--- linux-2.6.18-408.el5.028stab120.1/kernel/sysctl.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/kernel/sysctl.c	2017-06-07 23:55:16 +0000
@@ -1679,6 +1679,16 @@ static ctl_table fs_table[] = {
 		.proc_handler	= &proc_dointvec
 	},
 	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "protected_hardlinks",
+		.data		= &sysctl_protected_hardlinks,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &zero,
+		.extra2		= &one,
+	},
+	{
 		.ctl_name	= KERN_SETUID_DUMPABLE,
 		.procname	= "suid_dumpable",
 		.data		= &suid_dumpable,
diff -urpN linux-2.6.18-408.el5.028stab120.1/kernel/ve/ve.c linux-2.6.18-408.el5.028stab120.1-owl/kernel/ve/ve.c
--- linux-2.6.18-408.el5.028stab120.1/kernel/ve/ve.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/kernel/ve/ve.c	2016-08-23 15:44:15 +0000
@@ -122,6 +122,7 @@ struct ve_struct ve0 = {
 	.features		= -1,
 	.mnt_nr			= ATOMIC_INIT(0),
 	.ifa_nr			= ATOMIC_INIT(0),
+	.ping_group_range       = { 1, 0 },
 };
 
 EXPORT_SYMBOL(ve0);
diff -urpN linux-2.6.18-408.el5.028stab120.1/kernel/ve/vecalls.c linux-2.6.18-408.el5.028stab120.1-owl/kernel/ve/vecalls.c
--- linux-2.6.18-408.el5.028stab120.1/kernel/ve/vecalls.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/kernel/ve/vecalls.c	2016-08-23 15:43:33 +0000
@@ -1131,6 +1131,9 @@ static int init_ve_struct(struct ve_stru
 	atomic_set(&ve->mnt_nr, 0);
 	atomic_set(&ve->ifa_nr, 0);
 
+	ve->ping_group_range[0] = 1;
+	ve->ping_group_range[1] = 0;
+
 	return 0;
 }
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/mm/madvise.c linux-2.6.18-408.el5.028stab120.1-owl/mm/madvise.c
--- linux-2.6.18-408.el5.028stab120.1/mm/madvise.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/mm/madvise.c	2016-10-23 19:56:21 +0000
@@ -23,7 +23,6 @@ static int madvise_need_mmap_write(int b
 	switch (behavior) {
 	case MADV_REMOVE:
 	case MADV_WILLNEED:
-	case MADV_DONTNEED:
 	case MADV_DEACTIVATE:
 		return 0;
 	default:
diff -urpN linux-2.6.18-408.el5.028stab120.1/mm/memory.c linux-2.6.18-408.el5.028stab120.1-owl/mm/memory.c
--- linux-2.6.18-408.el5.028stab120.1/mm/memory.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/mm/memory.c	2016-12-10 01:06:32 +0000
@@ -1131,6 +1131,23 @@ out:
 	return NULL;
 }
 
+static inline bool can_follow_write_pte(pte_t pte, struct page *page,
+					unsigned int flags)
+{
+	if (pte_write(pte))
+		return true;
+
+	/*
+	 * Make sure that we are really following CoWed page. We do not really
+	 * have to care about exclusiveness of the page because we only want
+	 * to ensure that once COWed page hasn't disappeared in the meantime
+	 * or it hasn't been merged to a KSM page.
+	 */
+	if (flags & FOLL_COW)
+		return page && PageAnon(page);
+
+	return false;
+}
 
 /*
  * Do a quick page-table lookup for a single page.
@@ -1179,9 +1196,11 @@ struct page *follow_page(struct vm_area_
 	pte = *ptep;
 	if (!pte_present(pte))
 		goto no_page;
-	if ((flags & FOLL_WRITE) && !pte_write(pte))
-		goto unlock;
 	page = vm_normal_page(vma, address, pte);
+	if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, page, flags)) {
+		pte_unmap_unlock(ptep, ptl);
+		return NULL;
+	}
 	if (unlikely(!page))
 		goto bad_page;
 
@@ -1193,7 +1212,6 @@ struct page *follow_page(struct vm_area_
 			set_page_dirty(page);
 		mark_page_accessed(page);
 	}
-unlock:
 	pte_unmap_unlock(ptep, ptl);
 out:
 	return page;
@@ -1363,13 +1381,16 @@ int get_user_pages(struct task_struct *t
 				ret = __handle_mm_fault(mm, vma, start,
 						foll_flags & FOLL_WRITE);
 				/*
-				 * The VM_FAULT_WRITE bit tells us that do_wp_page has
-				 * broken COW when necessary, even if maybe_mkwrite
-				 * decided not to set pte_write. We can thus safely do
-				 * subsequent page lookups as if they were reads.
+				 * The VM_FAULT_WRITE bit tells us that
+				 * do_wp_page has broken COW when necessary,
+				 * even if maybe_mkwrite decided not to set
+				 * pte_write. We cannot simply drop FOLL_WRITE
+				 * here because the COWed page might be gone by
+				 * the time we do the subsequent page lookups.
 				 */
-				if (ret & VM_FAULT_WRITE)
-					foll_flags &= ~FOLL_WRITE;
+				if ((ret & VM_FAULT_WRITE) && 
+				    !(vma->vm_flags & VM_WRITE))
+					foll_flags |= FOLL_COW;
 				
 				switch (ret & ~VM_FAULT_WRITE) {
 				case VM_FAULT_MINOR:
@@ -2587,6 +2608,53 @@ out_nomap:
 	return ret;
 }
 
+/**
+ * vm_iomap_memory - remap memory to userspace
+ * @vma: user vma to map to
+ * @start: start of area
+ * @len: size of area
+ *
+ * This is a simplified io_remap_pfn_range() for common driver use. The
+ * driver just needs to give us the physical memory range to be mapped,
+ * we'll figure out the rest from the vma information.
+ *
+ * NOTE! Some drivers might want to tweak vma->vm_page_prot first to get
+ * whatever write-combining details or similar.
+ */
+int vm_iomap_memory(struct vm_area_struct *vma, unsigned long start, unsigned long len)
+{
+	unsigned long vm_len, pfn, pages;
+
+	/* Check that the physical memory area passed in looks valid */
+	if (start + len < start)
+		return -EINVAL;
+	/*
+	 * You *really* shouldn't map things that aren't page-aligned,
+	 * but we've historically allowed it because IO memory might
+	 * just have smaller alignment.
+	 */
+	len += start & ~PAGE_MASK;
+	pfn = start >> PAGE_SHIFT;
+	pages = (len + ~PAGE_MASK) >> PAGE_SHIFT;
+	if (pfn + pages < pfn)
+		return -EINVAL;
+
+	/* We start the mapping 'vm_pgoff' pages into the area */
+	if (vma->vm_pgoff > pages)
+		return -EINVAL;
+	pfn += vma->vm_pgoff;
+	pages -= vma->vm_pgoff;
+
+	/* Can we fit all of the mapping? */
+	vm_len = vma->vm_end - vma->vm_start;
+	if (vm_len >> PAGE_SHIFT > pages)
+		return -EINVAL;
+
+	/* Ok, let it rip */
+	return io_remap_pfn_range(vma, vma->vm_start, pfn, vm_len, vma->vm_page_prot);
+}
+EXPORT_SYMBOL(vm_iomap_memory);
+
 /*
  * This is like a special single-page "expand_{down|up}wards()",
  * except we must first make sure that 'address{-|+}PAGE_SIZE'
diff -urpN linux-2.6.18-408.el5.028stab120.1/mm/mempolicy.c linux-2.6.18-408.el5.028stab120.1-owl/mm/mempolicy.c
--- linux-2.6.18-408.el5.028stab120.1/mm/mempolicy.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/mm/mempolicy.c	2016-08-23 15:41:27 +0000
@@ -1845,6 +1845,9 @@ int show_numa_map(struct seq_file *m, vo
 	int n;
 	char buffer[50];
 
+	if (current->exec_id != m->exec_id)
+		return 0;
+
 	if (!mm)
 		return 0;
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/mm/migrate.c linux-2.6.18-408.el5.028stab120.1-owl/mm/migrate.c
--- linux-2.6.18-408.el5.028stab120.1/mm/migrate.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/mm/migrate.c	2016-08-23 18:13:25 +0000
@@ -890,7 +890,7 @@ asmlinkage long sys_move_pages(pid_t pid
 
 	/* Find the mm_struct */
 	read_lock(&tasklist_lock);
-	task = pid ? find_task_by_pid_all(pid) : current;
+	task = pid ? find_task_by_pid_ve(pid) : current;
 	if (!task) {
 		read_unlock(&tasklist_lock);
 		return -ESRCH;
diff -urpN linux-2.6.18-408.el5.028stab120.1/mm/oom_kill.c linux-2.6.18-408.el5.028stab120.1-owl/mm/oom_kill.c
--- linux-2.6.18-408.el5.028stab120.1/mm/oom_kill.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/mm/oom_kill.c	2016-08-23 15:41:27 +0000
@@ -280,7 +280,7 @@ static void __oom_kill_task(struct task_
 
 	if (virtinfo_notifier_call(VITYPE_GENERAL, VIRTINFO_OOMKILL, p)
 			& NOTIFY_FAIL)
-		return 1;
+		return;
 
 	task_lock(p);
 	if (!p->mm || p->mm == &init_mm) {
diff -urpN linux-2.6.18-408.el5.028stab120.1/mm/page-writeback.c linux-2.6.18-408.el5.028stab120.1-owl/mm/page-writeback.c
--- linux-2.6.18-408.el5.028stab120.1/mm/page-writeback.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/mm/page-writeback.c	2016-08-23 15:41:27 +0000
@@ -152,20 +152,19 @@ get_dirty_limits(long *pbackground, long
 				global_page_state(NR_ANON_PAGES)) * 100) /
 					total_pages;
 
-	if (vm_dirty_bytes)
-		dirty = DIV_ROUND_UP(vm_dirty_bytes, PAGE_SIZE);
-	else {
-		dirty_ratio = vm_dirty_ratio;
+	dirty_ratio = vm_dirty_ratio;
 
-		/* if vm_dirty_ratio is 100 dont limit to 1/2 unmapped_ratio */
-		if ((dirty_ratio > unmapped_ratio / 2) && (dirty_ratio != 100))
-			dirty_ratio = unmapped_ratio / 2;
+	/* if vm_dirty_ratio is 100 dont limit to 1/2 unmapped_ratio */
+	if ((dirty_ratio > unmapped_ratio / 2) && (dirty_ratio != 100))
+		dirty_ratio = unmapped_ratio / 2;
 
-		if (dirty_ratio < 5)
-			dirty_ratio = 5;
+	if (dirty_ratio < 5)
+		dirty_ratio = 5;
 
+	if (vm_dirty_bytes)
+		dirty = DIV_ROUND_UP(vm_dirty_bytes, PAGE_SIZE);
+	else
 		dirty = (dirty_ratio * available_memory) / 100;
-	}
 
 	if (dirty_background_bytes)
 		background = DIV_ROUND_UP(dirty_background_bytes, PAGE_SIZE);
diff -urpN linux-2.6.18-408.el5.028stab120.1/mm/page_alloc.c linux-2.6.18-408.el5.028stab120.1-owl/mm/page_alloc.c
--- linux-2.6.18-408.el5.028stab120.1/mm/page_alloc.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/mm/page_alloc.c	2016-08-23 15:41:27 +0000
@@ -1052,7 +1052,7 @@ nofail_alloc:
 	if (!wait)
 		goto nopage;
 
-	if (test_thread_flag(TIF_MEMDIE) && !(gfp_mask & __GFP_NOFAIL) || would_oom_kill)
+	if ((test_thread_flag(TIF_MEMDIE) && !(gfp_mask & __GFP_NOFAIL)) || would_oom_kill)
 		goto nopage;
 	cond_resched();
 
@@ -1446,7 +1446,7 @@ void show_free_areas(void)
 		printk("= %lukB\n", K(total));
 	}
 
-	printk("%d pagecache pages\n", global_page_state(NR_FILE_PAGES));
+	printk("%ld pagecache pages\n", global_page_state(NR_FILE_PAGES));
 
 	show_swap_cache_info();
 }
@@ -1462,7 +1462,9 @@ void show_free_areas(void)
 #define ZONELIST_ORDER_NODE	(0)
 #define ZONELIST_ORDER_ZONE	(1)
 
+#ifdef CONFIG_NUMA
 static int zonelist_order = ZONELIST_ORDER_NODE;
+#endif
 
 /*
  * Builds allocation fallback zone lists.
diff -urpN linux-2.6.18-408.el5.028stab120.1/net/core/dev.c linux-2.6.18-408.el5.028stab120.1-owl/net/core/dev.c
--- linux-2.6.18-408.el5.028stab120.1/net/core/dev.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/net/core/dev.c	2016-08-23 15:41:27 +0000
@@ -1571,6 +1571,7 @@ static inline int skb_checksum_setup_v4(
 	return skb_setup_csum_ptr(skb, skb->nh.iph->protocol);
 }
 
+#ifdef CONFIG_IPV6
 static inline int skb_checksum_setup_v6(struct sk_buff *skb)
 {
 	int ptr;
@@ -1590,14 +1591,17 @@ static inline int skb_checksum_setup_v6(
 	skb->h.raw = skb->data + ptr;
 	return skb_setup_csum_ptr(skb, nexthdr);
 }
+#endif
 
 inline int skb_checksum_setup(struct sk_buff *skb)
 {
 	if (skb->proto_csum_blank) {
 		if (skb->protocol == htons(ETH_P_IP))
 			return skb_checksum_setup_v4(skb);
+#ifdef CONFIG_IPV6
 		else if (skb->protocol == htons(ETH_P_IPV6))
 			return skb_checksum_setup_v6(skb);
+#endif
 		return -EPROTO;
 	}
 	return 0;
diff -urpN linux-2.6.18-408.el5.028stab120.1/net/ipv4/Kconfig linux-2.6.18-408.el5.028stab120.1-owl/net/ipv4/Kconfig
--- linux-2.6.18-408.el5.028stab120.1/net/ipv4/Kconfig	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/net/ipv4/Kconfig	2016-08-23 15:41:27 +0000
@@ -14,6 +14,26 @@ config IP_MULTICAST
 	  <file:Documentation/networking/multicast.txt>. For most people, it's
 	  safe to say N.
 
+config IP_PING
+	bool "IP: ping socket"
+	help
+	  This option introduces a new kind of sockets - "ping sockets".
+
+	  A ping socket makes it possible to send ICMP Echo messages and receive
+	  corresponding ICMP Echo Reply messages without any special privileges.
+	  In other words, it makes is possible to implement setuid-less /bin/ping.
+
+	  A new ping socket is created with socket(PF_INET, SOCK_DGRAM, PROT_ICMP).
+
+config IP_PING_DEBUG
+	bool "IP: ping socket debug output"
+	depends on IP_PING
+	default n
+	help
+	  Enable the inclusion of debug code in the ICMP ping sockets.
+	  Be aware that doing this will impact performance.
+	  If unsure say N.
+
 config IP_ADVANCED_ROUTER
 	bool "IP: advanced router"
 	---help---
diff -urpN linux-2.6.18-408.el5.028stab120.1/net/ipv4/Makefile linux-2.6.18-408.el5.028stab120.1-owl/net/ipv4/Makefile
--- linux-2.6.18-408.el5.028stab120.1/net/ipv4/Makefile	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/net/ipv4/Makefile	2016-08-23 15:41:27 +0000
@@ -20,6 +20,7 @@ obj-$(CONFIG_IP_FIB_TRIE) += fib_trie.o
 obj-$(CONFIG_PROC_FS) += proc.o
 obj-$(CONFIG_IP_MULTIPLE_TABLES) += fib_rules.o
 obj-$(CONFIG_IP_MROUTE) += ipmr.o
+obj-$(CONFIG_IP_PING) += ping.o
 obj-$(CONFIG_NET_IPIP) += ipip.o
 obj-$(CONFIG_NET_IPGRE) += ip_gre.o
 obj-$(CONFIG_SYN_COOKIES) += syncookies.o
diff -urpN linux-2.6.18-408.el5.028stab120.1/net/ipv4/af_inet.c linux-2.6.18-408.el5.028stab120.1-owl/net/ipv4/af_inet.c
--- linux-2.6.18-408.el5.028stab120.1/net/ipv4/af_inet.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/net/ipv4/af_inet.c	2017-06-19 15:03:24 +0000
@@ -104,6 +104,7 @@
 #include <net/inet_connection_sock.h>
 #include <net/tcp.h>
 #include <net/udp.h>
+#include <net/ping.h>
 #include <linux/skbuff.h>
 #include <net/sock.h>
 #include <net/raw.h>
@@ -922,6 +923,16 @@ static struct inet_protosw inetsw_array[
                 .flags =      INET_PROTOSW_PERMANENT,
        },
         
+#ifdef CONFIG_IP_PING
+       {
+		.type =       SOCK_DGRAM,
+		.protocol =   IPPROTO_ICMP,
+		.prot =       &ping_prot,
+		.ops =        &inet_sockraw_ops,
+		.no_check =   UDP_CSUM_DEFAULT,
+		.flags =      INET_PROTOSW_REUSE,
+       },
+#endif
 
        {
                .type =       SOCK_RAW,
@@ -1348,6 +1359,9 @@ static struct net_protocol udp_protocol
 
 static struct net_protocol icmp_protocol = {
 	.handler =	icmp_rcv,
+#ifdef CONFIG_IP_PING
+	.err_handler =	ping_err,
+#endif
 	.no_policy =	1,
 };
 
@@ -1423,6 +1437,11 @@ static int __init inet_init(void)
 	rc = proto_register(&raw_prot, 1);
 	if (rc)
 		goto out_unregister_udp_proto;
+#ifdef CONFIG_IP_PING
+	rc = proto_register(&ping_prot, 1);
+	if (rc)
+		goto out_unregister_raw_proto;
+#endif
 
 	/*
 	 *	Tell SOCKET that we are alive... 
@@ -1480,6 +1499,10 @@ static int __init inet_init(void)
 
 	icmp_init(&inet_family_ops);
 
+#ifdef CONFIG_IP_PING
+	ping_init();
+#endif
+
 	/*
 	 *	Initialise the multicast router
 	 */
@@ -1503,6 +1526,10 @@ static int __init inet_init(void)
 	rc = 0;
 out:
 	return rc;
+#ifdef CONFIG_IP_PING
+out_unregister_raw_proto:
+	proto_unregister(&raw_prot);
+#endif
 out_unregister_tcp_proto:
 	proto_unregister(&tcp_prot);
 out_unregister_udp_proto:
@@ -1529,11 +1556,19 @@ static int __init ipv4_proc_init(void)
 		goto out_udp;
 	if (fib_proc_init())
 		goto out_fib;
+#ifdef CONFIG_IP_PING
+	if (ping_proc_init())
+		goto out_ping;
+#endif
 	if (ip_misc_proc_init())
 		goto out_misc;
 out:
 	return rc;
 out_misc:
+#ifdef CONFIG_IP_PING
+	ping_proc_exit();
+out_ping:
+#endif
 	fib_proc_exit();
 out_fib:
 	udp4_proc_exit();
diff -urpN linux-2.6.18-408.el5.028stab120.1/net/ipv4/devinet.c linux-2.6.18-408.el5.028stab120.1-owl/net/ipv4/devinet.c
--- linux-2.6.18-408.el5.028stab120.1/net/ipv4/devinet.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/net/ipv4/devinet.c	2016-08-23 15:41:27 +0000
@@ -61,6 +61,9 @@
 
 #include <net/arp.h>
 #include <net/ip.h>
+#ifdef CONFIG_IP_PING
+#include <net/ping.h>
+#endif
 #include <net/route.h>
 #include <net/ip_fib.h>
 
@@ -1713,10 +1716,21 @@ static ctl_table net_sysctl_tables[] = {
 		.procname	= "route",
 		.maxlen		= 0,
 		.mode		= 0555,
-		.child		= &net_sysctl_tables[7],
+		.child		= &net_sysctl_tables[8],
+	},
+#ifdef CONFIG_IP_PING
+	{
+		.ctl_name	= NET_PING_GROUP_RANGE,
+		.procname	= "ping_group_range",
+		.maxlen		= sizeof(int)*2,
+		.mode		= 0644,
+		.proc_handler	= &ipv4_ping_group_range,
 	},
+#else
+	{ .ctl_name = 0 },
+#endif
 	{ .ctl_name = 0 },
-	/* 7: net/ipv4/route/flush */
+	/* 8: net/ipv4/route/flush */
 	{
 		.ctl_name 	= NET_IPV4_ROUTE_FLUSH,
 		.procname	= "flush",
diff -urpN linux-2.6.18-408.el5.028stab120.1/net/ipv4/icmp.c linux-2.6.18-408.el5.028stab120.1-owl/net/ipv4/icmp.c
--- linux-2.6.18-408.el5.028stab120.1/net/ipv4/icmp.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/net/ipv4/icmp.c	2016-08-23 15:41:27 +0000
@@ -84,6 +84,7 @@
 #include <net/tcp.h>
 #include <net/udp.h>
 #include <net/raw.h>
+#include <net/ping.h>
 #include <linux/skbuff.h>
 #include <net/sock.h>
 #include <linux/errno.h>
@@ -821,6 +822,17 @@ static void icmp_redirect(struct sk_buff
 			       iph->saddr, skb->dev);
 		break;
   	}
+
+#ifdef CONFIG_IP_PING
+	/* Ping wants to see redirects.
+         * Let's pretend they are errors of sorts... */
+	if (iph->protocol == IPPROTO_ICMP &&
+	    iph->ihl >= 5 &&
+	    pskb_may_pull(skb, (iph->ihl<<2)+8)) {
+		ping_err(skb, icmp_hdr(skb)->un.gateway);
+	}
+#endif
+
 out:
 	return;
 out_err:
@@ -1063,7 +1075,7 @@ error:
  */
 static const struct icmp_control icmp_pointers[NR_ICMP_TYPES + 1] = {
 	[ICMP_ECHOREPLY] = {
-		.handler = icmp_discard,
+		.handler = icmp_echoreply,
 	},
 	[1] = {
 		.handler = icmp_discard,
diff -urpN linux-2.6.18-408.el5.028stab120.1/net/ipv4/ping.c linux-2.6.18-408.el5.028stab120.1-owl/net/ipv4/ping.c
--- linux-2.6.18-408.el5.028stab120.1/net/ipv4/ping.c	1970-01-01 00:00:00 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/net/ipv4/ping.c	2017-04-01 21:04:11 +0000
@@ -0,0 +1,1012 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		"Ping" sockets
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * Based on ipv4/udp.c code.
+ *
+ * Authors:	Vasiliy Kulikov / Openwall (for Linux 2.6.18),
+ *		Pavel Kankovsky (for Linux 2.4.32)
+ */
+
+#include <asm/system.h>
+#include <linux/uaccess.h>
+#include <asm/ioctls.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/inet.h>
+#include <linux/netdevice.h>
+#include <net/snmp.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <net/icmp.h>
+#include <net/protocol.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+#include <net/sock.h>
+#include <net/ping.h>
+#include <net/icmp.h>
+#include <net/udp.h>
+#include <net/route.h>
+#include <net/inet_common.h>
+#include <net/checksum.h>
+
+#ifdef CONFIG_SYSCTL
+
+/*
+ * gid_t is either uint or ushort.  We want to pass it to
+ * proc_dointvec_minmax(), so it must not be larger than MAX_INT
+ */
+#define GID_T_MAX (((gid_t)~0U) >> 1)
+
+DEFINE_SEQLOCK(ping_group_range_lock);
+static const unsigned int ip_ping_group_range_min[] = { 0, 0 };
+static const unsigned int ip_ping_group_range_max[] = { GID_T_MAX, GID_T_MAX };
+#endif
+
+struct ping_table ping_table __read_mostly;
+
+u16 ping_port_rover;
+
+static inline int ping_hashfn(struct ve_struct *net, unsigned num, unsigned mask)
+{
+	unsigned veid = VEID(net);
+	int res = (num + (veid ^ (veid >> 16))) & mask;
+	ping_debug("hash(%d) = %d\n", num, res);
+	return res;
+}
+
+static inline struct hlist_head *ping_hashslot(struct ping_table *table,
+					       struct ve_struct *net,
+					       unsigned num)
+{
+	return &table->hash[ping_hashfn(net, num, PING_HTABLE_MASK)];
+}
+
+static inline void __inet_get_ping_group_range(gid_t *data,
+					       gid_t *low, gid_t *high)
+{
+	unsigned seq;
+	do {
+		seq = read_seqbegin(&ping_group_range_lock);
+
+		*low = data[0];
+		*high = data[1];
+	} while (read_seqretry(&ping_group_range_lock, seq));
+}
+
+static void inet_get_ping_group_range_net(struct ve_struct *net,
+					  gid_t *low, gid_t *high)
+{
+	gid_t *data = net->ping_group_range;
+	__inet_get_ping_group_range(data, low, high);
+}
+
+/* Update system visible IP port range */
+static inline void set_ping_group_range(gid_t *data, gid_t range[2])
+{
+	write_seqlock(&ping_group_range_lock);
+	data[0] = range[0];
+	data[1] = range[1];
+	write_sequnlock(&ping_group_range_lock);
+}
+
+/* Validate changes from /proc interface. */
+int ipv4_ping_group_range(ctl_table *table, int write, struct file *filep,
+			  void __user *buffer,
+			  size_t *lenp, loff_t *ppos)
+{
+	int ret;
+	gid_t range[2];
+	ctl_table tmp = {
+		.data = &range,
+		.maxlen = sizeof(range),
+		.mode = table->mode,
+		.extra1 = &ip_ping_group_range_min,
+		.extra2 = &ip_ping_group_range_max,
+	};
+	struct ve_struct *env = table->owner_env;
+	if (env == NULL)
+		env = get_ve0();
+
+	inet_get_ping_group_range_net(env, range, range + 1);
+	ret = proc_dointvec_minmax(&tmp, write, filep, buffer, lenp, ppos);
+
+	if (write && ret == 0)
+		set_ping_group_range(env->ping_group_range, range);
+
+	return ret;
+}
+
+static int ping_v4_get_port(struct sock *sk, unsigned short ident)
+{
+	struct hlist_node *node;
+	struct hlist_head *hlist;
+	struct inet_sock *isk, *isk2;
+	struct sock *sk2 = NULL;
+	struct ve_struct *env;
+
+	env = sk->owner_env;
+	isk = inet_sk(sk);
+	write_lock_bh(&ping_table.lock);
+	if (ident == 0) {
+		u32 i;
+		u16 result = ping_port_rover + 1;
+
+		for (i = 0; i < (1L << 16); i++, result++) {
+			if (!result)
+				result++; /* avoid zero */
+			hlist = ping_hashslot(&ping_table, env,
+					    result);
+			sk_for_each(sk2, node, hlist) {
+				isk2 = inet_sk(sk2);
+
+				if (isk2->num == result)
+					goto next_port;
+			}
+
+			/* found */
+			ping_port_rover = ident = result;
+			break;
+next_port:
+			;
+		}
+		if (i >= (1L << 16))
+			goto fail;
+	} else {
+		hlist = ping_hashslot(&ping_table, env, ident);
+		sk_for_each(sk2, node, hlist) {
+			isk2 = inet_sk(sk2);
+
+			if ((isk2->num == ident) &&
+			    (sk2 != sk) &&
+			    (!sk2->sk_reuse || !sk->sk_reuse))
+				goto fail;
+		}
+	}
+
+	ping_debug("found port/ident = %d\n", ident);
+	isk->num = ident;
+	if (sk_unhashed(sk)) {
+		ping_debug("was not hashed\n");
+		sock_hold(sk);
+
+		sk_add_node(sk, hlist);
+		sock_prot_inc_use(sk->sk_prot);
+	}
+	write_unlock_bh(&ping_table.lock);
+	return 0;
+
+fail:
+	write_unlock_bh(&ping_table.lock);
+	return 1;
+}
+
+static void ping_v4_hash(struct sock *sk)
+{
+	ping_debug("ping_v4_hash(sk->port=%u)\n", inet_sk(sk)->num);
+	BUG(); /* "Please do not press this button again." */
+}
+
+static void ping_v4_unhash(struct sock *sk)
+{
+	struct inet_sock *isk = inet_sk(sk);
+	ping_debug("ping_v4_unhash(isk=%p,isk->num=%u)\n", isk, isk->num);
+	write_lock_bh(&ping_table.lock);
+	if (sk_hashed(sk)) {
+		sk_del_node_init(sk);
+		sock_put(sk);
+		isk->num = isk->sport = 0;
+		sock_prot_dec_use(sk->sk_prot);
+	}
+	write_unlock_bh(&ping_table.lock);
+}
+
+static int ping_init_sock(struct sock *sk)
+{
+	struct group_info *group_info = current->group_info;
+	int count = group_info->ngroups;
+	struct ve_struct *net = sk->owner_env;
+	int i,j;
+
+	gid_t group = current->egid;
+	gid_t range[2];
+
+	inet_get_ping_group_range_net(net, range, range+1);
+	if (range[0] <= group && group <= range[1])
+		return 0;
+
+
+	for (i = 0; i < group_info->nblocks; i++) {
+		int cp_count = min(NGROUPS_PER_BLOCK, count);
+
+		for (j = 0; j < cp_count; j++) {
+			group = group_info->blocks[i][j];
+			if (range[0] <= group && group <= range[1])
+				return 0;
+		}
+
+		count -= cp_count;
+	}
+
+	return -EACCES;
+}
+
+struct sock *ping_v4_lookup(u32 saddr, u32 daddr, u16 ident, int dif)
+{
+	struct ve_struct *net = get_exec_env();
+	struct hlist_head *hslot = ping_hashslot(&ping_table, net, ident);
+	struct sock *sk = NULL;
+	struct inet_sock *isk;
+	struct hlist_node *hnode;
+
+	ping_debug("try to find: num = %d, daddr = %ld, dif = %d\n",
+			 (int)ident, (unsigned long)daddr, dif);
+	read_lock_bh(&ping_table.lock);
+
+	sk_for_each(sk, hnode, hslot) {
+		isk = inet_sk(sk);
+
+		ping_debug("found: %p: num = %d, daddr = %ld, dif = %d\n", sk,
+			 (int)isk->num, (unsigned long)isk->rcv_saddr,
+			 sk->sk_bound_dev_if);
+
+		ping_debug("iterate\n");
+		if (isk->num != ident)
+			continue;
+		if (isk->rcv_saddr && isk->rcv_saddr != daddr)
+			continue;
+		if (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif)
+			continue;
+
+		sock_hold(sk);
+		goto exit;
+	}
+
+	sk = NULL;
+exit:
+	read_unlock_bh(&ping_table.lock);
+
+	return sk;
+}
+
+static void ping_close(struct sock *sk, long timeout)
+{
+	ping_debug("ping_close(sk=%p,sk->num=%u)\n",
+		inet_sk(sk), inet_sk(sk)->num);
+	ping_debug("isk->refcnt = %d\n", sk->sk_refcnt.counter);
+
+	sk_common_release(sk);
+}
+
+/*
+ * We need our own bind because there are no privileged id's == local ports.
+ * Moreover, we don't allow binding to multi- and broadcast addresses.
+ */
+
+static int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
+{
+	struct sockaddr_in *addr = (struct sockaddr_in *)uaddr;
+	struct inet_sock *isk = inet_sk(sk);
+	unsigned short snum;
+	int chk_addr_ret;
+	int err;
+
+	if (addr_len < sizeof(struct sockaddr_in))
+		return -EINVAL;
+
+	ping_debug("ping_v4_bind(sk=%p,sa_addr=%08x,sa_port=%d)\n",
+		sk, addr->sin_addr.s_addr, ntohs(addr->sin_port));
+
+	chk_addr_ret = inet_addr_type(addr->sin_addr.s_addr);
+	if (addr->sin_addr.s_addr == INADDR_ANY)
+		chk_addr_ret = RTN_LOCAL;
+
+	if ((sysctl_ip_nonlocal_bind == 0 &&
+	    isk->freebind == 0 && chk_addr_ret != RTN_LOCAL) ||
+	    chk_addr_ret == RTN_MULTICAST ||
+	    chk_addr_ret == RTN_BROADCAST)
+		return -EADDRNOTAVAIL;
+
+	lock_sock(sk);
+
+	err = -EINVAL;
+	if (isk->num != 0)
+		goto out;
+
+	err = -EADDRINUSE;
+	isk->rcv_saddr = isk->saddr = addr->sin_addr.s_addr;
+	snum = ntohs(addr->sin_port);
+	if (ping_v4_get_port(sk, snum) != 0) {
+		isk->saddr = isk->rcv_saddr = 0;
+		goto out;
+	}
+
+	ping_debug("after bind(): num = %d, daddr = %ld, dif = %d\n",
+		(int)isk->num,
+		(unsigned long) isk->rcv_saddr,
+		(int)sk->sk_bound_dev_if);
+
+	err = 0;
+	if (isk->rcv_saddr)
+		sk->sk_userlocks |= SOCK_BINDADDR_LOCK;
+	if (snum)
+		sk->sk_userlocks |= SOCK_BINDPORT_LOCK;
+	isk->sport = htons(isk->num);
+	isk->daddr = 0;
+	isk->dport = 0;
+	sk_dst_reset(sk);
+out:
+	release_sock(sk);
+	ping_debug("ping_v4_bind -> %d\n", err);
+	return err;
+}
+
+/*
+ * Is this a supported type of ICMP message?
+ */
+
+static inline int ping_supported(int type, int code)
+{
+	if (type == ICMP_ECHO && code == 0)
+		return 1;
+	return 0;
+}
+
+/*
+ * This routine is called by the ICMP module when it gets some
+ * sort of error condition.
+ */
+
+static int ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb);
+
+void ping_err(struct sk_buff *skb, u32 info)
+{
+	struct iphdr *iph = (struct iphdr *)skb->data;
+	struct icmphdr *icmph = (struct icmphdr *)(skb->data+(iph->ihl<<2));
+	struct inet_sock *inet_sock;
+	int type = icmph->type;
+	int code = icmph->code;
+	struct sock *sk;
+	int harderr;
+	int err;
+
+	/* We assume the packet has already been checked by icmp_unreach */
+
+	if (!ping_supported(icmph->type, icmph->code))
+		return;
+
+	ping_debug("ping_err(type=%04x,code=%04x,id=%04x,seq=%04x)\n", type,
+		code, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));
+
+	sk = ping_v4_lookup(iph->daddr, iph->saddr,
+			    ntohs(icmph->un.echo.id), skb->dev->ifindex);
+	if (sk == NULL) {
+		ICMP_INC_STATS_BH(ICMP_MIB_INERRORS);
+		ping_debug("no socket, dropping\n");
+		return;	/* No socket for error */
+	}
+	ping_debug("err on socket %p\n", sk);
+
+	err = 0;
+	harderr = 0;
+	inet_sock = inet_sk(sk);
+
+	switch (type) {
+	default:
+	case ICMP_TIME_EXCEEDED:
+		err = EHOSTUNREACH;
+		break;
+	case ICMP_SOURCE_QUENCH:
+		/* This is not a real error but ping wants to see it.
+		 * Report it with some fake errno. */
+		err = EREMOTEIO;
+		break;
+	case ICMP_PARAMETERPROB:
+		err = EPROTO;
+		harderr = 1;
+		break;
+	case ICMP_DEST_UNREACH:
+		if (code == ICMP_FRAG_NEEDED) { /* Path MTU discovery */
+			if (inet_sock->pmtudisc != IP_PMTUDISC_DONT) {
+				err = EMSGSIZE;
+				harderr = 1;
+				break;
+			}
+			goto out;
+		}
+		err = EHOSTUNREACH;
+		if (code <= NR_ICMP_UNREACH) {
+			harderr = icmp_err_convert[code].fatal;
+			err = icmp_err_convert[code].errno;
+		}
+		break;
+	case ICMP_REDIRECT:
+		/* See ICMP_SOURCE_QUENCH */
+		err = EREMOTEIO;
+		break;
+	}
+
+	/*
+	 *      RFC1122: OK.  Passes ICMP errors back to application, as per
+	 *	4.1.3.3.
+	 */
+	if (!inet_sock->recverr) {
+		if (!harderr || sk->sk_state != TCP_ESTABLISHED)
+			goto out;
+	} else {
+		ip_icmp_error(sk, skb, err, 0 /* no remote port */,
+			 info, (u8 *)icmph);
+	}
+	sk->sk_err = err;
+	sk->sk_error_report(sk);
+out:
+	sock_put(sk);
+}
+
+/*
+ *	Copy and checksum an ICMP Echo packet from user space into a buffer.
+ */
+
+struct pingfakehdr {
+	struct icmphdr icmph;
+	struct iovec *iov;
+	u32 wcheck;
+};
+
+static int ping_getfrag(void *from, char * to,
+			int offset, int fraglen, int odd, struct sk_buff *skb)
+{
+	struct pingfakehdr *pfh = (struct pingfakehdr *)from;
+
+	if (offset == 0) {
+		if (fraglen < sizeof(struct icmphdr))
+			BUG();
+		if (csum_partial_copy_fromiovecend(to + sizeof(struct icmphdr),
+			    pfh->iov, 0, fraglen - sizeof(struct icmphdr),
+			    &pfh->wcheck))
+			return -EFAULT;
+
+		return 0;
+	}
+	if (offset < sizeof(struct icmphdr))
+		BUG();
+	if (csum_partial_copy_fromiovecend
+			(to, pfh->iov, offset - sizeof(struct icmphdr),
+			 fraglen, &pfh->wcheck))
+		return -EFAULT;
+	return 0;
+}
+
+static int ping_push_pending_frames(struct sock *sk, struct pingfakehdr *pfh)
+{
+	struct sk_buff *skb = skb_peek(&sk->sk_write_queue);
+
+	pfh->wcheck = csum_partial((char *)&pfh->icmph,
+		sizeof(struct icmphdr), pfh->wcheck);
+	pfh->icmph.checksum = csum_fold(pfh->wcheck);
+	memcpy(skb->h.icmph, &pfh->icmph, sizeof(struct icmphdr));
+	skb->ip_summed = CHECKSUM_NONE;
+
+	return ip_push_pending_frames(sk);
+}
+
+int ping_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+		 size_t len)
+{
+	struct inet_sock *isk = inet_sk(sk);
+	struct ipcm_cookie ipc;
+	struct icmphdr user_icmph;
+	struct pingfakehdr pfh;
+	struct rtable *rt = NULL;
+	int free = 0;
+	u32 saddr, daddr;
+	u8  tos;
+	int err;
+
+	ping_debug("ping_sendmsg(sk=%p,sk->num=%u)\n", isk, isk->num);
+
+
+	if (len > 0xFFFF)
+		return -EMSGSIZE;
+
+	/*
+	 *	Check the flags.
+	 */
+
+	/* Mirror BSD error message compatibility */
+	if (msg->msg_flags & MSG_OOB)
+		return -EOPNOTSUPP;
+
+	/*
+	 *	Fetch the ICMP header provided by the userland.
+	 *	iovec is modified!
+	 */
+
+	if (memcpy_fromiovec((u8 *)&user_icmph, msg->msg_iov,
+			     sizeof(struct icmphdr)))
+		return -EFAULT;
+	if (!ping_supported(user_icmph.type, user_icmph.code))
+		return -EINVAL;
+
+	/*
+	 *	Get and verify the address.
+	 */
+
+	if (msg->msg_name) {
+		struct sockaddr_in *usin = (struct sockaddr_in *)msg->msg_name;
+		if (msg->msg_namelen < sizeof(*usin))
+			return -EINVAL;
+		if (usin->sin_family != AF_INET)
+			return -EINVAL;
+		daddr = usin->sin_addr.s_addr;
+		/* no remote port */
+	} else {
+		if (sk->sk_state != TCP_ESTABLISHED)
+			return -EDESTADDRREQ;
+		daddr = isk->daddr;
+		/* no remote port */
+	}
+
+	ipc.addr = isk->saddr;
+	ipc.opt = NULL;
+	ipc.oif = sk->sk_bound_dev_if;
+
+	if (msg->msg_controllen) {
+		err = ip_cmsg_send(msg, &ipc);
+		if (err)
+			return err;
+		if (ipc.opt)
+			free = 1;
+	}
+	if (!ipc.opt)
+		ipc.opt = isk->opt;
+
+	saddr = ipc.addr;
+	ipc.addr = daddr;
+
+	if (ipc.opt && ipc.opt->srr) {
+		if (!daddr)
+			return -EINVAL;
+		daddr = ipc.opt->faddr;
+	}
+	tos = RT_TOS(isk->tos);
+	if (sock_flag(sk, SOCK_LOCALROUTE) ||
+	    (msg->msg_flags&MSG_DONTROUTE) ||
+	    (ipc.opt && ipc.opt->is_strictroute)) {
+		tos |= RTO_ONLINK;
+	}
+
+	if (MULTICAST(daddr)) {
+		if (!ipc.oif)
+			ipc.oif = isk->mc_index;
+		if (!saddr)
+			saddr = isk->mc_addr;
+	}
+
+	{
+		struct flowi fl = { .oif = ipc.oif,
+				    .nl_u = { .ip4_u = {
+						.daddr = daddr,
+						.saddr = saddr,
+						.tos = tos } },
+				    .proto = IPPROTO_ICMP,
+		};
+
+		security_sk_classify_flow(sk, &fl);
+		err = ip_route_output_flow(&rt, &fl, sk, 1);
+		if (err) {
+			if (err == -ENETUNREACH)
+				IP_INC_STATS_BH(IPSTATS_MIB_OUTNOROUTES);
+			goto out;
+		}
+
+		err = -EACCES;
+		if ((rt->rt_flags & RTCF_BROADCAST) &&
+		    !sock_flag(sk, SOCK_BROADCAST))
+			goto out;
+	}
+
+	if (msg->msg_flags & MSG_CONFIRM)
+		goto do_confirm;
+back_from_confirm:
+
+	if (!ipc.addr)
+		ipc.addr = rt->rt_dst;
+
+	lock_sock(sk);
+
+	pfh.icmph.type = user_icmph.type; /* already checked */
+	pfh.icmph.code = user_icmph.code; /* dtto */
+	pfh.icmph.checksum = 0;
+	pfh.icmph.un.echo.id = isk->sport;
+	pfh.icmph.un.echo.sequence = user_icmph.un.echo.sequence;
+	pfh.iov = msg->msg_iov;
+	pfh.wcheck = 0;
+
+	err = ip_append_data(sk, ping_getfrag, &pfh, len,
+			0, &ipc, rt,
+			msg->msg_flags);
+	if (err)
+		ip_flush_pending_frames(sk);
+	else
+		err = ping_push_pending_frames(sk, &pfh);
+	release_sock(sk);
+
+out:
+	ip_rt_put(rt);
+	if (free)
+		kfree(ipc.opt);
+	if (!err) {
+		icmp_out_count(user_icmph.type);
+		return len;
+	}
+	return err;
+
+do_confirm:
+	dst_confirm(&rt->u.dst);
+	if (!(msg->msg_flags & MSG_PROBE) || len)
+		goto back_from_confirm;
+	err = 0;
+	goto out;
+}
+
+/*
+ *	IOCTL requests applicable to the UDP^H^H^HICMP protocol
+ */
+
+int ping_ioctl(struct sock *sk, int cmd, unsigned long arg)
+{
+	ping_debug("ping_ioctl(sk=%p,sk->num=%u,cmd=%d,arg=%lu)\n",
+		inet_sk(sk), inet_sk(sk)->num, cmd, arg);
+	switch (cmd) {
+	case SIOCOUTQ:
+	case SIOCINQ:
+		return udp_ioctl(sk, cmd, arg);
+	default:
+		return -ENOIOCTLCMD;
+	}
+}
+
+int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+		 size_t len, int noblock, int flags, int *addr_len)
+{
+	struct inet_sock *isk = inet_sk(sk);
+	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
+	struct sk_buff *skb;
+	int copied, err;
+
+	ping_debug("ping_recvmsg(sk=%p,sk->num=%u)\n", isk, isk->num);
+
+	if (flags & MSG_OOB)
+		goto out;
+
+	if (addr_len)
+		*addr_len = sizeof(*sin);
+
+	if (flags & MSG_ERRQUEUE)
+		return ip_recv_error(sk, msg, len, addr_len);
+
+	skb = skb_recv_datagram(sk, flags, noblock, &err);
+	if (!skb)
+		goto out;
+
+	copied = skb->len;
+	if (copied > len) {
+		msg->msg_flags |= MSG_TRUNC;
+		copied = len;
+	}
+
+	/* Don't bother checking the checksum */
+	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
+	if (err)
+		goto done;
+
+	sock_recv_timestamp(msg, sk, skb);
+
+	/* Copy the address. */
+	if (sin) {
+		sin->sin_family = AF_INET;
+		sin->sin_port = 0 /* skb->h.uh->source */;
+		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
+		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+	}
+	if (isk->cmsg_flags)
+		ip_cmsg_recv(msg, skb);
+	err = copied;
+
+done:
+	skb_free_datagram(sk, skb);
+out:
+	ping_debug("ping_recvmsg -> %d\n", err);
+	return err;
+}
+
+static int ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
+{
+	ping_debug("ping_queue_rcv_skb(sk=%p,sk->num=%d,skb=%p)\n",
+		inet_sk(sk), inet_sk(sk)->num, skb);
+	if (sock_queue_rcv_skb(sk, skb) < 0) {
+		ICMP_INC_STATS_BH(ICMP_MIB_INERRORS);
+		kfree_skb(skb);
+		ping_debug("ping_queue_rcv_skb -> failed\n");
+		return -1;
+	}
+	return 0;
+}
+
+
+/*
+ *	All we need to do is get the socket.
+ */
+
+void ping_rcv(struct sk_buff *skb)
+{
+	struct sock *sk;
+	struct iphdr *iph = ip_hdr(skb);
+	struct icmphdr *icmph = icmp_hdr(skb);
+	u32 saddr = iph->saddr;
+	u32 daddr = iph->daddr;
+
+	/* We assume the packet has already been checked by icmp_rcv */
+
+	ping_debug("ping_rcv(skb=%p,id=%04x,seq=%04x)\n",
+		skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));
+
+	/* Push ICMP header back */
+	skb_push(skb, skb->data - (u8 *)icmph);
+
+	sk = ping_v4_lookup(saddr, daddr, ntohs(icmph->un.echo.id),
+			    skb->dev->ifindex);
+	if (sk != NULL) {
+		ping_debug("rcv on socket %p\n", sk);
+		ping_queue_rcv_skb(sk, skb_get(skb));
+		sock_put(sk);
+		return;
+	}
+	ping_debug("no socket, dropping\n");
+
+	/* We're called from icmp_rcv(). kfree_skb() is done there. */
+}
+
+struct proto ping_prot = {
+	.name =		"PING",
+	.owner =	THIS_MODULE,
+	.init =		ping_init_sock,
+	.close =	ping_close,
+	.connect =	ip4_datagram_connect,
+	.disconnect =	udp_disconnect,
+	.ioctl =	ping_ioctl,
+	.setsockopt =	ip_setsockopt,
+	.getsockopt =	ip_getsockopt,
+	.sendmsg =	ping_sendmsg,
+	.recvmsg =	ping_recvmsg,
+	.bind =		ping_bind,
+	.backlog_rcv =	ping_queue_rcv_skb,
+	.hash =		ping_v4_hash,
+	.unhash =	ping_v4_unhash,
+	.get_port =	ping_v4_get_port,
+	.obj_size =	sizeof(struct inet_sock),
+};
+EXPORT_SYMBOL(ping_prot);
+
+#ifdef CONFIG_PROC_FS
+
+static struct sock *ping_get_first(struct seq_file *seq, int start)
+{
+	struct sock *sk;
+	struct ping_iter_state *state = seq->private;
+	struct ve_struct *net = get_exec_env();
+
+	for (state->bucket = start; state->bucket < PING_HTABLE_SIZE;
+	     ++state->bucket) {
+		struct hlist_node *node;
+		struct hlist_head *hslot = &ping_table.hash[state->bucket];
+
+		sk_for_each(sk, node, hslot) {
+			if (ve_accessible(sk->owner_env, net))
+				goto found;
+		}
+	}
+	sk = NULL;
+found:
+	return sk;
+}
+
+static struct sock *ping_get_next(struct seq_file *seq, struct sock *sk)
+{
+	struct ping_iter_state *state = seq->private;
+
+	do {
+		sk = sk_next(sk);
+		if (!sk)
+			break;
+		if (ve_accessible(sk->owner_env, get_exec_env()))
+			break;
+	} while (1);
+
+	if (!sk)
+		return ping_get_first(seq, state->bucket + 1);
+	return sk;
+}
+
+static struct sock *ping_get_idx(struct seq_file *seq, loff_t pos)
+{
+	struct sock *sk = ping_get_first(seq, 0);
+
+	if (sk)
+		while (pos && (sk = ping_get_next(seq, sk)) != NULL)
+			--pos;
+	return pos ? NULL : sk;
+}
+
+static void *ping_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	struct ping_iter_state *state = seq->private;
+	state->bucket = 0;
+
+	read_lock_bh(&ping_table.lock);
+
+	return *pos ? ping_get_idx(seq, *pos-1) : SEQ_START_TOKEN;
+}
+
+static void *ping_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	struct sock *sk;
+
+	if (v == SEQ_START_TOKEN)
+		sk = ping_get_idx(seq, 0);
+	else
+		sk = ping_get_next(seq, v);
+
+	++*pos;
+	return sk;
+}
+
+static void ping_seq_stop(struct seq_file *seq, void *v)
+{
+	read_unlock_bh(&ping_table.lock);
+}
+
+static void ping_format_sock(struct sock *sp, struct seq_file *f,
+		int bucket, int *len)
+{
+	struct inet_sock *inet = inet_sk(sp);
+	__be32 dest = inet->daddr;
+	__be32 src = inet->rcv_saddr;
+	__u16 destp = ntohs(inet->dport);
+	__u16 srcp = ntohs(inet->sport);
+
+	seq_printf(f, "%5d: %08X:%04X %08X:%04X"
+		" %02X %08X:%08X %02X:%08lX %08X %5d %8d %lu %d %p %n",
+		bucket, src, srcp, dest, destp, sp->sk_state,
+		atomic_read(&sp->sk_wmem_alloc),
+		atomic_read(&sp->sk_rmem_alloc),
+		0, 0L, 0, sock_i_uid(sp), 0, sock_i_ino(sp),
+		atomic_read(&sp->sk_refcnt), sp,
+		len);
+}
+
+static int ping_seq_show(struct seq_file *seq, void *v)
+{
+	if (v == SEQ_START_TOKEN)
+		seq_printf(seq, "%-127s\n",
+			   "  sl  local_address rem_address   st tx_queue "
+			   "rx_queue tr tm->when retrnsmt   uid  timeout "
+			   "inode ref pointer drops");
+	else {
+		struct ping_iter_state *state = seq->private;
+		int len;
+
+		ping_format_sock(v, seq, state->bucket, &len);
+		seq_printf(seq, "%*s\n", 127 - len, "");
+	}
+	return 0;
+}
+
+static struct seq_operations ping_seq_ops = {
+	.show		= ping_seq_show,
+	.start		= ping_seq_start,
+	.next		= ping_seq_next,
+	.stop		= ping_seq_stop,
+};
+
+static int ping_seq_open(struct inode *inode, struct file *file)
+{
+	int rc = -ENOMEM;
+	struct seq_file *seq;
+	struct ping_iter_state *s = kzalloc(sizeof(*s), GFP_KERNEL);
+
+	if (!s)
+		goto out;
+
+	rc = seq_open(file, &ping_seq_ops);
+	if (rc)
+		goto out_kfree;
+
+	seq	     = file->private_data;
+	seq->private = s;
+out:
+	return rc;
+out_kfree:
+	kfree(s);
+	goto out;
+}
+
+static struct file_operations ping_seq_fops = {
+	.owner		= THIS_MODULE,
+	.open		= ping_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release_private,
+};
+
+static const char ping_proc_name[] = "net/icmp";
+
+static int ping_proc_register(void)
+{
+	struct proc_dir_entry *p;
+	int rc = 0;
+
+	p = proc_glob_fops_create(ping_proc_name, S_IRUGO,
+			     &ping_seq_fops);
+	if (!p)
+		rc = -ENOMEM;
+	return rc;
+}
+
+static void ping_proc_unregister(void)
+{
+	remove_proc_glob_entry(ping_proc_name, NULL);
+}
+
+static int ping_proc_init_net(void)
+{
+	return ping_proc_register();
+}
+
+static void ping_proc_exit_net(void)
+{
+	ping_proc_unregister();
+}
+
+#if 0
+static struct pernet_operations ping_net_ops = {
+	.init = ping_proc_init_net,
+	.exit = ping_proc_exit_net,
+};
+#endif
+
+int __init ping_proc_init(void)
+{
+	return ping_proc_init_net();
+}
+
+void ping_proc_exit(void)
+{
+	ping_proc_exit_net();
+}
+
+#endif
+
+void __init ping_init(void)
+{
+	int i;
+
+	for (i = 0; i < PING_HTABLE_SIZE; i++)
+		INIT_HLIST_HEAD(&ping_table.hash[i]);
+	rwlock_init(&ping_table.lock);
+}
diff -urpN linux-2.6.18-408.el5.028stab120.1/net/ipv4/sysctl_net_ipv4.c linux-2.6.18-408.el5.028stab120.1-owl/net/ipv4/sysctl_net_ipv4.c
--- linux-2.6.18-408.el5.028stab120.1/net/ipv4/sysctl_net_ipv4.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/net/ipv4/sysctl_net_ipv4.c	2016-08-23 15:41:27 +0000
@@ -16,6 +16,9 @@
 #include <net/snmp.h>
 #include <net/icmp.h>
 #include <net/ip.h>
+#ifdef CONFIG_IP_PING
+#include <net/ping.h>
+#endif
 #include <net/route.h>
 #include <net/tcp.h>
 #include <net/udp.h>
@@ -251,6 +254,15 @@ ctl_table ipv4_table[] = {
 		.proc_handler	= &ipv4_sysctl_forward,
 		.strategy	= &ipv4_sysctl_forward_strategy
 	},
+#ifdef CONFIG_IP_PING
+	{
+		.ctl_name	= NET_PING_GROUP_RANGE,
+		.procname	= "ping_group_range",
+		.maxlen		= sizeof(int)*2,
+		.mode		= 0644,
+		.proc_handler	= &ipv4_ping_group_range,
+	},
+#endif
         {
 		.ctl_name	= NET_IPV4_DEFAULT_TTL,
 		.procname	= "ip_default_ttl",
diff -urpN linux-2.6.18-408.el5.028stab120.1/net/llc/af_llc.c linux-2.6.18-408.el5.028stab120.1-owl/net/llc/af_llc.c
--- linux-2.6.18-408.el5.028stab120.1/net/llc/af_llc.c	2016-01-25 08:11:40 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/net/llc/af_llc.c	2016-08-23 15:41:27 +0000
@@ -155,6 +155,9 @@ static int llc_ui_create(struct socket *
 	struct sock *sk;
 	int rc = -ESOCKTNOSUPPORT;
 
+	if (!capable(CAP_NET_RAW))
+		return -EPERM;
+
 	if (likely(sock->type == SOCK_DGRAM || sock->type == SOCK_STREAM)) {
 		rc = -ENOMEM;
 		sk = llc_sk_alloc(PF_LLC, GFP_KERNEL, &llc_proto);
@@ -977,6 +980,7 @@ static int llc_ui_setsockopt(struct sock
 	struct llc_sock *llc = llc_sk(sk);
 	int rc = -EINVAL, opt;
 
+	memset(&sllc, 0, sizeof(sllc));
 	lock_sock(sk);
 	if (unlikely(level != SOL_LLC || optlen != sizeof(int)))
 		goto out;
diff -urpN linux-2.6.18-408.el5.028stab120.1/net/socket.c linux-2.6.18-408.el5.028stab120.1-owl/net/socket.c
--- linux-2.6.18-408.el5.028stab120.1/net/socket.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/net/socket.c	2017-01-25 09:21:30 +0000
@@ -1190,6 +1190,7 @@ int vz_security_protocol_check(int proto
 	case  IPPROTO_TCP:
 	case  IPPROTO_UDP:
 	case  IPPROTO_RAW:
+	case  IPPROTO_ICMP:
 		break;
 	default:
 		return -EAFNOSUPPORT;
@@ -2198,31 +2199,31 @@ int __sys_recvmmsg(int fd, struct mmsghd
 			break;
 	}
 
-out_put:
-	fput_light(sock->file, fput_needed);
-
 	if (err == 0)
-		return datagrams;
+		goto out_put;
+
+	if (datagrams == 0) {
+		datagrams = err;
+		goto out_put;
+	}
 
-	if (datagrams != 0) {
+	/*
+	 * We may return less entries than requested (vlen) if the
+	 * sock is non block and there aren't enough datagrams...
+	 */
+	if (err != -EAGAIN) {
 		/*
-		 * We may return less entries than requested (vlen) if the
-		 * sock is non block and there aren't enough datagrams...
+		 * ... or  if recvmsg returns an error after we
+		 * received some datagrams, where we record the
+		 * error to return on the next call or if the
+		 * app asks about it using getsockopt(SO_ERROR).
 		 */
-		if (err != -EAGAIN) {
-			/*
-			 * ... or  if recvmsg returns an error after we
-			 * received some datagrams, where we record the
-			 * error to return on the next call or if the
-			 * app asks about it using getsockopt(SO_ERROR).
-			 */
-			sock->sk->sk_err = -err;
-		}
-
-		return datagrams;
+		sock->sk->sk_err = -err;
 	}
+out_put:
+	fput_light(sock->file, fput_needed);
 
-	return err;
+	return datagrams;
 }
 
 asmlinkage long sys_recvmmsg(int fd, struct mmsghdr __user *mmsg,
diff -urpN linux-2.6.18-408.el5.028stab120.1/scripts/kconfig/lxdialog/check-lxdialog.sh linux-2.6.18-408.el5.028stab120.1-owl/scripts/kconfig/lxdialog/check-lxdialog.sh
--- linux-2.6.18-408.el5.028stab120.1/scripts/kconfig/lxdialog/check-lxdialog.sh	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/scripts/kconfig/lxdialog/check-lxdialog.sh	2012-08-18 16:53:51 +0000
@@ -11,7 +11,7 @@ ldflags()
 	fi
 	$cc -print-file-name=libncurses.so | grep -q /
 	if [ $? -eq 0 ]; then
-		echo '-lncurses'
+		echo '-lncurses -ltinfo'
 		exit
 	fi
 	$cc -print-file-name=libcurses.so | grep -q /
diff -urpN linux-2.6.18-408.el5.028stab120.1/scripts/mkcompile_h linux-2.6.18-408.el5.028stab120.1-owl/scripts/mkcompile_h
--- linux-2.6.18-408.el5.028stab120.1/scripts/mkcompile_h	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/scripts/mkcompile_h	2011-07-27 04:03:04 +0000
@@ -47,17 +47,9 @@ UTS_TRUNCATE="sed -e s/\(.\{1,$UTS_LEN\}
   echo \#define UTS_VERSION \"`echo $UTS_VERSION | $UTS_TRUNCATE`\"
 
   echo \#define LINUX_COMPILE_TIME \"`LC_ALL=C LANG=C date +%T`\"
-  echo \#define LINUX_COMPILE_BY \"`whoami`\"
-  echo \#define LINUX_COMPILE_HOST \"`hostname | $UTS_TRUNCATE`\"
-
-  if [ -x /bin/dnsdomainname ]; then
-    echo \#define LINUX_COMPILE_DOMAIN \"`dnsdomainname | $UTS_TRUNCATE`\"
-  elif [ -x /bin/domainname ]; then
-    echo \#define LINUX_COMPILE_DOMAIN \"`domainname | $UTS_TRUNCATE`\"
-  else
-    echo \#define LINUX_COMPILE_DOMAIN
-  fi
-
+  echo \#define LINUX_COMPILE_BY \"sources\"
+  echo \#define LINUX_COMPILE_HOST \"${ARCH}.example.org\"
+  echo \#define LINUX_COMPILE_DOMAIN \"\"
   echo \#define LINUX_COMPILER \"`$CC -v 2>&1 | tail -n 1`\"
 ) > .tmpcompile
 
diff -urpN linux-2.6.18-408.el5.028stab120.1/security/min_addr.c linux-2.6.18-408.el5.028stab120.1-owl/security/min_addr.c
--- linux-2.6.18-408.el5.028stab120.1/security/min_addr.c	2016-01-25 08:11:41 +0000
+++ linux-2.6.18-408.el5.028stab120.1-owl/security/min_addr.c	2016-08-23 15:41:27 +0000
@@ -5,9 +5,9 @@
 #include <linux/sysctl.h>
 
 /* amount of vm to protect from userspace access by both DAC and the LSM*/
-unsigned long mmap_min_addr;
+unsigned long mmap_min_addr = 98304;
 /* amount of vm to protect from userspace using CAP_SYS_RAWIO (DAC) */
-unsigned long dac_mmap_min_addr = 4096;
+unsigned long dac_mmap_min_addr = 98304;
 /* amount of vm to protect from userspace using the LSM = CONFIG_LSM_MMAP_MIN_ADDR */
 
 /*

diff -uNrp linux-2.6.18.orig/Makefile linux-2.6.18/Makefile
--- linux-2.6.18.orig/Makefile	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/Makefile	2011-03-04 17:54:13 +0000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 18
-EXTRAVERSION = -238.5.1.el5.028stab085.1
+EXTRAVERSION = -238.5.1.el5.028stab085.1.owl1
 RHEL_MAJOR = 5
 RHEL_MINOR = 6
 NAME=Avast! A bilge rat!
diff -uNrp linux-2.6.18.orig/arch/i386/kernel/cpu/amd.c linux-2.6.18/arch/i386/kernel/cpu/amd.c
--- linux-2.6.18.orig/arch/i386/kernel/cpu/amd.c	2011-03-04 01:59:41 +0000
+++ linux-2.6.18/arch/i386/kernel/cpu/amd.c	2011-03-04 17:48:35 +0000
@@ -45,11 +45,14 @@ static void __cpuinit amd_fixup_dcm(stru
 	if (cpu_has(c, X86_FEATURE_AMD_DCM))
 		return;
 
+#if 0
+/* early_is_k8_nb() is only defined under arch/x86_64/ */
 	/* proceed only if there is a valid AMD northbridge
 	 * (not in virtualized environments!)
 	 */
 	if (!early_is_k8_nb(read_pci_config(0, 24, 3, 0x00)))
 		return;
+#endif
 
 	rdmsrl(0xc001100c, value);
 
diff -uNrp linux-2.6.18.orig/arch/i386/kernel/cpu/intel_cacheinfo.c linux-2.6.18/arch/i386/kernel/cpu/intel_cacheinfo.c
--- linux-2.6.18.orig/arch/i386/kernel/cpu/intel_cacheinfo.c	2011-03-04 01:59:45 +0000
+++ linux-2.6.18/arch/i386/kernel/cpu/intel_cacheinfo.c	2011-03-04 17:48:35 +0000
@@ -47,10 +47,12 @@ static void wbinvd_on_cpu(int cpu)
 	smp_call_function_single(cpu, __wbinvd, NULL, 0, 1);
 }
 
+#if 0
 static int wbinvd_on_all_cpus(void)
 {
 	return on_each_cpu(__wbinvd, NULL, 0, 1);
 }
+#endif
 
 /* from arch/x86/kernel/cpu/amd.c upstream */
 static int amd_get_nb_id(int cpu)
@@ -335,9 +337,12 @@ amd_check_l3_disable(int index, struct _
 	    boot_cpu_data.x86_mask < 0x1)
 		return;
 
+#if 0
+/* num_k8_northbridges is only defined under arch/x86_64/ */
 	/* not in virtualized environments */
 	if (num_k8_northbridges == 0)
 		return;
+#endif
 
 	this_leaf->can_disable = true;
 	this_leaf->l3_indices  = amd_calc_l3_indices();
diff -uNrp linux-2.6.18.orig/arch/x86_64/Kconfig linux-2.6.18/arch/x86_64/Kconfig
--- linux-2.6.18.orig/arch/x86_64/Kconfig	2011-03-04 01:59:45 +0000
+++ linux-2.6.18/arch/x86_64/Kconfig	2011-03-04 17:48:35 +0000
@@ -476,6 +476,7 @@ config IOMMU
 	default y
 	select SWIOTLB
 	select AGP
+	select IOMMU_HELPER
 	depends on PCI && !X86_64_XEN
 	help
 	  Support for full DMA access of devices with 32bit memory access only
diff -uNrp linux-2.6.18.orig/drivers/ata/Kconfig linux-2.6.18/drivers/ata/Kconfig
--- linux-2.6.18.orig/drivers/ata/Kconfig	2011-03-04 01:59:35 +0000
+++ linux-2.6.18/drivers/ata/Kconfig	2011-03-04 17:48:35 +0000
@@ -447,8 +447,8 @@ config PATA_MARVELL
 	help
 	  This option enables limited support for the Marvell 88SE61xx ATA
 	  controllers. If you wish to use only the SATA ports then select
-	  the AHCI driver alone. If you wish to the use the PATA port or
-	  both SATA and PATA include this driver.
+	  the AHCI driver alone. If you wish to use the PATA port or both
+	  SATA and PATA include this driver.
 
 	  If unsure, say N.
 
diff -uNrp linux-2.6.18.orig/drivers/ata/ahci.c linux-2.6.18/drivers/ata/ahci.c
--- linux-2.6.18.orig/drivers/ata/ahci.c	2011-03-04 01:59:43 +0000
+++ linux-2.6.18/drivers/ata/ahci.c	2011-03-04 17:48:35 +0000
@@ -791,7 +791,7 @@ static void ahci_save_initial_config(str
 			   port_map,
 			   port_map & mv);
 		dev_printk(KERN_ERR, &pdev->dev,
-			  "Disabling your PATA port. Use the boot option 'ahci.marvell_enable=0' to avoid this.\n");
+			  "Disabling your PATA port on the Marvell SATA/PATA controller, which is unsupported by the AHCI driver. Use the boot option 'ahci.marvell_enable=0' to avoid this and let the likely slower Marvell PATA driver take over, supporting both SATA and PATA ports.\n");
 
 		port_map &= mv;
 	}
@@ -2900,8 +2900,11 @@ static int ahci_init_one(struct pci_dev 
 	/* The AHCI driver can only drive the SATA ports, the PATA driver
 	   can drive them all so if both drivers are selected make sure
 	   AHCI stays out of the way */
-	if (pdev->vendor == PCI_VENDOR_ID_MARVELL && !marvell_enable)
+	if (pdev->vendor == PCI_VENDOR_ID_MARVELL && !marvell_enable) {
+		dev_printk(KERN_ERR, &pdev->dev,
+			  "Skipping the Marvell SATA/PATA controller in order to let the Marvell PATA driver take over. Use the boot option 'ahci.marvell_enable=1' to avoid this, likely gaining a bit of performance but losing support for your PATA port.\n");
 		return -ENODEV;
+	}
 
 	/* acquire resources */
 	rc = pcim_enable_device(pdev);
diff -uNrp linux-2.6.18.orig/drivers/block/cciss.c linux-2.6.18/drivers/block/cciss.c
--- linux-2.6.18.orig/drivers/block/cciss.c	2011-03-04 01:59:45 +0000
+++ linux-2.6.18/drivers/block/cciss.c	2011-03-04 17:48:35 +0000
@@ -194,11 +194,40 @@ static void cciss_free_drive_info(ctlr_i
 static void cciss_clear_drive_info(drive_info_struct *drive_info);
 static void cciss_sysfs_stat_inquiry(int ctlr, int logvol,
 			drive_info_struct *drv);
-static inline void complete_pc_buffers(struct bio *bio,
-	unsigned int nr_bytes, int status);
-static inline void complete_fs_buffers(struct bio *bio, int status);
 static unsigned int blk_rq_bytes(struct request *rq);
 
+static inline void complete_pc_buffers(struct bio *bio,
+	unsigned int nr_bytes, int status)
+{
+	unsigned int bytes_remaining = nr_bytes;
+
+	while (bio) {
+		struct bio *xbh = bio->bi_next;
+		unsigned int bytes_in_this_bio = bio_sectors(bio) << 9;
+
+		if (bytes_in_this_bio > bytes_remaining)
+			bytes_in_this_bio = bytes_remaining;
+
+		bio->bi_next = NULL;
+		bio_endio(bio, bytes_in_this_bio, status ? 0 : -EIO);
+		bio = xbh;
+
+		bytes_remaining -= bytes_in_this_bio;
+	}
+}
+
+static inline void complete_fs_buffers(struct bio *bio, int status)
+{
+	while (bio) {
+		struct bio *xbh = bio->bi_next;
+		unsigned int nr_bytes = bio_sectors(bio) << 9;
+ 
+		bio->bi_next = NULL;
+		bio_endio(bio, nr_bytes, status ? 0 : -EIO);
+		bio = xbh;
+	}
+}
+
 #ifdef CONFIG_PROC_FS
 static void cciss_procinit(int i);
 #else
@@ -4460,38 +4489,6 @@ err:
 
 }
 
-static inline void complete_pc_buffers(struct bio *bio,
-	unsigned int nr_bytes, int status)
-{
-	unsigned int bytes_remaining = nr_bytes;
-
-	while (bio) {
-		struct bio *xbh = bio->bi_next;
-		unsigned int bytes_in_this_bio = bio_sectors(bio) << 9;
-
-		if (bytes_in_this_bio > bytes_remaining)
-			bytes_in_this_bio = bytes_remaining;
-
-		bio->bi_next = NULL;
-		bio_endio(bio, bytes_in_this_bio, status ? 0 : -EIO);
-		bio = xbh;
-
-		bytes_remaining -= bytes_in_this_bio;
-	}
-}
-
-static inline void complete_fs_buffers(struct bio *bio, int status)
-{
-	while (bio) {
-		struct bio *xbh = bio->bi_next;
-		unsigned int nr_bytes = bio_sectors(bio) << 9;
- 
-		bio->bi_next = NULL;
-		bio_endio(bio, nr_bytes, status ? 0 : -EIO);
-		bio = xbh;
-	}
-}
-
 /**
  * blk_rq_bytes - Returns bytes left to complete in the entire request
  * @rq: the request being processed
diff -uNrp linux-2.6.18.orig/drivers/char/keyboard.c linux-2.6.18/drivers/char/keyboard.c
--- linux-2.6.18.orig/drivers/char/keyboard.c	2011-03-04 01:59:45 +0000
+++ linux-2.6.18/drivers/char/keyboard.c	2011-03-04 17:48:35 +0000
@@ -1376,7 +1376,7 @@ int __init kbd_init(void)
 		kbd_table[i].lockstate = KBD_DEFLOCK;
 		kbd_table[i].slockstate = 0;
 		kbd_table[i].modeflags = KBD_DEFMODE;
-		kbd_table[i].kbdmode = VC_UNICODE;
+		kbd_table[i].kbdmode = VC_XLATE;
 	}
 
 	input_register_handler(&kbd_handler);
diff -uNrp linux-2.6.18.orig/drivers/char/vt.c linux-2.6.18/drivers/char/vt.c
--- linux-2.6.18.orig/drivers/char/vt.c	2011-03-04 01:59:32 +0000
+++ linux-2.6.18/drivers/char/vt.c	2011-03-04 17:48:35 +0000
@@ -1497,7 +1497,7 @@ static void reset_terminal(struct vc_dat
 	vc->vc_charset		= 0;
 	vc->vc_need_wrap	= 0;
 	vc->vc_report_mouse	= 0;
-	vc->vc_utf		= 1;
+	vc->vc_utf		= 0;
 	vc->vc_utf_count	= 0;
 
 	vc->vc_disp_ctrl	= 0;
diff -uNrp linux-2.6.18.orig/drivers/dca/Kconfig linux-2.6.18/drivers/dca/Kconfig
--- linux-2.6.18.orig/drivers/dca/Kconfig	2011-03-04 01:59:21 +0000
+++ linux-2.6.18/drivers/dca/Kconfig	2011-03-04 17:48:35 +0000
@@ -3,7 +3,7 @@
 #
 
 config DCA
-	tristate
+	tristate "DCA server configuration"
 	depends on DMA_ENGINE_V3 && PCI
 	default m
 	---help---
diff -uNrp linux-2.6.18.orig/drivers/message/fusion/mptsas.c linux-2.6.18/drivers/message/fusion/mptsas.c
--- linux-2.6.18.orig/drivers/message/fusion/mptsas.c	2011-03-04 01:59:37 +0000
+++ linux-2.6.18/drivers/message/fusion/mptsas.c	2011-03-04 17:48:35 +0000
@@ -436,6 +436,23 @@ mptsas_is_end_device(struct mptsas_devin
 		return 0;
 }
 
+static inline void
+mptsas_set_rphy(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_rphy *rphy)
+{
+	if (phy_info->port_details) {
+		phy_info->port_details->rphy = rphy;
+		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "sas_rphy_add: rphy=%p\n",
+		    ioc->name, rphy));
+	}
+
+	if (rphy) {
+		dsaswideprintk(ioc, dev_printk(KERN_DEBUG,
+		    &rphy->dev, MYIOC_s_FMT "add:", ioc->name));
+		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "rphy=%p release=%p\n",
+		    ioc->name, rphy, rphy->dev.release));
+	}
+}
+
 /* no mutex */
 static void
 mptsas_port_delete(MPT_ADAPTER *ioc, struct mptsas_portinfo_details * port_details)
@@ -474,23 +491,6 @@ mptsas_get_rphy(struct mptsas_phyinfo *p
 		return NULL;
 }
 
-static inline void
-mptsas_set_rphy(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_rphy *rphy)
-{
-	if (phy_info->port_details) {
-		phy_info->port_details->rphy = rphy;
-		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "sas_rphy_add: rphy=%p\n",
-		    ioc->name, rphy));
-	}
-
-	if (rphy) {
-		dsaswideprintk(ioc, dev_printk(KERN_DEBUG,
-		    &rphy->dev, MYIOC_s_FMT "add:", ioc->name));
-		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "rphy=%p release=%p\n",
-		    ioc->name, rphy, rphy->dev.release));
-	}
-}
-
 static inline struct sas_port *
 mptsas_get_port(struct mptsas_phyinfo *phy_info)
 {
diff -uNrp linux-2.6.18.orig/drivers/net/Kconfig linux-2.6.18/drivers/net/Kconfig
--- linux-2.6.18.orig/drivers/net/Kconfig	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/drivers/net/Kconfig	2011-03-04 17:48:35 +0000
@@ -2615,6 +2615,8 @@ config NIU
 config BNX2X
 	tristate "Broadcom NetXtremeII 10Gb support"
 	depends on PCI
+	select CRYPTO_CRC32C
+	select MDIO
 	help
 	  This driver supports Broadcom NetXtremeII 10 gigabit Ethernet cards.
 	  To compile this driver as a module, choose M here: the module
diff -uNrp linux-2.6.18.orig/fs/Kconfig linux-2.6.18/fs/Kconfig
--- linux-2.6.18.orig/fs/Kconfig	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/fs/Kconfig	2011-03-04 17:48:35 +0000
@@ -473,6 +473,7 @@ config QFMT_V2
 config SIM_FS
 	tristate "VPS filesystem"
 	depends on VZ_QUOTA
+	select EXPORTFS
 	default m
 	help
 	  This file system is a part of Virtuozzo. It intoduces a fake
diff -uNrp linux-2.6.18.orig/fs/exec.c linux-2.6.18/fs/exec.c
--- linux-2.6.18.orig/fs/exec.c	2011-03-04 01:59:45 +0000
+++ linux-2.6.18/fs/exec.c	2011-03-04 17:48:35 +0000
@@ -231,7 +231,8 @@ struct page *get_arg_page(struct linux_b
 		 *  - the program will have a reasonable amount of stack left
 		 *    to work from.
 		 */
-		if (size > rlim[RLIMIT_STACK].rlim_cur / 4) {
+		if (size > rlim[RLIMIT_STACK].rlim_cur / 4 ||
+		    size > MAX_ARG_STACK) {
 			put_page(page);
 			return NULL;
 		}
@@ -287,7 +288,10 @@ static int __bprm_mm_init(struct linux_b
 
 	vma->vm_flags = VM_STACK_FLAGS;
 	vma->vm_page_prot = protection_map[vma->vm_flags & 0x7];
-	err = insert_vm_struct(mm, vma);
+
+	err = security_file_mmap_addr(NULL, 0, 0, 0, vma->vm_start, 1);
+	if (!err)
+		err = insert_vm_struct(mm, vma);
 	if (err) {
 		up_write(&mm->mmap_sem);
 		goto err;
diff -uNrp linux-2.6.18.orig/fs/proc/base.c linux-2.6.18/fs/proc/base.c
--- linux-2.6.18.orig/fs/proc/base.c	2011-03-04 01:59:45 +0000
+++ linux-2.6.18/fs/proc/base.c	2011-03-04 17:48:35 +0000
@@ -273,10 +273,10 @@ static struct pid_entry tgid_base_stuff[
 	  S_IFREG|S_IRUGO|S_IWUSR),
 #endif
 #ifdef CONFIG_TASK_IO_ACCOUNTING
-	E(PROC_TGID_IO,             "io",  S_IFREG|S_IRUGO),
+	E(PROC_TGID_IO,             "io",  S_IFREG|S_IRUSR),
 #endif
 #ifdef CONFIG_STACKTRACE_PROC
-	E(PROC_TGID_STACK,     "stack",   S_IFREG|S_IRUGO),
+	E(PROC_TGID_STACK,     "stack",   S_IFREG|S_IRUSR),
 #endif
 
 	{0,0,NULL,0}
@@ -324,10 +324,10 @@ static struct pid_entry tid_base_stuff[]
 #endif
 	E(PROC_TID_LIMITS, "limits", S_IFREG|S_IRUGO),
 #ifdef CONFIG_TASK_IO_ACCOUNTING
-	E(PROC_TID_IO,         "io",      S_IFREG|S_IRUGO),
+	E(PROC_TID_IO,         "io",      S_IFREG|S_IRUSR),
 #endif
 #ifdef CONFIG_STACKTRACE_PROC
-	E(PROC_TID_STACK,      "stack",   S_IFREG|S_IRUGO),
+	E(PROC_TID_STACK,      "stack",   S_IFREG|S_IRUSR),
 #endif
 
 	{0,0,NULL,0}
diff -uNrp linux-2.6.18.orig/fs/sysfs/inode.c linux-2.6.18/fs/sysfs/inode.c
--- linux-2.6.18.orig/fs/sysfs/inode.c	2011-03-04 01:59:45 +0000
+++ linux-2.6.18/fs/sysfs/inode.c	2011-03-04 17:48:35 +0000
@@ -16,7 +16,15 @@
 #include <linux/security.h>
 #include "sysfs.h"
 
-static inline void set_inode_attr(struct inode * inode, struct iattr * iattr);
+static inline void set_inode_attr(struct inode * inode, struct iattr * iattr)
+{
+	inode->i_mode = iattr->ia_mode;
+	inode->i_uid = iattr->ia_uid;
+	inode->i_gid = iattr->ia_gid;
+	inode->i_atime = iattr->ia_atime;
+	inode->i_mtime = iattr->ia_mtime;
+	inode->i_ctime = iattr->ia_ctime;
+}
 
 static const struct address_space_operations sysfs_aops = {
 	.readpage	= simple_readpage,
@@ -189,16 +197,6 @@ static inline void set_default_inode_att
 	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 }
 
-static inline void set_inode_attr(struct inode * inode, struct iattr * iattr)
-{
-	inode->i_mode = iattr->ia_mode;
-	inode->i_uid = iattr->ia_uid;
-	inode->i_gid = iattr->ia_gid;
-	inode->i_atime = iattr->ia_atime;
-	inode->i_mtime = iattr->ia_mtime;
-	inode->i_ctime = iattr->ia_ctime;
-}
-
 /*
  * sysfs has a different i_mutex lock order behavior for i_mutex than other
  * filesystems; sysfs i_mutex is called in many places with subsystem locks
diff -uNrp linux-2.6.18.orig/include/linux/binfmts.h linux-2.6.18/include/linux/binfmts.h
--- linux-2.6.18.orig/include/linux/binfmts.h	2011-03-04 01:59:45 +0000
+++ linux-2.6.18/include/linux/binfmts.h	2011-03-04 17:48:35 +0000
@@ -13,7 +13,8 @@ struct pt_regs;
  */
 #define MAX_ARG_PAGES 32
 #define MAX_ARG_STRLEN (PAGE_SIZE * 32)
-#define MAX_ARG_STRINGS 0x7FFFFFFF
+#define MAX_ARG_STACK (0xC0000000UL / 4)
+#define MAX_ARG_STRINGS (MAX_ARG_STACK / 5)
 
 /* sizeof(linux_binprm->buf) */
 #define BINPRM_BUF_SIZE 128
diff -uNrp linux-2.6.18.orig/include/linux/compat.h linux-2.6.18/include/linux/compat.h
--- linux-2.6.18.orig/include/linux/compat.h	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/include/linux/compat.h	2011-03-04 17:48:35 +0000
@@ -263,5 +263,6 @@ asmlinkage long compat_sys_epoll_pwait(i
 asmlinkage long compat_sys_signalfd(int ufd,
 				const compat_sigset_t __user *sigmask,
 				compat_size_t sigsetsize);
+
 #endif /* CONFIG_COMPAT */
 #endif /* _LINUX_COMPAT_H */
diff -uNrp linux-2.6.18.orig/include/linux/dmar.h linux-2.6.18/include/linux/dmar.h
--- linux-2.6.18.orig/include/linux/dmar.h	2011-03-04 01:59:28 +0000
+++ linux-2.6.18/include/linux/dmar.h	2011-03-04 17:48:35 +0000
@@ -125,10 +125,6 @@ extern int irq_remapped(int irq);
 extern struct intel_iommu *map_dev_to_ir(struct pci_dev *dev);
 extern struct intel_iommu *map_ioapic_to_ir(int apic);
 #else
-static inline int enable_drhd_fault_handling(void)
-{
-	return -1;
-}
 static inline int alloc_irte(struct intel_iommu *iommu, int irq, u16 count)
 {
 	return -1;
diff -uNrp linux-2.6.18.orig/init/do_mounts.c linux-2.6.18/init/do_mounts.c
--- linux-2.6.18.orig/init/do_mounts.c	2011-03-04 17:37:55 +0000
+++ linux-2.6.18/init/do_mounts.c	2011-03-04 17:48:35 +0000
@@ -13,6 +13,10 @@
 #include <linux/nfs_fs_sb.h>
 #include <linux/nfs_mount.h>
 
+#ifdef CONFIG_BLK_DEV_IDECD
+#include <linux/ide.h>
+#endif
+
 #include "do_mounts.h"
 
 extern int get_filesystem_list(char * buf);
@@ -267,10 +271,63 @@ static void __init get_fs_names(char *pa
 
 static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 {
-	int err = sys_mount(name, "/root", fs, flags, data);
+	int err = -ENODEV;
+
+	if (!strcmp(saved_root_name, "/dev/cdrom")) {
+		char realname[10];
+#ifdef CONFIG_BLK_DEV_IDECD
+		int h, unit;
+		for (h = 0; h < MAX_HWIFS; h++) {
+			ide_hwif_t *hwif = &ide_hwifs[h];
+			if (!hwif->present)
+				continue;
+			for (unit = 0; unit < MAX_DRIVES; unit++) {
+				ide_drive_t *drive = &hwif->drives[unit];
+				if (!drive->present ||
+				    drive->media != ide_cdrom)
+					continue;
+				snprintf(realname, sizeof(realname),
+				    "/dev/%s", drive->name);
+				printk(KERN_INFO "Trying to mount %s...\n",
+				    realname);
+				create_dev(name,
+				    MKDEV(hwif->major, unit << PARTN_BITS));
+				err = sys_mount(name, "/root", fs, flags, data);
+				if (!err)
+					goto ok;
+			}
+		}
+#endif
+#ifdef CONFIG_BLK_DEV_SR
+		strcpy(realname, "/dev/scd0");
+		while (realname[8] < '8') {
+			int retries = root_delay;
+retry:
+			printk(KERN_INFO "Trying to mount %s...\n", realname);
+			if (retries == root_delay)
+				create_dev(name,
+				    MKDEV(SCSI_CDROM_MAJOR, realname[8] - '0'));
+			err = sys_mount(name, "/root", fs, flags, data);
+			if (!err)
+				goto ok;
+			if (err == -ENXIO || err == -ENODEV) {
+				if (retries-- <= 0)
+					return err;
+				printk(KERN_INFO "Retrying in 1 sec...\n");
+				ssleep(1);
+				goto retry;
+			}
+			realname[8]++;
+		}
+#endif
+		return err;
+	}
+
+	err = sys_mount(name, "/root", fs, flags, data);
 	if (err)
 		return err;
 
+ok:
 	sys_chdir("/root");
 	ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
 	printk("VFS: Mounted root (%s filesystem)%s.\n",
@@ -397,7 +454,7 @@ void __init prepare_namespace(void)
 {
 	int is_floppy;
 
-	if (root_delay) {
+	if (root_delay && strcmp(saved_root_name, "/dev/cdrom")) {
 		printk(KERN_INFO "Waiting %dsec before mounting root device...\n",
 		       root_delay);
 		ssleep(root_delay);
diff -uNrp linux-2.6.18.orig/init/do_mounts_md.c linux-2.6.18/init/do_mounts_md.c
--- linux-2.6.18.orig/init/do_mounts_md.c	2011-03-04 17:37:55 +0000
+++ linux-2.6.18/init/do_mounts_md.c	2011-03-04 17:48:35 +0000
@@ -122,6 +122,7 @@ static void __init md_setup_drive(void)
 
 	for (ent = 0; ent < md_setup_ents ; ent++) {
 		int fd;
+		int disknum = 0;
 		int err = 0;
 		char *devname;
 		mdu_disk_info_t dinfo;
@@ -144,7 +145,7 @@ static void __init md_setup_drive(void)
 
 			p = strchr(devname, ',');
 			if (p)
-				*p++ = 0;
+				*p = 0;
 
 			dev = name_to_dev_t(devname);
 			if (strncmp(devname, "/dev/", 5) == 0)
@@ -154,17 +155,22 @@ static void __init md_setup_drive(void)
 			if (rdev)
 				dev = new_decode_dev(rdev);
 			if (!dev) {
-				printk(KERN_WARNING "md: Unknown device name: %s\n", devname);
-				break;
+				printk(KERN_WARNING "md: Skipping unknown device name: %s\n", devname);
+				if (p)
+					*p++ = ',';
+				devname = p;
+				continue;
 			}
 
-			devices[i] = dev;
+			devices[disknum++] = dev;
 
+			if (p)
+				*p++ = ',';
 			devname = p;
 		}
-		devices[i] = 0;
+		devices[disknum] = 0;
 
-		if (!i)
+		if (!disknum)
 			continue;
 
 		printk(KERN_INFO "md: Loading md%s%d: %s\n",
diff -uNrp linux-2.6.18.orig/kernel/exit.c linux-2.6.18/kernel/exit.c
--- linux-2.6.18.orig/kernel/exit.c	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/kernel/exit.c	2011-03-04 17:48:35 +0000
@@ -957,12 +957,28 @@ fastcall NORET_TYPE void do_exit(long co
 	int group_dead;
 	unsigned int mycpu;
 
+	/*
+	 * Check this first since set_fs() below depends on
+	 * current_thread_info(), which we better not access when we're in
+	 * interrupt context.  Other than that, we want to do the set_fs()
+	 * as early as possible.
+	 */
+	if (unlikely(in_interrupt()))
+		panic("Aiee, killing interrupt handler!");
+
+	/*
+	 * If do_exit is called because this process Oops'ed, it's possible
+	 * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before
+	 * continuing. Amongst other possible reasons, this is to prevent
+	 * mm_release()->clear_child_tid() from writing to a user-controlled
+	 * kernel address.
+	 */
+	set_fs(USER_DS);
+
 	profile_task_exit(tsk);
 
 	WARN_ON(atomic_read(&tsk->fs_excl));
 
-	if (unlikely(in_interrupt()))
-		panic("Aiee, killing interrupt handler!");
 	if (unlikely(!tsk->pid))
 		panic("Attempted to kill the idle task!");
 #ifdef CONFIG_VE
diff -uNrp linux-2.6.18.orig/kernel/kallsyms.c linux-2.6.18/kernel/kallsyms.c
--- linux-2.6.18.orig/kernel/kallsyms.c	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/kernel/kallsyms.c	2011-03-04 17:48:35 +0000
@@ -421,7 +421,7 @@ static int __init kallsyms_init(void)
 {
 	struct proc_dir_entry *entry;
 
-	entry = create_proc_entry("kallsyms", 0444, NULL);
+	entry = create_proc_entry("kallsyms", 0400, NULL);
 	if (entry)
 		entry->proc_fops = &kallsyms_operations;
 	return 0;
diff -uNrp linux-2.6.18.orig/kernel/panic.c linux-2.6.18/kernel/panic.c
--- linux-2.6.18.orig/kernel/panic.c	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/kernel/panic.c	2011-03-04 17:48:35 +0000
@@ -20,7 +20,7 @@
 #include <linux/kexec.h>
 #include <linux/debug_locks.h>
 
-int panic_on_oops = 1;
+int panic_on_oops;
 int tainted = 1;
 static int pause_on_oops;
 static int pause_on_oops_flag;
diff -uNrp linux-2.6.18.orig/kernel/printk.c linux-2.6.18/kernel/printk.c
--- linux-2.6.18.orig/kernel/printk.c	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/kernel/printk.c	2011-03-04 17:48:35 +0000
@@ -255,10 +255,6 @@ int do_syslog(int type, char __user *buf
 	if (!ve_is_super(get_exec_env()) && (type == 6 || type == 7))
 		goto out;
 
-	error = security_syslog(type);
-	if (error)
-		return error;
-
 	switch (type) {
 	case 0:		/* Close log */
 		break;
@@ -390,6 +386,12 @@ out:
 
 asmlinkage long sys_syslog(int type, char __user *buf, int len)
 {
+	int error;
+
+	error = security_syslog(type);
+	if (error)
+		return error;
+		
 	return do_syslog(type, buf, len);
 }
 
diff -uNrp linux-2.6.18.orig/mm/mmap.c linux-2.6.18/mm/mmap.c
--- linux-2.6.18.orig/mm/mmap.c	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/mm/mmap.c	2011-03-04 17:48:35 +0000
@@ -2397,6 +2397,11 @@ int install_special_mapping(struct mm_st
 	vma->vm_ops = &special_mapping_vmops;
 	vma->vm_private_data = pages;
 
+	if (unlikely(security_file_mmap_addr(NULL, 0, 0, 0, vma->vm_start, 1))) {
+		free_vma(mm, vma);
+		return -EPERM;
+	}
+
 	if (unlikely(insert_vm_struct(mm, vma))) {
 		free_vma(mm, vma);
 		return -ENOMEM;
diff -uNrp linux-2.6.18.orig/net/llc/af_llc.c linux-2.6.18/net/llc/af_llc.c
--- linux-2.6.18.orig/net/llc/af_llc.c	2011-03-04 17:37:55 +0000
+++ linux-2.6.18/net/llc/af_llc.c	2011-03-04 17:48:35 +0000
@@ -155,6 +155,9 @@ static int llc_ui_create(struct socket *
 	struct sock *sk;
 	int rc = -ESOCKTNOSUPPORT;
 
+	if (!capable(CAP_NET_RAW))
+		return -EPERM;
+
 	if (likely(sock->type == SOCK_DGRAM || sock->type == SOCK_STREAM)) {
 		rc = -ENOMEM;
 		sk = llc_sk_alloc(PF_LLC, GFP_KERNEL, &llc_proto);
@@ -911,6 +914,7 @@ static int llc_ui_getname(struct socket 
 	struct llc_sock *llc = llc_sk(sk);
 	int rc = 0;
 
+	memset(&sllc, 0, sizeof(sllc));
 	lock_sock(sk);
 	if (sock_flag(sk, SOCK_ZAPPED))
 		goto out;
diff -uNrp linux-2.6.18.orig/scripts/mkcompile_h linux-2.6.18/scripts/mkcompile_h
--- linux-2.6.18.orig/scripts/mkcompile_h	2011-03-04 17:37:55 +0000
+++ linux-2.6.18/scripts/mkcompile_h	2011-03-04 17:48:35 +0000
@@ -47,17 +47,9 @@ UTS_TRUNCATE="sed -e s/\(.\{1,$UTS_LEN\}
   echo \#define UTS_VERSION \"`echo $UTS_VERSION | $UTS_TRUNCATE`\"
 
   echo \#define LINUX_COMPILE_TIME \"`LC_ALL=C LANG=C date +%T`\"
-  echo \#define LINUX_COMPILE_BY \"`whoami`\"
-  echo \#define LINUX_COMPILE_HOST \"`hostname | $UTS_TRUNCATE`\"
-
-  if [ -x /bin/dnsdomainname ]; then
-    echo \#define LINUX_COMPILE_DOMAIN \"`dnsdomainname | $UTS_TRUNCATE`\"
-  elif [ -x /bin/domainname ]; then
-    echo \#define LINUX_COMPILE_DOMAIN \"`domainname | $UTS_TRUNCATE`\"
-  else
-    echo \#define LINUX_COMPILE_DOMAIN
-  fi
-
+  echo \#define LINUX_COMPILE_BY \"sources\"
+  echo \#define LINUX_COMPILE_HOST \"${ARCH}.example.org\"
+  echo \#define LINUX_COMPILE_DOMAIN \"\"
   echo \#define LINUX_COMPILER \"`$CC -v 2>&1 | tail -n 1`\"
 ) > .tmpcompile
 
diff -uNrp linux-2.6.18.orig/security/min_addr.c linux-2.6.18/security/min_addr.c
--- linux-2.6.18.orig/security/min_addr.c	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/security/min_addr.c	2011-03-04 17:48:35 +0000
@@ -5,9 +5,9 @@
 #include <linux/sysctl.h>
 
 /* amount of vm to protect from userspace access by both DAC and the LSM*/
-unsigned long mmap_min_addr;
+unsigned long mmap_min_addr = 98304;
 /* amount of vm to protect from userspace using CAP_SYS_RAWIO (DAC) */
-unsigned long dac_mmap_min_addr = 4096;
+unsigned long dac_mmap_min_addr = 98304;
 /* amount of vm to protect from userspace using the LSM = CONFIG_LSM_MMAP_MIN_ADDR */
 
 /*
diff -uNrp linux-2.6.18.orig/include/linux/sysctl.h linux-2.6.18/include/linux/sysctl.h
--- linux-2.6.18.orig/include/linux/sysctl.h	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/include/linux/sysctl.h	2011-03-04 17:48:35 +0000
@@ -476,6 +476,7 @@ enum
 	NET_IPV4_LOCAL_RESERVED_PORTS=125,
 	NET_TCP_PORT_FORWARD_RANGE=150,
 	NET_TCP_USE_SG=245,
+	NET_PING_GROUP_RANGE=246,
 };
 
 enum {
diff -uNrp linux-2.6.18.orig/include/linux/ve.h linux-2.6.18/include/linux/ve.h
--- linux-2.6.18.orig/include/linux/ve.h	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/include/linux/ve.h	2011-03-04 17:48:35 +0000
@@ -216,6 +216,7 @@ struct ve_struct {
 	struct ctl_table_header	*forward_header;
 	struct ctl_table	*forward_table;
  	unsigned long		rt_flush_required;
+	unsigned int 		ping_group_range[2];
 	struct neigh_table	*ve_arp_tbl;
 #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
 	struct ipv6_devconf	*_ipv6_devconf;
diff -uNrp /dev/null linux-2.6.18/include/net/ping.h
--- /dev/null	1970-01-01 00:00:00 +0000
+++ linux-2.6.18/include/net/ping.h	2011-02-10 18:44:33 +0000
@@ -0,0 +1,68 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the "ping" module.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _PING_H
+#define _PING_H
+
+//#include <net/netns/hash.h>
+#include <net/inet_sock.h>
+
+#ifdef CONFIG_IP_PING_DEBUG
+#define ping_debug(fmt, x...) printk(KERN_INFO fmt, ## x)
+#else
+#define ping_debug(fmt, x...) do {} while (0)
+#endif
+
+/* PING_HTABLE_SIZE must be power of 2 */
+#define PING_HTABLE_SIZE 	64
+#define PING_HTABLE_MASK 	(PING_HTABLE_SIZE-1)
+
+#define ping_portaddr_for_each_entry(__sk, node, list) \
+	hlist_nulls_for_each_entry(__sk, node, list, sk_nulls_node)
+
+#define MAX_PING_IDENT 	65536
+
+
+struct ping_table {
+	struct hlist_head	hash[PING_HTABLE_SIZE];
+	rwlock_t		lock;
+};
+
+struct ping_iter_state {
+	int			bucket;
+};
+
+extern struct proto ping_prot;
+
+
+#ifdef CONFIG_IP_PING
+#define icmp_echoreply ping_rcv
+#else
+#define icmp_echoreply icmp_discard
+#endif
+
+extern void ping_rcv(struct sk_buff *);
+extern void ping_err(struct sk_buff *, u32 info);
+
+int ipv4_ping_group_range(ctl_table *table, int write, struct file *filep,
+				 void __user *buffer,
+				 size_t *lenp, loff_t *ppos);
+
+#ifdef CONFIG_PROC_FS
+extern int __init ping_proc_init(void);
+extern void ping_proc_exit(void);
+#endif
+
+void __init ping_init(void);
+
+
+#endif /* _PING_H */
diff -uNrp linux-2.6.18.orig/kernel/ve/ve.c linux-2.6.18/kernel/ve/ve.c
--- linux-2.6.18.orig/kernel/ve/ve.c	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/kernel/ve/ve.c	2011-03-04 17:48:35 +0000
@@ -120,6 +120,7 @@ struct ve_struct ve0 = {
 #endif
 	._randomize_va_space	= 1,
 	.features		= -1,
+	.ping_group_range	= { 1, 0 },
 };
 
 EXPORT_SYMBOL(ve0);
diff -uNrp linux-2.6.18.orig/kernel/ve/vecalls.c linux-2.6.18/kernel/ve/vecalls.c
--- linux-2.6.18.orig/kernel/ve/vecalls.c	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/kernel/ve/vecalls.c	2011-03-04 17:48:35 +0000
@@ -1113,6 +1113,8 @@ static int init_ve_struct(struct ve_stru
 
 	ve->_randomize_va_space = ve0._randomize_va_space;
 	ve->ipv6_ops = ve_ipv6_ops_get();
+	ve->ping_group_range[0] = 1;
+	ve->ping_group_range[1] = 0;
  
 	return 0;
 }
diff -uNrp linux-2.6.18.orig/net/ipv4/Kconfig linux-2.6.18/net/ipv4/Kconfig
--- linux-2.6.18.orig/net/ipv4/Kconfig	2011-03-04 01:59:11 +0000
+++ linux-2.6.18/net/ipv4/Kconfig	2011-03-04 17:48:35 +0000
@@ -14,6 +14,26 @@ config IP_MULTICAST
 	  <file:Documentation/networking/multicast.txt>. For most people, it's
 	  safe to say N.
 
+config IP_PING
+	bool "IP: ping socket"
+	help
+	  This option introduces a new kind of sockets - "ping sockets".
+
+	  A ping socket makes it possible to send ICMP Echo messages and receive
+	  corresponding ICMP Echo Reply messages without any special privileges.
+	  In other words, it makes is possible to implement setuid-less /bin/ping.
+
+	  A new ping socket is created with socket(PF_INET, SOCK_DGRAM, PROT_ICMP).
+
+config IP_PING_DEBUG
+	bool "IP: ping socket debug output"
+	depends on IP_PING
+	default n
+	help
+	  Enable the inclusion of debug code in the ICMP ping sockets.
+	  Be aware that doing this will impact performance.
+	  If unsure say N.
+
 config IP_ADVANCED_ROUTER
 	bool "IP: advanced router"
 	---help---
diff -uNrp linux-2.6.18.orig/net/ipv4/Makefile linux-2.6.18/net/ipv4/Makefile
--- linux-2.6.18.orig/net/ipv4/Makefile	2011-03-04 01:59:11 +0000
+++ linux-2.6.18/net/ipv4/Makefile	2011-03-04 17:48:35 +0000
@@ -20,6 +20,7 @@ obj-$(CONFIG_IP_FIB_TRIE) += fib_trie.o
 obj-$(CONFIG_PROC_FS) += proc.o
 obj-$(CONFIG_IP_MULTIPLE_TABLES) += fib_rules.o
 obj-$(CONFIG_IP_MROUTE) += ipmr.o
+obj-$(CONFIG_IP_PING) += ping.o
 obj-$(CONFIG_NET_IPIP) += ipip.o
 obj-$(CONFIG_NET_IPGRE) += ip_gre.o
 obj-$(CONFIG_SYN_COOKIES) += syncookies.o
diff -uNrp linux-2.6.18.orig/net/ipv4/af_inet.c linux-2.6.18/net/ipv4/af_inet.c
--- linux-2.6.18.orig/net/ipv4/af_inet.c	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/net/ipv4/af_inet.c	2011-03-04 17:48:35 +0000
@@ -104,6 +104,7 @@
 #include <net/inet_connection_sock.h>
 #include <net/tcp.h>
 #include <net/udp.h>
+#include <net/ping.h>
 #include <linux/skbuff.h>
 #include <net/sock.h>
 #include <net/raw.h>
@@ -922,6 +923,16 @@ static struct inet_protosw inetsw_array[
                 .flags =      INET_PROTOSW_PERMANENT,
        },
         
+#ifdef CONFIG_IP_PING
+       {
+		.type =       SOCK_DGRAM,
+		.protocol =   IPPROTO_ICMP,
+		.prot =       &ping_prot,
+		.ops =        &inet_dgram_ops,
+		.no_check =   UDP_CSUM_DEFAULT,
+		.flags =      INET_PROTOSW_REUSE,
+       },
+#endif
 
        {
                .type =       SOCK_RAW,
@@ -1342,6 +1353,9 @@ static struct net_protocol udp_protocol 
 
 static struct net_protocol icmp_protocol = {
 	.handler =	icmp_rcv,
+#ifdef CONFIG_IP_PING
+	.err_handler =	ping_err,
+#endif
 	.no_policy =	1,
 };
 
@@ -1417,6 +1431,11 @@ static int __init inet_init(void)
 	rc = proto_register(&raw_prot, 1);
 	if (rc)
 		goto out_unregister_udp_proto;
+#ifdef CONFIG_IP_PING
+	rc = proto_register(&ping_prot, 1);
+	if (rc)
+		goto out_unregister_raw_proto;
+#endif
 
 	/*
 	 *	Tell SOCKET that we are alive... 
@@ -1468,12 +1487,17 @@ static int __init inet_init(void)
 	/* Setup UDP memory threshold */
 	udp_init();
 
+
 	/*
 	 *	Set the ICMP layer up
 	 */
 
 	icmp_init(&inet_family_ops);
 
+#ifdef CONFIG_IP_PING
+	ping_init();
+#endif
+
 	/*
 	 *	Initialise the multicast router
 	 */
@@ -1497,6 +1521,10 @@ static int __init inet_init(void)
 	rc = 0;
 out:
 	return rc;
+#ifdef CONFIG_IP_PING
+out_unregister_raw_proto:
+	proto_unregister(&raw_prot);
+#endif
 out_unregister_tcp_proto:
 	proto_unregister(&tcp_prot);
 out_unregister_udp_proto:
@@ -1523,11 +1551,19 @@ static int __init ipv4_proc_init(void)
 		goto out_udp;
 	if (fib_proc_init())
 		goto out_fib;
+#ifdef CONFIG_IP_PING
+	if (ping_proc_init())
+		goto out_ping;
+#endif
 	if (ip_misc_proc_init())
 		goto out_misc;
 out:
 	return rc;
 out_misc:
+#ifdef CONFIG_IP_PING
+	ping_proc_exit();
+out_ping:
+#endif
 	fib_proc_exit();
 out_fib:
 	udp4_proc_exit();
diff -uNrp linux-2.6.18.orig/net/ipv4/devinet.c linux-2.6.18/net/ipv4/devinet.c
--- linux-2.6.18.orig/net/ipv4/devinet.c	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/net/ipv4/devinet.c	2011-03-04 17:48:35 +0000
@@ -61,6 +61,7 @@
 
 #include <net/arp.h>
 #include <net/ip.h>
+#include <net/ping.h>
 #include <net/route.h>
 #include <net/ip_fib.h>
 
@@ -1670,10 +1671,17 @@ static ctl_table net_sysctl_tables[] = {
 		.procname	= "route",
 		.maxlen		= 0,
 		.mode		= 0555,
-		.child		= &net_sysctl_tables[7],
+		.child		= &net_sysctl_tables[8],
+	},
+	{
+		.ctl_name	= NET_PING_GROUP_RANGE,
+		.procname	= "ping_group_range",
+		.maxlen		= sizeof(int)*2,
+		.mode		= 0644,
+		.proc_handler	= &ipv4_ping_group_range,
 	},
 	{ .ctl_name = 0 },
-	/* 7: net/ipv4/route/flush */
+	/* 8: net/ipv4/route/flush */
 	{
 		.ctl_name 	= NET_IPV4_ROUTE_FLUSH,
 		.procname	= "flush",
diff -uNrp linux-2.6.18.orig/net/ipv4/icmp.c linux-2.6.18/net/ipv4/icmp.c
--- linux-2.6.18.orig/net/ipv4/icmp.c	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/net/ipv4/icmp.c	2011-03-04 17:48:35 +0000
@@ -84,6 +84,7 @@
 #include <net/tcp.h>
 #include <net/udp.h>
 #include <net/raw.h>
+#include <net/ping.h>
 #include <linux/skbuff.h>
 #include <net/sock.h>
 #include <linux/errno.h>
@@ -820,6 +821,17 @@ static void icmp_redirect(struct sk_buff
 			       iph->saddr, skb->dev);
 		break;
   	}
+
+#ifdef CONFIG_IP_PING
+	/* Ping wants to see redirects.
+         * Let's pretend they are errors of sorts... */
+	if (iph->protocol == IPPROTO_ICMP &&
+	    iph->ihl >= 5 &&
+	    pskb_may_pull(skb, (iph->ihl<<2)+8)) {
+		ping_err(skb, icmp_hdr(skb)->un.gateway);
+	}
+#endif
+
 out:
 	return;
 out_err:
@@ -1062,7 +1074,7 @@ error:
  */
 static const struct icmp_control icmp_pointers[NR_ICMP_TYPES + 1] = {
 	[ICMP_ECHOREPLY] = {
-		.handler = icmp_discard,
+		.handler = icmp_echoreply,
 	},
 	[1] = {
 		.handler = icmp_discard,
diff -uNrp /dev/null linux-2.6.18/net/ipv4/ping.c
--- /dev/null	1970-01-01 00:00:00 +0000
+++ linux-2.6.18/net/ipv4/ping.c	2011-03-06 11:12:31 +0000
@@ -0,0 +1,1022 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		"Ping" sockets
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * Based on ipv4/udp.c code.
+ *
+ * Authors:	Vasiliy Kulikov / Openwall (for Linux 2.6.18),
+ *		Pavel Kankovsky (for Linux 2.4.32)
+ *
+ */
+
+#include <asm/system.h>
+#include <linux/uaccess.h>
+#include <asm/ioctls.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/inet.h>
+#include <linux/netdevice.h>
+#include <net/snmp.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <net/icmp.h>
+#include <net/protocol.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+#include <net/sock.h>
+#include <net/ping.h>
+#include <net/icmp.h>
+#include <net/udp.h>
+#include <net/route.h>
+#include <net/inet_common.h>
+#include <net/checksum.h>
+
+
+#ifdef CONFIG_SYSCTL
+
+/*
+ * gid_t is either uint or ushort.  We want to pass it to
+ * proc_dointvec_minmax(), so it must not be larger than MAX_INT
+ */
+#define GID_T_MAX (((gid_t)~0U) >> 1)
+
+DEFINE_SEQLOCK(ping_group_range_lock);
+static const unsigned int ip_ping_group_range_min[] = { 0, 0 };
+static const unsigned int ip_ping_group_range_max[] = { GID_T_MAX, GID_T_MAX };
+#endif
+
+struct ping_table ping_table __read_mostly;
+
+u16 ping_port_rover;
+
+static inline int ping_hashfn(struct ve_struct *net, unsigned num, unsigned mask)
+{
+	unsigned veid = VEID(net);
+	int res = (num + (veid ^ (veid >> 16))) & mask;
+	ping_debug("hash(%d) = %d\n", num, res);
+	return res;
+}
+
+static inline struct hlist_head *ping_hashslot(struct ping_table *table,
+					     struct ve_struct *net, unsigned num)
+{
+	return &table->hash[ping_hashfn(net, num, PING_HTABLE_MASK)];
+}
+
+void __inet_get_ping_group_range(gid_t *data, gid_t *low, gid_t *high)
+{
+	unsigned seq;
+	do {
+		seq = read_seqbegin(&ping_group_range_lock);
+
+		*low = data[0];
+		*high = data[1];
+	} while (read_seqretry(&ping_group_range_lock, seq));
+}
+
+void inet_get_ping_group_range_net(struct ve_struct *net, gid_t *low, gid_t *high)
+{
+	gid_t *data = net->ping_group_range;
+	__inet_get_ping_group_range(data, low, high);
+}
+
+/* Update system visible IP port range */
+void set_ping_group_range(gid_t *data, gid_t range[2])
+{
+	write_seqlock(&ping_group_range_lock);
+	data[0] = range[0];
+	data[1] = range[1];
+	write_sequnlock(&ping_group_range_lock);
+}
+
+/* Validate changes from /proc interface. */
+int ipv4_ping_group_range(ctl_table *table, int write, struct file *filep,
+				 void __user *buffer,
+				 size_t *lenp, loff_t *ppos)
+{
+	int ret;
+	gid_t range[2];
+	ctl_table tmp = {
+		.data = &range,
+		.maxlen = sizeof(range),
+		.mode = table->mode,
+		.extra1 = &ip_ping_group_range_min,
+		.extra2 = &ip_ping_group_range_max,
+	};
+	struct ve_struct *env = table->owner_env;
+	if (env == NULL)
+		env = get_ve0();
+
+	inet_get_ping_group_range_net(env, range, range + 1);
+	ret = proc_dointvec_minmax(&tmp, write, filep, buffer, lenp, ppos);
+
+	if (write && ret == 0)
+		set_ping_group_range(env->ping_group_range, range);
+
+	return ret;
+}
+
+static int ping_v4_get_port(struct sock *sk, unsigned short ident)
+{
+	struct hlist_node *node;
+	struct hlist_head *hlist;
+	struct inet_sock *isk, *isk2;
+	struct sock *sk2 = NULL;
+	struct ve_struct *env;
+
+	env = sk->owner_env;
+	isk = inet_sk(sk);
+	write_lock_bh(&ping_table.lock);
+	if (ident == 0) {
+		u32 i;
+		u16 result = ping_port_rover + 1;
+
+		for (i = 0; i < (1L << 16); i++, result++) {
+			if (!result)
+				result++; /* avoid zero */
+			hlist = ping_hashslot(&ping_table, env,
+					    result);
+			sk_for_each(sk2, node, hlist) {
+				isk2 = inet_sk(sk2);
+
+				if (isk2->num == result)
+					goto next_port;
+			}
+
+			/* found */
+			ping_port_rover = ident = result;
+			break;
+next_port:
+			;
+		}
+		if (i >= (1L << 16))
+			goto fail;
+	} else {
+		hlist = ping_hashslot(&ping_table, env, ident);
+		sk_for_each(sk2, node, hlist) {
+			isk2 = inet_sk(sk2);
+
+			if ((isk2->num == ident) &&
+			    (sk2 != sk) &&
+			    (!sk2->sk_reuse || !sk->sk_reuse))
+				goto fail;
+		}
+	}
+
+	ping_debug("found port/ident = %d\n", ident);
+	isk->num = ident;
+	if (sk_unhashed(sk)) {
+		ping_debug("was not hashed\n");
+		sock_hold(sk);
+
+		sk_add_node(sk, hlist);
+		sock_prot_inc_use(sk->sk_prot);
+	}
+	write_unlock_bh(&ping_table.lock);
+	return 0;
+
+fail:
+	write_unlock_bh(&ping_table.lock);
+	return 1;
+}
+
+static void ping_v4_hash(struct sock *sk)
+{
+	ping_debug("ping_v4_hash(sk->port=%u)\n", inet_sk(sk)->num);
+	BUG(); /* "Please do not press this button again." */
+}
+
+static void ping_v4_unhash(struct sock *sk)
+{
+	struct inet_sock *isk = inet_sk(sk);
+	struct ve_struct *env = sk->owner_env;
+	ping_debug("ping_v4_unhash(isk=%p,isk->num=%u)\n", isk, isk->num);
+	if (sk_hashed(sk)) {
+		struct hlist_head *hslot;
+
+		hslot = ping_hashslot(&ping_table, env, isk->num);
+		write_lock_bh(&ping_table.lock);
+		sk_del_node_init(sk);
+		sock_put(sk);
+		isk->num = isk->sport = 0;
+		sock_prot_dec_use(sk->sk_prot);
+		write_unlock_bh(&ping_table.lock);
+	}
+}
+
+static int ping_init_sock(struct sock *sk)
+{
+	struct group_info *group_info = current->group_info;
+	int count = group_info->ngroups;
+	struct ve_struct *net = sk->owner_env;
+	int i,j;
+
+	gid_t group = current->egid;
+	gid_t range[2];
+
+	inet_get_ping_group_range_net(net, range, range+1);
+	if (range[0] <= group && group <= range[1])
+		return 0;
+
+
+	for (i = 0; i < group_info->nblocks; i++) {
+		int cp_count = min(NGROUPS_PER_BLOCK, count);
+
+		for (j = 0; j < cp_count; j++) {
+			group = group_info->blocks[i][j];
+			if (range[0] <= group && group <= range[1])
+				return 0;
+		}
+
+		count -= cp_count;
+	}
+
+	return -EACCES;
+}
+
+struct sock *ping_v4_lookup(u32 saddr, u32 daddr, u16 ident, int dif)
+{
+	struct ve_struct *net = get_exec_env();
+	struct hlist_head *hslot = ping_hashslot(&ping_table, net, ident);
+	struct sock *sk = NULL;
+	struct inet_sock *isk;
+	struct hlist_node *hnode;
+
+	ping_debug("try to find: num = %d, daddr = %ld, dif = %d\n",
+			 (int)ident, (unsigned long)daddr, dif);
+	read_lock_bh(&ping_table.lock);
+
+	sk_for_each(sk, hnode, hslot) {
+		isk = inet_sk(sk);
+
+		ping_debug("found: %p: num = %d, daddr = %ld, dif = %d\n", sk,
+			 (int)isk->num, (unsigned long)isk->rcv_saddr,
+			 sk->sk_bound_dev_if);
+
+		ping_debug("iterate\n");
+		if (isk->num != ident)
+			continue;
+		if (isk->rcv_saddr && isk->rcv_saddr != daddr)
+			continue;
+		if (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif)
+			continue;
+
+		sock_hold(sk);
+		goto exit;
+	}
+
+	sk = NULL;
+exit:
+	read_unlock_bh(&ping_table.lock);
+
+	return sk;
+}
+
+static void ping_close(struct sock *sk, long timeout)
+{
+	ping_debug("ping_close(sk=%p,sk->num=%u)\n",
+		inet_sk(sk), inet_sk(sk)->num);
+	ping_debug("isk->refcnt = %d\n", sk->sk_refcnt.counter);
+
+	sk_common_release(sk);
+}
+
+/*
+ * We need our own bind because there are no privileged id's == local ports.
+ * Moreover, we don't allow binding to multi- and broadcast addresses.
+ */
+
+static int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
+{
+	struct sockaddr_in *addr = (struct sockaddr_in *)uaddr;
+	struct inet_sock *isk = inet_sk(sk);
+	unsigned short snum;
+	int chk_addr_ret;
+	int err;
+	//struct ve_struct *env = sk->owner_env;
+
+	if (addr_len < sizeof(struct sockaddr_in))
+		return -EINVAL;
+
+	ping_debug("ping_v4_bind(sk=%p,sa_addr=%08x,sa_port=%d)\n",
+		sk, addr->sin_addr.s_addr, ntohs(addr->sin_port));
+
+	chk_addr_ret = inet_addr_type(addr->sin_addr.s_addr);
+	if (addr->sin_addr.s_addr == INADDR_ANY)
+		chk_addr_ret = RTN_LOCAL;
+
+	if ((sysctl_ip_nonlocal_bind == 0 &&
+	    isk->freebind == 0 && // isk->transparent == 0 &&
+	     chk_addr_ret != RTN_LOCAL) ||
+	    chk_addr_ret == RTN_MULTICAST ||
+	    chk_addr_ret == RTN_BROADCAST)
+		return -EADDRNOTAVAIL;
+
+	lock_sock(sk);
+
+	err = -EINVAL;
+	if (isk->num != 0)
+		goto out;
+
+	err = -EADDRINUSE;
+	isk->rcv_saddr = isk->saddr = addr->sin_addr.s_addr;
+	snum = ntohs(addr->sin_port);
+	if (ping_v4_get_port(sk, snum) != 0) {
+		isk->saddr = isk->rcv_saddr = 0;
+		goto out;
+	}
+
+	ping_debug("after bind(): num = %d, daddr = %ld, dif = %d\n",
+		(int)isk->num,
+		(unsigned long) isk->rcv_saddr,
+		(int)sk->sk_bound_dev_if);
+
+	err = 0;
+	if (isk->rcv_saddr)
+		sk->sk_userlocks |= SOCK_BINDADDR_LOCK;
+	if (snum)
+		sk->sk_userlocks |= SOCK_BINDPORT_LOCK;
+	isk->sport = htons(isk->num);
+	isk->daddr = 0;
+	isk->dport = 0;
+	sk_dst_reset(sk);
+out:
+	release_sock(sk);
+	ping_debug("ping_v4_bind -> %d\n", err);
+	return err;
+}
+
+/*
+ * Is this a supported type of ICMP message?
+ */
+
+static inline int ping_supported(int type, int code)
+{
+	if (type == ICMP_ECHO && code == 0)
+		return 1;
+	return 0;
+}
+
+/*
+ * This routine is called by the ICMP module when it gets some
+ * sort of error condition.
+ */
+
+static int ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb);
+
+void ping_err(struct sk_buff *skb, u32 info)
+{
+	struct iphdr *iph = (struct iphdr *)skb->data;
+	struct icmphdr *icmph = (struct icmphdr *)(skb->data+(iph->ihl<<2));
+	struct inet_sock *inet_sock;
+	int type = icmph->type;
+	int code = icmph->code;
+	struct sock *sk;
+	int harderr;
+	int err;
+
+	/* We assume the packet has already been checked by icmp_unreach */
+
+	if (!ping_supported(icmph->type, icmph->code))
+		return;
+
+	ping_debug("ping_err(type=%04x,code=%04x,id=%04x,seq=%04x)\n", type,
+		code, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));
+
+	sk = ping_v4_lookup(iph->daddr, iph->saddr,
+			    ntohs(icmph->un.echo.id), skb->dev->ifindex);
+	if (sk == NULL) {
+		ICMP_INC_STATS_BH(ICMP_MIB_INERRORS);
+		ping_debug("no socket, dropping\n");
+		return;	/* No socket for error */
+	}
+	ping_debug("err on socket %p\n", sk);
+
+	err = 0;
+	harderr = 0;
+	inet_sock = inet_sk(sk);
+
+	switch (type) {
+	default:
+	case ICMP_TIME_EXCEEDED:
+		err = EHOSTUNREACH;
+		break;
+	case ICMP_SOURCE_QUENCH:
+		/* This is not a real error but ping wants to see it.
+		 * Report it with some fake errno. */
+		err = EREMOTEIO;
+		break;
+	case ICMP_PARAMETERPROB:
+		err = EPROTO;
+		harderr = 1;
+		break;
+	case ICMP_DEST_UNREACH:
+		if (code == ICMP_FRAG_NEEDED) { /* Path MTU discovery */
+			if (inet_sock->pmtudisc != IP_PMTUDISC_DONT) {
+				err = EMSGSIZE;
+				harderr = 1;
+				break;
+			}
+			goto out;
+		}
+		err = EHOSTUNREACH;
+		if (code <= NR_ICMP_UNREACH) {
+			harderr = icmp_err_convert[code].fatal;
+			err = icmp_err_convert[code].errno;
+		}
+		break;
+	case ICMP_REDIRECT:
+		/* See ICMP_SOURCE_QUENCH */
+		err = EREMOTEIO;
+		break;
+	}
+
+	/*
+	 *      RFC1122: OK.  Passes ICMP errors back to application, as per
+	 *	4.1.3.3.
+	 */
+	if (!inet_sock->recverr) {
+		if (!harderr || sk->sk_state != TCP_ESTABLISHED)
+			goto out;
+	} else {
+		ip_icmp_error(sk, skb, err, 0 /* no remote port */,
+			 info, (u8 *)icmph);
+	}
+	sk->sk_err = err;
+	sk->sk_error_report(sk);
+out:
+	sock_put(sk);
+}
+
+/*
+ *	Copy and checksum an ICMP Echo packet from user space into a buffer.
+ */
+
+struct pingfakehdr {
+	struct icmphdr icmph;
+	struct iovec *iov;
+	u32 wcheck;
+};
+
+static int ping_getfrag(void *from, char * to,
+			int offset, int fraglen, int odd, struct sk_buff *skb)
+{
+	struct pingfakehdr *pfh = (struct pingfakehdr *)from;
+
+	if (offset == 0) {
+		if (fraglen < sizeof(struct icmphdr))
+			BUG();
+		if (csum_partial_copy_fromiovecend(to + sizeof(struct icmphdr),
+			    pfh->iov, 0, fraglen - sizeof(struct icmphdr),
+			    &pfh->wcheck))
+			return -EFAULT;
+
+		return 0;
+	}
+	if (offset < sizeof(struct icmphdr))
+		BUG();
+	if (csum_partial_copy_fromiovecend
+			(to, pfh->iov, offset - sizeof(struct icmphdr),
+			 fraglen, &pfh->wcheck))
+		return -EFAULT;
+	return 0;
+}
+
+static int ping_push_pending_frames(struct sock *sk, struct pingfakehdr *pfh)
+{
+	struct sk_buff *skb = skb_peek(&sk->sk_write_queue);
+
+	pfh->wcheck = csum_partial((char *)&pfh->icmph,
+		sizeof(struct icmphdr), pfh->wcheck);
+	pfh->icmph.checksum = csum_fold(pfh->wcheck);
+	memcpy(skb->h.icmph, &pfh->icmph, sizeof(struct icmphdr));
+	skb->ip_summed = CHECKSUM_NONE;
+
+	return ip_push_pending_frames(sk);
+}
+
+int ping_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+		 size_t len)
+{
+	struct inet_sock *isk = inet_sk(sk);
+	struct ipcm_cookie ipc;
+	struct icmphdr user_icmph;
+	struct pingfakehdr pfh;
+	struct rtable *rt = NULL;
+	int free = 0;
+	u32 saddr, daddr;
+	u8  tos;
+	int err;
+	//struct ve_struct *env = sk->owner_env;
+
+	ping_debug("ping_sendmsg(sk=%p,sk->num=%u)\n", isk, isk->num);
+
+
+	if (len > 0xFFFF)
+		return -EMSGSIZE;
+
+	/*
+	 *	Check the flags.
+	 */
+
+	/* Mirror BSD error message compatibility */
+	if (msg->msg_flags & MSG_OOB)
+		return -EOPNOTSUPP;
+
+	/*
+	 *	Fetch the ICMP header provided by the userland.
+	 *	iovec is modified!
+	 */
+
+	if (memcpy_fromiovec((u8 *)&user_icmph, msg->msg_iov,
+			     sizeof(struct icmphdr)))
+		return -EFAULT;
+	if (!ping_supported(user_icmph.type, user_icmph.code))
+		return -EINVAL;
+
+	/*
+	 *	Get and verify the address.
+	 */
+
+	if (msg->msg_name) {
+		struct sockaddr_in *usin = (struct sockaddr_in *)msg->msg_name;
+		if (msg->msg_namelen < sizeof(*usin))
+			return -EINVAL;
+		if (usin->sin_family != AF_INET)
+			return -EINVAL;
+		daddr = usin->sin_addr.s_addr;
+		/* no remote port */
+	} else {
+		if (sk->sk_state != TCP_ESTABLISHED)
+			return -EDESTADDRREQ;
+		daddr = isk->daddr;
+		/* no remote port */
+	}
+
+	ipc.addr = isk->saddr;
+	ipc.opt = NULL;
+	ipc.oif = sk->sk_bound_dev_if;
+
+	if (msg->msg_controllen) {
+		err = ip_cmsg_send(msg, &ipc);
+		if (err)
+			return err;
+		if (ipc.opt)
+			free = 1;
+	}
+	if (!ipc.opt)
+		ipc.opt = isk->opt;
+
+	saddr = ipc.addr;
+	ipc.addr = daddr;
+
+	if (ipc.opt && ipc.opt->srr) {
+		if (!daddr)
+			return -EINVAL;
+		daddr = ipc.opt->faddr;
+	}
+	tos = RT_TOS(isk->tos);
+	if (sock_flag(sk, SOCK_LOCALROUTE) ||
+	    (msg->msg_flags&MSG_DONTROUTE) ||
+	    (ipc.opt && ipc.opt->is_strictroute)) {
+		tos |= RTO_ONLINK;
+	}
+
+	if (MULTICAST(daddr)) {
+		if (!ipc.oif)
+			ipc.oif = isk->mc_index;
+		if (!saddr)
+			saddr = isk->mc_addr;
+	}
+
+	{
+		struct flowi fl = { .oif = ipc.oif,
+				    .nl_u = { .ip4_u = {
+						.daddr = daddr,
+						.saddr = saddr,
+						.tos = tos } },
+				    .proto = IPPROTO_ICMP,
+		};
+
+		//struct ve_struct *net = env;
+
+		security_sk_classify_flow(sk, &fl);
+		err = ip_route_output_flow(&rt, &fl, sk, 1);
+		if (err) {
+			if (err == -ENETUNREACH)
+				IP_INC_STATS_BH(IPSTATS_MIB_OUTNOROUTES);
+			goto out;
+		}
+
+		err = -EACCES;
+		if ((rt->rt_flags & RTCF_BROADCAST) &&
+		    !sock_flag(sk, SOCK_BROADCAST))
+			goto out;
+	}
+
+	if (msg->msg_flags & MSG_CONFIRM)
+		goto do_confirm;
+back_from_confirm:
+
+	if (!ipc.addr)
+		ipc.addr = rt->rt_dst;
+
+	lock_sock(sk);
+
+	pfh.icmph.type = user_icmph.type; /* already checked */
+	pfh.icmph.code = user_icmph.code; /* dtto */
+	pfh.icmph.checksum = 0;
+	pfh.icmph.un.echo.id = isk->sport;
+	pfh.icmph.un.echo.sequence = user_icmph.un.echo.sequence;
+	pfh.iov = msg->msg_iov;
+	pfh.wcheck = 0;
+
+	err = ip_append_data(sk, ping_getfrag, &pfh, len,
+			0, &ipc, rt,
+			msg->msg_flags);
+	if (err)
+		ip_flush_pending_frames(sk);
+	else
+		err = ping_push_pending_frames(sk, &pfh);
+	release_sock(sk);
+
+out:
+	ip_rt_put(rt);
+	if (free)
+		kfree(ipc.opt);
+	if (!err) {
+		icmp_out_count(user_icmph.type);
+		return len;
+	}
+	return err;
+
+do_confirm:
+	dst_confirm(&rt->u.dst);
+	if (!(msg->msg_flags & MSG_PROBE) || len)
+		goto back_from_confirm;
+	err = 0;
+	goto out;
+}
+
+/*
+ *	IOCTL requests applicable to the UDP^H^H^HICMP protocol
+ */
+
+int ping_ioctl(struct sock *sk, int cmd, unsigned long arg)
+{
+	ping_debug("ping_ioctl(sk=%p,sk->num=%u,cmd=%d,arg=%lu)\n",
+		inet_sk(sk), inet_sk(sk)->num, cmd, arg);
+	switch (cmd) {
+	case SIOCOUTQ:
+	case SIOCINQ:
+		return udp_ioctl(sk, cmd, arg);
+	default:
+		return -ENOIOCTLCMD;
+	}
+}
+
+int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+		 size_t len, int noblock, int flags, int *addr_len)
+{
+	struct inet_sock *isk = inet_sk(sk);
+	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
+	struct sk_buff *skb;
+	int copied, err;
+
+	ping_debug("ping_recvmsg(sk=%p,sk->num=%u)\n", isk, isk->num);
+
+	if (flags & MSG_OOB)
+		goto out;
+
+	if (addr_len)
+		*addr_len = sizeof(*sin);
+
+	if (flags & MSG_ERRQUEUE)
+		return ip_recv_error(sk, msg, len);
+
+	skb = skb_recv_datagram(sk, flags, noblock, &err);
+	if (!skb)
+		goto out;
+
+	copied = skb->len;
+	if (copied > len) {
+		msg->msg_flags |= MSG_TRUNC;
+		copied = len;
+	}
+
+	/* Don't bother checking the checksum */
+	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
+	if (err)
+		goto done;
+
+	sock_recv_timestamp(msg, sk, skb);
+
+	/* Copy the address. */
+	if (sin) {
+		sin->sin_family = AF_INET;
+		sin->sin_port = 0 /* skb->h.uh->source */;
+		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
+		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+	}
+	if (isk->cmsg_flags)
+		ip_cmsg_recv(msg, skb);
+	err = copied;
+
+done:
+	skb_free_datagram(sk, skb);
+out:
+	ping_debug("ping_recvmsg -> %d\n", err);
+	return err;
+}
+
+static int ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
+{
+	ping_debug("ping_queue_rcv_skb(sk=%p,sk->num=%d,skb=%p)\n",
+		inet_sk(sk), inet_sk(sk)->num, skb);
+	if (sock_queue_rcv_skb(sk, skb) < 0) {
+		ICMP_INC_STATS_BH(ICMP_MIB_INERRORS);
+		kfree_skb(skb);
+		ping_debug("ping_queue_rcv_skb -> failed\n");
+		return -1;
+	}
+	return 0;
+}
+
+
+/*
+ *	All we need to do is get the socket.
+ */
+
+void ping_rcv(struct sk_buff *skb)
+{
+	struct sock *sk;
+	//struct ve_struct *net = dev_net(skb->dev);
+	struct iphdr *iph = ip_hdr(skb);
+	struct icmphdr *icmph = icmp_hdr(skb);
+	u32 saddr = iph->saddr;
+	u32 daddr = iph->daddr;
+
+	/* We assume the packet has already been checked by icmp_rcv */
+
+	ping_debug("ping_rcv(skb=%p,id=%04x,seq=%04x)\n",
+		skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));
+
+	/* Push ICMP header back */
+	skb_push(skb, skb->data - (u8 *)icmph);
+
+	sk = ping_v4_lookup(saddr, daddr, ntohs(icmph->un.echo.id),
+			    skb->dev->ifindex);
+	if (sk != NULL) {
+		ping_debug("rcv on socket %p\n", sk);
+		ping_queue_rcv_skb(sk, skb_get(skb));
+		sock_put(sk);
+		return;
+	}
+	ping_debug("no socket, dropping\n");
+
+	/* We're called from icmp_rcv(). kfree_skb() is done there. */
+}
+
+struct proto ping_prot = {
+	.name =		"PING",
+	.owner =	THIS_MODULE,
+	.init =		ping_init_sock,
+	.close =	ping_close,
+	.connect =	ip4_datagram_connect,
+	.disconnect =	udp_disconnect,
+	.ioctl =	ping_ioctl,
+	.setsockopt =	ip_setsockopt,
+	.getsockopt =	ip_getsockopt,
+	.sendmsg =	ping_sendmsg,
+	.recvmsg =	ping_recvmsg,
+	.bind =		ping_bind,
+	.backlog_rcv =	ping_queue_rcv_skb,
+	.hash =		ping_v4_hash,
+	.unhash =	ping_v4_unhash,
+	.get_port =	ping_v4_get_port,
+	.obj_size =	sizeof(struct inet_sock),
+};
+EXPORT_SYMBOL(ping_prot);
+
+#ifdef CONFIG_PROC_FS
+
+static struct sock *ping_get_first(struct seq_file *seq, int start)
+{
+	struct sock *sk;
+	struct ping_iter_state *state = seq->private;
+	//struct ve_struct *net = seq_file_net(seq);
+	struct ve_struct *net = get_exec_env();
+
+	for (state->bucket = start; state->bucket < PING_HTABLE_SIZE;
+	     ++state->bucket) {
+		struct hlist_node *node;
+		struct hlist_head *hslot = &ping_table.hash[state->bucket];
+
+		sk_for_each(sk, node, hslot) {
+			if (ve_accessible(sk->owner_env, net))
+				goto found;
+		}
+	}
+	sk = NULL;
+found:
+	return sk;
+}
+
+static struct sock *ping_get_next(struct seq_file *seq, struct sock *sk)
+{
+	struct ping_iter_state *state = seq->private;
+
+	do {
+		sk = sk_next(sk);
+		if (!sk)
+			break;
+		if (ve_accessible(sk->owner_env, get_exec_env()))
+			break;
+	} while (1);
+
+	if (!sk)
+		return ping_get_first(seq, state->bucket + 1);
+	return sk;
+}
+
+static struct sock *ping_get_idx(struct seq_file *seq, loff_t pos)
+{
+	struct sock *sk = ping_get_first(seq, 0);
+
+	if (sk)
+		while (pos && (sk = ping_get_next(seq, sk)) != NULL)
+			--pos;
+	return pos ? NULL : sk;
+}
+
+static void *ping_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	struct ping_iter_state *state = seq->private;
+	state->bucket = 0;
+
+	read_lock_bh(&ping_table.lock);
+
+	return *pos ? ping_get_idx(seq, *pos-1) : SEQ_START_TOKEN;
+}
+
+static void *ping_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	struct sock *sk;
+
+	if (v == SEQ_START_TOKEN)
+		sk = ping_get_idx(seq, 0);
+	else
+		sk = ping_get_next(seq, v);
+
+	++*pos;
+	return sk;
+}
+
+static void ping_seq_stop(struct seq_file *seq, void *v)
+{
+	read_unlock_bh(&ping_table.lock);
+}
+
+static void ping_format_sock(struct sock *sp, struct seq_file *f,
+		int bucket, int *len)
+{
+	struct inet_sock *inet = inet_sk(sp);
+	__be32 dest = inet->daddr;
+	__be32 src = inet->rcv_saddr;
+	__u16 destp = ntohs(inet->dport);
+	__u16 srcp = ntohs(inet->sport);
+
+	seq_printf(f, "%5d: %08X:%04X %08X:%04X"
+		" %02X %08X:%08X %02X:%08lX %08X %5d %8d %lu %d %p %n",
+		bucket, src, srcp, dest, destp, sp->sk_state,
+		atomic_read(&sp->sk_wmem_alloc),
+		atomic_read(&sp->sk_rmem_alloc),
+		0, 0L, 0, sock_i_uid(sp), 0, sock_i_ino(sp),
+		atomic_read(&sp->sk_refcnt), sp,
+		len);
+}
+
+static int ping_seq_show(struct seq_file *seq, void *v)
+{
+	if (v == SEQ_START_TOKEN)
+		seq_printf(seq, "%-127s\n",
+			   "  sl  local_address rem_address   st tx_queue "
+			   "rx_queue tr tm->when retrnsmt   uid  timeout "
+			   "inode ref pointer drops");
+	else {
+		struct ping_iter_state *state = seq->private;
+		int len;
+
+		ping_format_sock(v, seq, state->bucket, &len);
+		seq_printf(seq, "%*s\n", 127 - len, "");
+	}
+	return 0;
+}
+
+static struct seq_operations ping_seq_ops = {
+	.show		= ping_seq_show,
+	.start		= ping_seq_start,
+	.next		= ping_seq_next,
+	.stop		= ping_seq_stop,
+};
+
+static int ping_seq_open(struct inode *inode, struct file *file)
+{
+	int rc = -ENOMEM;
+	struct seq_file *seq;
+	struct ping_iter_state *s = kzalloc(sizeof(*s), GFP_KERNEL);
+
+	if (!s)
+		goto out;
+
+	rc = seq_open(file, &ping_seq_ops);
+	if (rc)
+		goto out_kfree;
+
+	seq	     = file->private_data;
+	seq->private = s;
+out:
+	return rc;
+out_kfree:
+	kfree(s);
+	goto out;
+}
+
+static struct file_operations ping_seq_fops = {
+	.owner		= THIS_MODULE,
+	.open		= ping_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release_private,
+};
+
+static const char ping_proc_name[] = "net/icmp";
+
+static int ping_proc_register(void)
+{
+	struct proc_dir_entry *p;
+	int rc = 0;
+
+	p = proc_glob_fops_create(ping_proc_name, S_IRUGO,
+			     &ping_seq_fops);
+	if (!p)
+		rc = -ENOMEM;
+	return rc;
+}
+
+static void ping_proc_unregister(void)
+{
+	remove_proc_glob_entry(ping_proc_name, NULL);
+}
+
+static int ping_proc_init_net(void)
+{
+	return ping_proc_register();
+}
+
+static void ping_proc_exit_net(void)
+{
+	ping_proc_unregister();
+}
+
+#if 0
+static struct pernet_operations ping_net_ops = {
+	.init = ping_proc_init_net,
+	.exit = ping_proc_exit_net,
+};
+#endif
+
+int __init ping_proc_init(void)
+{
+	return ping_proc_init_net();
+}
+
+void ping_proc_exit(void)
+{
+	ping_proc_exit_net();
+}
+
+#endif
+
+void __init ping_init(void)
+{
+	int i;
+
+	for (i = 0; i < PING_HTABLE_SIZE; i++)
+		INIT_HLIST_HEAD(&ping_table.hash[i]);
+	rwlock_init(&ping_table.lock);
+}
diff -uNrp linux-2.6.18.orig/net/ipv4/sysctl_net_ipv4.c linux-2.6.18/net/ipv4/sysctl_net_ipv4.c
--- linux-2.6.18.orig/net/ipv4/sysctl_net_ipv4.c	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/net/ipv4/sysctl_net_ipv4.c	2011-03-04 17:48:35 +0000
@@ -16,6 +16,7 @@
 #include <net/snmp.h>
 #include <net/icmp.h>
 #include <net/ip.h>
+#include <net/ping.h>
 #include <net/route.h>
 #include <net/tcp.h>
 #include <net/udp.h>
@@ -250,6 +251,13 @@ ctl_table ipv4_table[] = {
 		.proc_handler	= &ipv4_sysctl_forward,
 		.strategy	= &ipv4_sysctl_forward_strategy
 	},
+	{
+		.ctl_name	= NET_PING_GROUP_RANGE,
+		.procname	= "ping_group_range",
+		.maxlen		= sizeof(int)*2,
+		.mode		= 0644,
+		.proc_handler	= &ipv4_ping_group_range,
+	},
         {
 		.ctl_name	= NET_IPV4_DEFAULT_TTL,
 		.procname	= "ip_default_ttl",
diff -uNrp linux-2.6.18.orig/net/socket.c linux-2.6.18/net/socket.c
--- linux-2.6.18.orig/net/socket.c	2011-03-04 01:59:46 +0000
+++ linux-2.6.18/net/socket.c	2011-03-04 17:48:35 +0000
@@ -1171,6 +1171,7 @@ int vz_security_protocol_check(int proto
 	case  IPPROTO_TCP:
 	case  IPPROTO_UDP:
 	case  IPPROTO_RAW:
+	case  IPPROTO_ICMP:
 		break;
 	default:
 		return -EAFNOSUPPORT;
diff -uNrp linux-2.6.18.orig/include/net/sock.h linux-2.6.18/include/net/sock.h
--- linux-2.6.18.orig/include/net/sock.h	2011-03-05 09:54:10 +0000
+++ linux-2.6.18/include/net/sock.h	2011-03-05 09:58:01 +0000
@@ -495,27 +495,6 @@ static inline void __sk_add_backlog(stru
 	skb->next = NULL;
 }
 
-/*
- * Take into account size of receive queue and backlog queue
- */
-static inline bool sk_rcvqueues_full(const struct sock *sk, const struct sk_buff *skb)
-{
-	unsigned int qsize = sk_extended(sk)->sk_backlog.len +
-			     atomic_read(&sk->sk_rmem_alloc);
-
-	return qsize + skb->truesize > sk->sk_rcvbuf;
-}
-
-/* The per-socket spinlock must be held here. */
-static inline __must_check int sk_add_backlog(struct sock *sk, struct sk_buff *skb)
-{
-	if (sk_rcvqueues_full(sk, skb))
-		return -ENOBUFS;
-
-	__sk_add_backlog(sk, skb);
-	sk_extended(sk)->sk_backlog.len += skb->truesize;
-	return 0;
-}
 
 #define sk_wait_event(__sk, __timeo, __condition)		\
 ({	int rc;							\
@@ -644,6 +623,28 @@ static inline struct sock_extended *sk_e
 	return (struct sock_extended *) (((char *) sk) + extended_offset);
 }
 
+/*
+ * Take into account size of receive queue and backlog queue
+ */
+static inline bool sk_rcvqueues_full(const struct sock *sk, const struct sk_buff *skb)
+{
+	unsigned int qsize = sk_extended(sk)->sk_backlog.len +
+			     atomic_read(&sk->sk_rmem_alloc);
+
+	return qsize + skb->truesize > sk->sk_rcvbuf;
+}
+
+/* The per-socket spinlock must be held here. */
+static inline __must_check int sk_add_backlog(struct sock *sk, struct sk_buff *skb)
+{
+	if (sk_rcvqueues_full(sk, skb))
+		return -ENOBUFS;
+
+	__sk_add_backlog(sk, skb);
+	sk_extended(sk)->sk_backlog.len += skb->truesize;
+	return 0;
+}
+
 #ifdef SOCK_REFCNT_DEBUG
 static inline void sk_refcnt_debug_inc(struct sock *sk)
 {
diff -uNrp linux-2.6.18.orig/net/core/dev.c linux-2.6.18/net/core/dev.c
--- linux-2.6.18.orig/net/core/dev.c	2011-03-05 10:05:19 +0000
+++ linux-2.6.18/net/core/dev.c	2011-03-05 10:05:25 +0000
@@ -1566,6 +1566,7 @@ static inline int skb_checksum_setup_v4(
 	return skb_setup_csum_ptr(skb, skb->nh.iph->protocol);
 }
 
+#ifdef CONFIG_IPV6
 static inline int skb_checksum_setup_v6(struct sk_buff *skb)
 {
 	int ptr;
@@ -1585,14 +1586,17 @@ static inline int skb_checksum_setup_v6(
 	skb->h.raw = skb->data + ptr;
 	return skb_setup_csum_ptr(skb, nexthdr);
 }
+#endif
 
 inline int skb_checksum_setup(struct sk_buff *skb)
 {
 	if (skb->proto_csum_blank) {
 		if (skb->protocol == htons(ETH_P_IP))
 			return skb_checksum_setup_v4(skb);
+#ifdef CONFIG_IPV6
 		else if (skb->protocol == htons(ETH_P_IPV6))
 			return skb_checksum_setup_v6(skb);
+#endif
 		return -EPROTO;
 	}
 	return 0;
diff -uNrp linux-2.6.18.orig/arch/x86_64/vdso/vdso.lds.S linux-2.6.18/arch/x86_64/vdso/vdso.lds.S
--- linux-2.6.18.orig/arch/x86_64/vdso/vdso.lds.S	2011-03-07 10:02:26 +0000
+++ linux-2.6.18/arch/x86_64/vdso/vdso.lds.S	2011-03-09 10:23:08 +0000
@@ -35,7 +35,7 @@ SECTIONS
    .altinstructions : { *(.altinstructions) }                   :text
    .altinstr_replacement  : { *(.altinstr_replacement) }        :text
 
-   .note                  : { *(.note.*) }              :text :note
+   /* .note                  : { *(.note.*) }              :text :note */
    .eh_frame_hdr   : { *(.eh_frame_hdr) }       :text :eh_frame_hdr
    .eh_frame       : { KEEP (*(.eh_frame)) }    :text
    .dynamic        : { *(.dynamic) }            :text :dynamic
@@ -55,7 +55,7 @@ PHDRS
 {
   text PT_LOAD FILEHDR PHDRS FLAGS(5); /* PF_R|PF_X */
   dynamic PT_DYNAMIC FLAGS(4); /* PF_R */
-  note PT_NOTE FLAGS(4); /* PF_R */
+  /* note PT_NOTE FLAGS(4); */ /* PF_R */
   eh_frame_hdr 0x6474e550; /* PT_GNU_EH_FRAME, but ld doesn't match the name */
 }
 

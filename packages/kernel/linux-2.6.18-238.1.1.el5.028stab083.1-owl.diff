diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/Makefile linux-2.6.18-238.1.1.el5.028stab083.1-owl/Makefile
--- linux-2.6.18-238.1.1.el5.028stab083.1/Makefile	2011-01-25 10:00:04 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/Makefile	2011-01-29 15:23:51 +0000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 18
-EXTRAVERSION = -238.1.1.el5.028stab083.1
+EXTRAVERSION = -238.1.1.el5.028stab083.1.owl2
 RHEL_MAJOR = 5
 RHEL_MINOR = 6
 NAME=Avast! A bilge rat!
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/arch/i386/kernel/cpu/amd.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/arch/i386/kernel/cpu/amd.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/arch/i386/kernel/cpu/amd.c	2011-01-25 09:59:59 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/arch/i386/kernel/cpu/amd.c	2011-01-28 09:50:36 +0000
@@ -45,11 +45,14 @@ static void __cpuinit amd_fixup_dcm(stru
 	if (cpu_has(c, X86_FEATURE_AMD_DCM))
 		return;
 
+#if 0
+/* early_is_k8_nb() is only defined under arch/x86_64/ */
 	/* proceed only if there is a valid AMD northbridge
 	 * (not in virtualized environments!)
 	 */
 	if (!early_is_k8_nb(read_pci_config(0, 24, 3, 0x00)))
 		return;
+#endif
 
 	rdmsrl(0xc001100c, value);
 
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/arch/i386/kernel/cpu/intel_cacheinfo.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/arch/i386/kernel/cpu/intel_cacheinfo.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/arch/i386/kernel/cpu/intel_cacheinfo.c	2011-01-25 10:00:03 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/arch/i386/kernel/cpu/intel_cacheinfo.c	2011-01-28 09:50:36 +0000
@@ -47,10 +47,12 @@ static void wbinvd_on_cpu(int cpu)
 	smp_call_function_single(cpu, __wbinvd, NULL, 0, 1);
 }
 
+#if 0
 static int wbinvd_on_all_cpus(void)
 {
 	return on_each_cpu(__wbinvd, NULL, 0, 1);
 }
+#endif
 
 /* from arch/x86/kernel/cpu/amd.c upstream */
 static int amd_get_nb_id(int cpu)
@@ -335,9 +337,12 @@ amd_check_l3_disable(int index, struct _
 	    boot_cpu_data.x86_mask < 0x1)
 		return;
 
+#if 0
+/* num_k8_northbridges is only defined under arch/x86_64/ */
 	/* not in virtualized environments */
 	if (num_k8_northbridges == 0)
 		return;
+#endif
 
 	this_leaf->can_disable = true;
 	this_leaf->l3_indices  = amd_calc_l3_indices();
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/arch/x86_64/Kconfig linux-2.6.18-238.1.1.el5.028stab083.1-owl/arch/x86_64/Kconfig
--- linux-2.6.18-238.1.1.el5.028stab083.1/arch/x86_64/Kconfig	2011-01-25 10:00:03 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/arch/x86_64/Kconfig	2011-01-28 09:50:36 +0000
@@ -476,6 +476,7 @@ config IOMMU
 	default y
 	select SWIOTLB
 	select AGP
+	select IOMMU_HELPER
 	depends on PCI && !X86_64_XEN
 	help
 	  Support for full DMA access of devices with 32bit memory access only
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/arch/x86_64/kernel/genapic.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/arch/x86_64/kernel/genapic.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/arch/x86_64/kernel/genapic.c	2011-01-25 09:59:49 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/arch/x86_64/kernel/genapic.c	2011-01-29 15:24:51 +0000
@@ -67,7 +67,10 @@ void __init clustered_apic_check(void)
 				genapic = &apic_flat;
 		}
 #else
-		genapic = &apic_flat;
+		if (num_possible_cpus() > 8)
+			genapic = &apic_physflat;
+		else
+			genapic = &apic_flat;
 #endif
 	}
 
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/arch/x86_64/vdso/vma.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/arch/x86_64/vdso/vma.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/arch/x86_64/vdso/vma.c	2011-01-25 10:00:03 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/arch/x86_64/vdso/vma.c	2011-01-29 16:09:28 +0000
@@ -13,7 +13,7 @@
 #include <asm/proto.h>
 #include "voffset.h"
 
-int vdso_enabled = 1;
+int vdso_enabled = 0;
 
 #define VEXTERN(x) extern typeof(__ ## x) *vdso_ ## x;
 #include "vextern.h"
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/drivers/ata/Kconfig linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/ata/Kconfig
--- linux-2.6.18-238.1.1.el5.028stab083.1/drivers/ata/Kconfig	2011-01-25 09:59:52 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/ata/Kconfig	2011-01-28 10:18:59 +0000
@@ -447,8 +447,8 @@ config PATA_MARVELL
 	help
 	  This option enables limited support for the Marvell 88SE61xx ATA
 	  controllers. If you wish to use only the SATA ports then select
-	  the AHCI driver alone. If you wish to the use the PATA port or
-	  both SATA and PATA include this driver.
+	  the AHCI driver alone. If you wish to use the PATA port or both
+	  SATA and PATA include this driver.
 
 	  If unsure, say N.
 
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/drivers/ata/ahci.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/ata/ahci.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/drivers/ata/ahci.c	2011-01-25 10:00:00 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/ata/ahci.c	2011-01-28 10:21:56 +0000
@@ -791,7 +791,7 @@ static void ahci_save_initial_config(str
 			   port_map,
 			   port_map & mv);
 		dev_printk(KERN_ERR, &pdev->dev,
-			  "Disabling your PATA port. Use the boot option 'ahci.marvell_enable=0' to avoid this.\n");
+			  "Disabling your PATA port on the Marvell SATA/PATA controller, which is unsupported by the AHCI driver. Use the boot option 'ahci.marvell_enable=0' to avoid this and let the likely slower Marvell PATA driver take over, supporting both SATA and PATA ports.\n");
 
 		port_map &= mv;
 	}
@@ -2900,8 +2900,11 @@ static int ahci_init_one(struct pci_dev 
 	/* The AHCI driver can only drive the SATA ports, the PATA driver
 	   can drive them all so if both drivers are selected make sure
 	   AHCI stays out of the way */
-	if (pdev->vendor == PCI_VENDOR_ID_MARVELL && !marvell_enable)
+	if (pdev->vendor == PCI_VENDOR_ID_MARVELL && !marvell_enable) {
+		dev_printk(KERN_ERR, &pdev->dev,
+			  "Skipping the Marvell SATA/PATA controller in order to let the Marvell PATA driver take over. Use the boot option 'ahci.marvell_enable=1' to avoid this, likely gaining a bit of performance but losing support for your PATA port.\n");
 		return -ENODEV;
+	}
 
 	/* acquire resources */
 	rc = pcim_enable_device(pdev);
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/drivers/block/cciss.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/block/cciss.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/drivers/block/cciss.c	2011-01-25 09:59:58 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/block/cciss.c	2011-01-28 14:13:29 +0000
@@ -194,11 +194,40 @@ static void cciss_free_drive_info(ctlr_i
 static void cciss_clear_drive_info(drive_info_struct *drive_info);
 static void cciss_sysfs_stat_inquiry(int ctlr, int logvol,
 			drive_info_struct *drv);
-static inline void complete_pc_buffers(struct bio *bio,
-	unsigned int nr_bytes, int status);
-static inline void complete_fs_buffers(struct bio *bio, int status);
 static unsigned int blk_rq_bytes(struct request *rq);
 
+static inline void complete_pc_buffers(struct bio *bio,
+	unsigned int nr_bytes, int status)
+{
+	unsigned int bytes_remaining = nr_bytes;
+
+	while (bio) {
+		struct bio *xbh = bio->bi_next;
+		unsigned int bytes_in_this_bio = bio_sectors(bio) << 9;
+
+		if (bytes_in_this_bio > bytes_remaining)
+			bytes_in_this_bio = bytes_remaining;
+
+		bio->bi_next = NULL;
+		bio_endio(bio, bytes_in_this_bio, status ? 0 : -EIO);
+		bio = xbh;
+
+		bytes_remaining -= bytes_in_this_bio;
+	}
+}
+
+static inline void complete_fs_buffers(struct bio *bio, int status)
+{
+	while (bio) {
+		struct bio *xbh = bio->bi_next;
+		unsigned int nr_bytes = bio_sectors(bio) << 9;
+ 
+		bio->bi_next = NULL;
+		bio_endio(bio, nr_bytes, status ? 0 : -EIO);
+		bio = xbh;
+	}
+}
+
 #ifdef CONFIG_PROC_FS
 static void cciss_procinit(int i);
 #else
@@ -4460,38 +4489,6 @@ err:
 
 }
 
-static inline void complete_pc_buffers(struct bio *bio,
-	unsigned int nr_bytes, int status)
-{
-	unsigned int bytes_remaining = nr_bytes;
-
-	while (bio) {
-		struct bio *xbh = bio->bi_next;
-		unsigned int bytes_in_this_bio = bio_sectors(bio) << 9;
-
-		if (bytes_in_this_bio > bytes_remaining)
-			bytes_in_this_bio = bytes_remaining;
-
-		bio->bi_next = NULL;
-		bio_endio(bio, bytes_in_this_bio, status ? 0 : -EIO);
-		bio = xbh;
-
-		bytes_remaining -= bytes_in_this_bio;
-	}
-}
-
-static inline void complete_fs_buffers(struct bio *bio, int status)
-{
-	while (bio) {
-		struct bio *xbh = bio->bi_next;
-		unsigned int nr_bytes = bio_sectors(bio) << 9;
- 
-		bio->bi_next = NULL;
-		bio_endio(bio, nr_bytes, status ? 0 : -EIO);
-		bio = xbh;
-	}
-}
-
 /**
  * blk_rq_bytes - Returns bytes left to complete in the entire request
  * @rq: the request being processed
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/drivers/char/keyboard.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/char/keyboard.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/drivers/char/keyboard.c	2011-01-25 10:00:03 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/char/keyboard.c	2011-01-28 09:50:36 +0000
@@ -1376,7 +1376,7 @@ int __init kbd_init(void)
 		kbd_table[i].lockstate = KBD_DEFLOCK;
 		kbd_table[i].slockstate = 0;
 		kbd_table[i].modeflags = KBD_DEFMODE;
-		kbd_table[i].kbdmode = VC_UNICODE;
+		kbd_table[i].kbdmode = VC_XLATE;
 	}
 
 	input_register_handler(&kbd_handler);
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/drivers/char/vt.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/char/vt.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/drivers/char/vt.c	2011-01-25 09:59:48 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/char/vt.c	2011-01-28 09:50:36 +0000
@@ -1497,7 +1497,7 @@ static void reset_terminal(struct vc_dat
 	vc->vc_charset		= 0;
 	vc->vc_need_wrap	= 0;
 	vc->vc_report_mouse	= 0;
-	vc->vc_utf		= 1;
+	vc->vc_utf		= 0;
 	vc->vc_utf_count	= 0;
 
 	vc->vc_disp_ctrl	= 0;
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/drivers/dca/Kconfig linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/dca/Kconfig
--- linux-2.6.18-238.1.1.el5.028stab083.1/drivers/dca/Kconfig	2011-01-25 09:59:32 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/dca/Kconfig	2011-01-28 09:50:36 +0000
@@ -3,7 +3,7 @@
 #
 
 config DCA
-	tristate
+	tristate "DCA server configuration"
 	depends on DMA_ENGINE_V3 && PCI
 	default m
 	---help---
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/drivers/message/fusion/mptsas.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/message/fusion/mptsas.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/drivers/message/fusion/mptsas.c	2011-01-25 09:59:53 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/message/fusion/mptsas.c	2011-01-28 09:50:36 +0000
@@ -436,6 +436,23 @@ mptsas_is_end_device(struct mptsas_devin
 		return 0;
 }
 
+static inline void
+mptsas_set_rphy(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_rphy *rphy)
+{
+	if (phy_info->port_details) {
+		phy_info->port_details->rphy = rphy;
+		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "sas_rphy_add: rphy=%p\n",
+		    ioc->name, rphy));
+	}
+
+	if (rphy) {
+		dsaswideprintk(ioc, dev_printk(KERN_DEBUG,
+		    &rphy->dev, MYIOC_s_FMT "add:", ioc->name));
+		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "rphy=%p release=%p\n",
+		    ioc->name, rphy, rphy->dev.release));
+	}
+}
+
 /* no mutex */
 static void
 mptsas_port_delete(MPT_ADAPTER *ioc, struct mptsas_portinfo_details * port_details)
@@ -474,23 +491,6 @@ mptsas_get_rphy(struct mptsas_phyinfo *p
 		return NULL;
 }
 
-static inline void
-mptsas_set_rphy(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_rphy *rphy)
-{
-	if (phy_info->port_details) {
-		phy_info->port_details->rphy = rphy;
-		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "sas_rphy_add: rphy=%p\n",
-		    ioc->name, rphy));
-	}
-
-	if (rphy) {
-		dsaswideprintk(ioc, dev_printk(KERN_DEBUG,
-		    &rphy->dev, MYIOC_s_FMT "add:", ioc->name));
-		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "rphy=%p release=%p\n",
-		    ioc->name, rphy, rphy->dev.release));
-	}
-}
-
 static inline struct sas_port *
 mptsas_get_port(struct mptsas_phyinfo *phy_info)
 {
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/drivers/net/Kconfig linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/net/Kconfig
--- linux-2.6.18-238.1.1.el5.028stab083.1/drivers/net/Kconfig	2011-01-25 10:00:04 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/drivers/net/Kconfig	2011-01-28 13:50:16 +0000
@@ -2615,6 +2615,8 @@ config NIU
 config BNX2X
 	tristate "Broadcom NetXtremeII 10Gb support"
 	depends on PCI
+	select CRYPTO_CRC32C
+	select MDIO
 	help
 	  This driver supports Broadcom NetXtremeII 10 gigabit Ethernet cards.
 	  To compile this driver as a module, choose M here: the module
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/fs/Kconfig linux-2.6.18-238.1.1.el5.028stab083.1-owl/fs/Kconfig
--- linux-2.6.18-238.1.1.el5.028stab083.1/fs/Kconfig	2011-01-25 10:00:04 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/fs/Kconfig	2011-01-28 09:50:36 +0000
@@ -473,6 +473,7 @@ config QFMT_V2
 config SIM_FS
 	tristate "VPS filesystem"
 	depends on VZ_QUOTA
+	select EXPORTFS
 	default m
 	help
 	  This file system is a part of Virtuozzo. It intoduces a fake
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/fs/exec.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/fs/exec.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/fs/exec.c	2011-01-25 10:00:03 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/fs/exec.c	2011-01-28 09:50:36 +0000
@@ -231,7 +231,8 @@ struct page *get_arg_page(struct linux_b
 		 *  - the program will have a reasonable amount of stack left
 		 *    to work from.
 		 */
-		if (size > rlim[RLIMIT_STACK].rlim_cur / 4) {
+		if (size > rlim[RLIMIT_STACK].rlim_cur / 4 ||
+		    size > MAX_ARG_STACK) {
 			put_page(page);
 			return NULL;
 		}
@@ -286,7 +287,10 @@ static int __bprm_mm_init(struct linux_b
 
 	vma->vm_flags = VM_STACK_FLAGS;
 	vma->vm_page_prot = protection_map[vma->vm_flags & 0x7];
-	err = insert_vm_struct(mm, vma);
+
+	err = security_file_mmap_addr(NULL, 0, 0, 0, vma->vm_start, 1);
+	if (!err)
+		err = insert_vm_struct(mm, vma);
 	if (err) {
 		up_write(&mm->mmap_sem);
 		goto err;
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/fs/proc/base.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/fs/proc/base.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/fs/proc/base.c	2011-01-25 10:00:03 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/fs/proc/base.c	2011-01-28 09:50:36 +0000
@@ -273,10 +273,10 @@ static struct pid_entry tgid_base_stuff[
 	  S_IFREG|S_IRUGO|S_IWUSR),
 #endif
 #ifdef CONFIG_TASK_IO_ACCOUNTING
-	E(PROC_TGID_IO,             "io",  S_IFREG|S_IRUGO),
+	E(PROC_TGID_IO,             "io",  S_IFREG|S_IRUSR),
 #endif
 #ifdef CONFIG_STACKTRACE_PROC
-	E(PROC_TGID_STACK,     "stack",   S_IFREG|S_IRUGO),
+	E(PROC_TGID_STACK,     "stack",   S_IFREG|S_IRUSR),
 #endif
 
 	{0,0,NULL,0}
@@ -324,10 +324,10 @@ static struct pid_entry tid_base_stuff[]
 #endif
 	E(PROC_TID_LIMITS, "limits", S_IFREG|S_IRUGO),
 #ifdef CONFIG_TASK_IO_ACCOUNTING
-	E(PROC_TID_IO,         "io",      S_IFREG|S_IRUGO),
+	E(PROC_TID_IO,         "io",      S_IFREG|S_IRUSR),
 #endif
 #ifdef CONFIG_STACKTRACE_PROC
-	E(PROC_TID_STACK,      "stack",   S_IFREG|S_IRUGO),
+	E(PROC_TID_STACK,      "stack",   S_IFREG|S_IRUSR),
 #endif
 
 	{0,0,NULL,0}
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/fs/sysfs/inode.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/fs/sysfs/inode.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/fs/sysfs/inode.c	2011-01-25 10:00:03 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/fs/sysfs/inode.c	2011-01-28 14:11:57 +0000
@@ -16,7 +16,15 @@
 #include <linux/security.h>
 #include "sysfs.h"
 
-static inline void set_inode_attr(struct inode * inode, struct iattr * iattr);
+static inline void set_inode_attr(struct inode * inode, struct iattr * iattr)
+{
+	inode->i_mode = iattr->ia_mode;
+	inode->i_uid = iattr->ia_uid;
+	inode->i_gid = iattr->ia_gid;
+	inode->i_atime = iattr->ia_atime;
+	inode->i_mtime = iattr->ia_mtime;
+	inode->i_ctime = iattr->ia_ctime;
+}
 
 static const struct address_space_operations sysfs_aops = {
 	.readpage	= simple_readpage,
@@ -189,16 +197,6 @@ static inline void set_default_inode_att
 	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 }
 
-static inline void set_inode_attr(struct inode * inode, struct iattr * iattr)
-{
-	inode->i_mode = iattr->ia_mode;
-	inode->i_uid = iattr->ia_uid;
-	inode->i_gid = iattr->ia_gid;
-	inode->i_atime = iattr->ia_atime;
-	inode->i_mtime = iattr->ia_mtime;
-	inode->i_ctime = iattr->ia_ctime;
-}
-
 /*
  * sysfs has a different i_mutex lock order behavior for i_mutex than other
  * filesystems; sysfs i_mutex is called in many places with subsystem locks
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/include/linux/binfmts.h linux-2.6.18-238.1.1.el5.028stab083.1-owl/include/linux/binfmts.h
--- linux-2.6.18-238.1.1.el5.028stab083.1/include/linux/binfmts.h	2011-01-25 10:00:03 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/include/linux/binfmts.h	2011-01-28 09:50:36 +0000
@@ -13,7 +13,8 @@ struct pt_regs;
  */
 #define MAX_ARG_PAGES 32
 #define MAX_ARG_STRLEN (PAGE_SIZE * 32)
-#define MAX_ARG_STRINGS 0x7FFFFFFF
+#define MAX_ARG_STACK (0xC0000000UL / 4)
+#define MAX_ARG_STRINGS (MAX_ARG_STACK / 5)
 
 /* sizeof(linux_binprm->buf) */
 #define BINPRM_BUF_SIZE 128
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/include/linux/compat.h linux-2.6.18-238.1.1.el5.028stab083.1-owl/include/linux/compat.h
--- linux-2.6.18-238.1.1.el5.028stab083.1/include/linux/compat.h	2011-01-25 10:00:03 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/include/linux/compat.h	2011-01-28 09:50:36 +0000
@@ -263,5 +263,6 @@ asmlinkage long compat_sys_epoll_pwait(i
 asmlinkage long compat_sys_signalfd(int ufd,
 				const compat_sigset_t __user *sigmask,
 				compat_size_t sigsetsize);
+
 #endif /* CONFIG_COMPAT */
 #endif /* _LINUX_COMPAT_H */
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/include/linux/dmar.h linux-2.6.18-238.1.1.el5.028stab083.1-owl/include/linux/dmar.h
--- linux-2.6.18-238.1.1.el5.028stab083.1/include/linux/dmar.h	2011-01-25 09:59:43 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/include/linux/dmar.h	2011-01-28 09:50:36 +0000
@@ -125,10 +125,6 @@ extern int irq_remapped(int irq);
 extern struct intel_iommu *map_dev_to_ir(struct pci_dev *dev);
 extern struct intel_iommu *map_ioapic_to_ir(int apic);
 #else
-static inline int enable_drhd_fault_handling(void)
-{
-	return -1;
-}
 static inline int alloc_irte(struct intel_iommu *iommu, int irq, u16 count)
 {
 	return -1;
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/init/do_mounts.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/init/do_mounts.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/init/do_mounts.c	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/init/do_mounts.c	2010-08-29 20:46:04 +0000
@@ -13,6 +13,10 @@
 #include <linux/nfs_fs_sb.h>
 #include <linux/nfs_mount.h>
 
+#ifdef CONFIG_BLK_DEV_IDECD
+#include <linux/ide.h>
+#endif
+
 #include "do_mounts.h"
 
 extern int get_filesystem_list(char * buf);
@@ -267,10 +271,63 @@ static void __init get_fs_names(char *pa
 
 static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 {
-	int err = sys_mount(name, "/root", fs, flags, data);
+	int err = -ENODEV;
+
+	if (!strcmp(saved_root_name, "/dev/cdrom")) {
+		char realname[10];
+#ifdef CONFIG_BLK_DEV_IDECD
+		int h, unit;
+		for (h = 0; h < MAX_HWIFS; h++) {
+			ide_hwif_t *hwif = &ide_hwifs[h];
+			if (!hwif->present)
+				continue;
+			for (unit = 0; unit < MAX_DRIVES; unit++) {
+				ide_drive_t *drive = &hwif->drives[unit];
+				if (!drive->present ||
+				    drive->media != ide_cdrom)
+					continue;
+				snprintf(realname, sizeof(realname),
+				    "/dev/%s", drive->name);
+				printk(KERN_INFO "Trying to mount %s...\n",
+				    realname);
+				create_dev(name,
+				    MKDEV(hwif->major, unit << PARTN_BITS));
+				err = sys_mount(name, "/root", fs, flags, data);
+				if (!err)
+					goto ok;
+			}
+		}
+#endif
+#ifdef CONFIG_BLK_DEV_SR
+		strcpy(realname, "/dev/scd0");
+		while (realname[8] < '8') {
+			int retries = root_delay;
+retry:
+			printk(KERN_INFO "Trying to mount %s...\n", realname);
+			if (retries == root_delay)
+				create_dev(name,
+				    MKDEV(SCSI_CDROM_MAJOR, realname[8] - '0'));
+			err = sys_mount(name, "/root", fs, flags, data);
+			if (!err)
+				goto ok;
+			if (err == -ENXIO || err == -ENODEV) {
+				if (retries-- <= 0)
+					return err;
+				printk(KERN_INFO "Retrying in 1 sec...\n");
+				ssleep(1);
+				goto retry;
+			}
+			realname[8]++;
+		}
+#endif
+		return err;
+	}
+
+	err = sys_mount(name, "/root", fs, flags, data);
 	if (err)
 		return err;
 
+ok:
 	sys_chdir("/root");
 	ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
 	printk("VFS: Mounted root (%s filesystem)%s.\n",
@@ -397,7 +454,7 @@ void __init prepare_namespace(void)
 {
 	int is_floppy;
 
-	if (root_delay) {
+	if (root_delay && strcmp(saved_root_name, "/dev/cdrom")) {
 		printk(KERN_INFO "Waiting %dsec before mounting root device...\n",
 		       root_delay);
 		ssleep(root_delay);
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/init/do_mounts_md.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/init/do_mounts_md.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/init/do_mounts_md.c	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/init/do_mounts_md.c	2007-10-03 03:57:50 +0000
@@ -122,6 +122,7 @@ static void __init md_setup_drive(void)
 
 	for (ent = 0; ent < md_setup_ents ; ent++) {
 		int fd;
+		int disknum = 0;
 		int err = 0;
 		char *devname;
 		mdu_disk_info_t dinfo;
@@ -144,7 +145,7 @@ static void __init md_setup_drive(void)
 
 			p = strchr(devname, ',');
 			if (p)
-				*p++ = 0;
+				*p = 0;
 
 			dev = name_to_dev_t(devname);
 			if (strncmp(devname, "/dev/", 5) == 0)
@@ -154,17 +155,22 @@ static void __init md_setup_drive(void)
 			if (rdev)
 				dev = new_decode_dev(rdev);
 			if (!dev) {
-				printk(KERN_WARNING "md: Unknown device name: %s\n", devname);
-				break;
+				printk(KERN_WARNING "md: Skipping unknown device name: %s\n", devname);
+				if (p)
+					*p++ = ',';
+				devname = p;
+				continue;
 			}
 
-			devices[i] = dev;
+			devices[disknum++] = dev;
 
+			if (p)
+				*p++ = ',';
 			devname = p;
 		}
-		devices[i] = 0;
+		devices[disknum] = 0;
 
-		if (!i)
+		if (!disknum)
 			continue;
 
 		printk(KERN_INFO "md: Loading md%s%d: %s\n",
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/kernel/exit.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/kernel/exit.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/kernel/exit.c	2011-01-25 10:00:04 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/kernel/exit.c	2011-01-28 09:50:36 +0000
@@ -957,12 +957,28 @@ fastcall NORET_TYPE void do_exit(long co
 	int group_dead;
 	unsigned int mycpu;
 
+	/*
+	 * Check this first since set_fs() below depends on
+	 * current_thread_info(), which we better not access when we're in
+	 * interrupt context.  Other than that, we want to do the set_fs()
+	 * as early as possible.
+	 */
+	if (unlikely(in_interrupt()))
+		panic("Aiee, killing interrupt handler!");
+
+	/*
+	 * If do_exit is called because this process Oops'ed, it's possible
+	 * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before
+	 * continuing. Amongst other possible reasons, this is to prevent
+	 * mm_release()->clear_child_tid() from writing to a user-controlled
+	 * kernel address.
+	 */
+	set_fs(USER_DS);
+
 	profile_task_exit(tsk);
 
 	WARN_ON(atomic_read(&tsk->fs_excl));
 
-	if (unlikely(in_interrupt()))
-		panic("Aiee, killing interrupt handler!");
 	if (unlikely(!tsk->pid))
 		panic("Attempted to kill the idle task!");
 #ifdef CONFIG_VE
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/kernel/kallsyms.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/kernel/kallsyms.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/kernel/kallsyms.c	2011-01-25 10:00:04 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/kernel/kallsyms.c	2011-01-28 09:50:36 +0000
@@ -421,7 +421,7 @@ static int __init kallsyms_init(void)
 {
 	struct proc_dir_entry *entry;
 
-	entry = create_proc_entry("kallsyms", 0444, NULL);
+	entry = create_proc_entry("kallsyms", 0400, NULL);
 	if (entry)
 		entry->proc_fops = &kallsyms_operations;
 	return 0;
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/kernel/panic.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/kernel/panic.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/kernel/panic.c	2011-01-25 10:00:04 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/kernel/panic.c	2011-01-28 09:50:36 +0000
@@ -20,7 +20,7 @@
 #include <linux/kexec.h>
 #include <linux/debug_locks.h>
 
-int panic_on_oops = 1;
+int panic_on_oops;
 int tainted = 1;
 static int pause_on_oops;
 static int pause_on_oops_flag;
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/kernel/printk.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/kernel/printk.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/kernel/printk.c	2011-01-25 10:00:04 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/kernel/printk.c	2011-01-28 10:31:56 +0000
@@ -255,10 +255,6 @@ int do_syslog(int type, char __user *buf
 	if (!ve_is_super(get_exec_env()) && (type == 6 || type == 7))
 		goto out;
 
-	error = security_syslog(type);
-	if (error)
-		return error;
-
 	switch (type) {
 	case 0:		/* Close log */
 		break;
@@ -390,6 +386,12 @@ out:
 
 asmlinkage long sys_syslog(int type, char __user *buf, int len)
 {
+	int error;
+
+	error = security_syslog(type);
+	if (error)
+		return error;
+		
 	return do_syslog(type, buf, len);
 }
 
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/mm/mmap.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/mm/mmap.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/mm/mmap.c	2011-01-25 10:00:04 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/mm/mmap.c	2011-01-28 09:50:36 +0000
@@ -2395,6 +2395,11 @@ int install_special_mapping(struct mm_st
 	vma->vm_ops = &special_mapping_vmops;
 	vma->vm_private_data = pages;
 
+	if (unlikely(security_file_mmap_addr(NULL, 0, 0, 0, vma->vm_start, 1))) {
+		kmem_cache_free(vm_area_cachep, vma);
+		return -EPERM;
+	}
+
 	if (unlikely(insert_vm_struct(mm, vma))) {
 		kmem_cache_free(vm_area_cachep, vma);
 		return -ENOMEM;
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/net/core/ethtool.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/net/core/ethtool.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/net/core/ethtool.c	2011-01-25 10:00:04 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/net/core/ethtool.c	2011-01-28 10:51:00 +0000
@@ -183,7 +183,7 @@ static int ethtool_get_regs(struct net_d
 	if (regs.len > reglen)
 		regs.len = reglen;
 
-	regbuf = kmalloc(reglen, GFP_USER);
+	regbuf = kzalloc(reglen, GFP_USER);
 	if (!regbuf)
 		return -ENOMEM;
 
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/net/llc/af_llc.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/net/llc/af_llc.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/net/llc/af_llc.c	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/net/llc/af_llc.c	2009-08-26 10:16:29 +0000
@@ -155,6 +155,9 @@ static int llc_ui_create(struct socket *
 	struct sock *sk;
 	int rc = -ESOCKTNOSUPPORT;
 
+	if (!capable(CAP_NET_RAW))
+		return -EPERM;
+
 	if (likely(sock->type == SOCK_DGRAM || sock->type == SOCK_STREAM)) {
 		rc = -ENOMEM;
 		sk = llc_sk_alloc(PF_LLC, GFP_KERNEL, &llc_proto);
@@ -911,6 +914,7 @@ static int llc_ui_getname(struct socket 
 	struct llc_sock *llc = llc_sk(sk);
 	int rc = 0;
 
+	memset(&sllc, 0, sizeof(sllc));
 	lock_sock(sk);
 	if (sock_flag(sk, SOCK_ZAPPED))
 		goto out;
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/scripts/mkcompile_h linux-2.6.18-238.1.1.el5.028stab083.1-owl/scripts/mkcompile_h
--- linux-2.6.18-238.1.1.el5.028stab083.1/scripts/mkcompile_h	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/scripts/mkcompile_h	2009-03-01 05:35:12 +0000
@@ -47,17 +47,9 @@ UTS_TRUNCATE="sed -e s/\(.\{1,$UTS_LEN\}
   echo \#define UTS_VERSION \"`echo $UTS_VERSION | $UTS_TRUNCATE`\"
 
   echo \#define LINUX_COMPILE_TIME \"`LC_ALL=C LANG=C date +%T`\"
-  echo \#define LINUX_COMPILE_BY \"`whoami`\"
-  echo \#define LINUX_COMPILE_HOST \"`hostname | $UTS_TRUNCATE`\"
-
-  if [ -x /bin/dnsdomainname ]; then
-    echo \#define LINUX_COMPILE_DOMAIN \"`dnsdomainname | $UTS_TRUNCATE`\"
-  elif [ -x /bin/domainname ]; then
-    echo \#define LINUX_COMPILE_DOMAIN \"`domainname | $UTS_TRUNCATE`\"
-  else
-    echo \#define LINUX_COMPILE_DOMAIN
-  fi
-
+  echo \#define LINUX_COMPILE_BY \"sources\"
+  echo \#define LINUX_COMPILE_HOST \"${ARCH}.example.org\"
+  echo \#define LINUX_COMPILE_DOMAIN \"\"
   echo \#define LINUX_COMPILER \"`$CC -v 2>&1 | tail -n 1`\"
 ) > .tmpcompile
 
diff -urp linux-2.6.18-238.1.1.el5.028stab083.1/security/min_addr.c linux-2.6.18-238.1.1.el5.028stab083.1-owl/security/min_addr.c
--- linux-2.6.18-238.1.1.el5.028stab083.1/security/min_addr.c	2011-01-25 10:00:04 +0000
+++ linux-2.6.18-238.1.1.el5.028stab083.1-owl/security/min_addr.c	2011-01-28 09:50:36 +0000
@@ -5,9 +5,9 @@
 #include <linux/sysctl.h>
 
 /* amount of vm to protect from userspace access by both DAC and the LSM*/
-unsigned long mmap_min_addr;
+unsigned long mmap_min_addr = 98304;
 /* amount of vm to protect from userspace using CAP_SYS_RAWIO (DAC) */
-unsigned long dac_mmap_min_addr = 4096;
+unsigned long dac_mmap_min_addr = 98304;
 /* amount of vm to protect from userspace using the LSM = CONFIG_LSM_MMAP_MIN_ADDR */
 
 /*

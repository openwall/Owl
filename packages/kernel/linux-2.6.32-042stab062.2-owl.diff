diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/ia32/ia32entry.S linux-2.6.32/arch/x86/ia32/ia32entry.S
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/ia32/ia32entry.S	2012-10-18 14:08:46.372774678 +0400
+++ linux-2.6.32/arch/x86/ia32/ia32entry.S	2012-10-18 14:09:23.880775683 +0400
@@ -157,7 +157,7 @@ ENTRY(ia32_sysenter_target)
  	.previous	
 	GET_THREAD_INFO(%r10)
 	orl    $TS_COMPAT,TI_status(%r10)
-	testl  $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r10)
+	testl  $_TIF_WORK_SYSCALL_ENTRY_32,TI_flags(%r10)
 	CFI_REMEMBER_STATE
 	jnz  sysenter_tracesys
 	cmpq	$(IA32_NR_syscalls-1),%rax
@@ -246,7 +246,7 @@ sysexit_audit:
 
 sysenter_tracesys:
 #ifdef CONFIG_AUDITSYSCALL
-	testl	$(_TIF_WORK_SYSCALL_ENTRY & ~_TIF_SYSCALL_AUDIT),TI_flags(%r10)
+	testl	$(_TIF_WORK_SYSCALL_ENTRY_32 & ~_TIF_SYSCALL_AUDIT),TI_flags(%r10)
 	jz	sysenter_auditsys
 #endif
 	SAVE_REST
@@ -319,7 +319,7 @@ ENTRY(ia32_cstar_target)
 	.previous	
 	GET_THREAD_INFO(%r10)
 	orl   $TS_COMPAT,TI_status(%r10)
-	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r10)
+	testl $_TIF_WORK_SYSCALL_ENTRY_32,TI_flags(%r10)
 	CFI_REMEMBER_STATE
 	jnz   cstar_tracesys
 	cmpq $IA32_NR_syscalls-1,%rax
@@ -363,7 +363,7 @@ sysretl_audit:
 
 cstar_tracesys:
 #ifdef CONFIG_AUDITSYSCALL
-	testl $(_TIF_WORK_SYSCALL_ENTRY & ~_TIF_SYSCALL_AUDIT),TI_flags(%r10)
+	testl $(_TIF_WORK_SYSCALL_ENTRY_32 & ~_TIF_SYSCALL_AUDIT),TI_flags(%r10)
 	jz cstar_auditsys
 #endif
 	xchgl %r9d,%ebp
@@ -431,7 +431,7 @@ ENTRY(ia32_syscall)
 	SAVE_ARGS 0,0,1
 	GET_THREAD_INFO(%r10)
 	orl   $TS_COMPAT,TI_status(%r10)
-	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r10)
+	testl $_TIF_WORK_SYSCALL_ENTRY_32,TI_flags(%r10)
 	jnz ia32_tracesys
 	cmpq $(IA32_NR_syscalls-1),%rax
 	ja ia32_badsys
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/include/asm/elf.h linux-2.6.32/arch/x86/include/asm/elf.h
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/include/asm/elf.h	2012-10-18 14:08:46.380774679 +0400
+++ linux-2.6.32/arch/x86/include/asm/elf.h	2012-10-18 14:09:23.880775683 +0400
@@ -346,6 +346,12 @@ extern int syscall32_setup_pages(struct
 extern unsigned long arch_randomize_brk(struct mm_struct *mm);
 #define arch_randomize_brk arch_randomize_brk
 
+extern void arch_post_exec_elf(int retval, int elf_class);
+#define arch_post_exec_elf arch_post_exec_elf
+
+extern void arch_post_execve(void);
+#define arch_post_execve arch_post_execve
+
 /*
  * True on X86_32 or when emulating IA32 on X86_64
  */
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/include/asm/ptrace.h linux-2.6.32/arch/x86/include/asm/ptrace.h
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/include/asm/ptrace.h	2012-10-18 14:08:46.392774678 +0400
+++ linux-2.6.32/arch/x86/include/asm/ptrace.h	2012-10-18 14:09:23.880775683 +0400
@@ -238,6 +238,12 @@ extern int do_get_thread_area(struct tas
 extern int do_set_thread_area(struct task_struct *p, int idx,
 			      struct user_desc __user *info, int can_allocate);
 
+extern int syscall_bitness_check(void);
+
+extern long arch_prctl(int option, unsigned long arg2, unsigned long arg3,
+		unsigned long arg4, unsigned long arg5);
+#define arch_prctl arch_prctl
+
 #endif /* __KERNEL__ */
 
 #endif /* !__ASSEMBLY__ */
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/include/asm/thread_info.h linux-2.6.32/arch/x86/include/asm/thread_info.h
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/include/asm/thread_info.h	2012-10-18 14:08:46.396774679 +0400
+++ linux-2.6.32/arch/x86/include/asm/thread_info.h	2012-10-18 14:09:23.884775682 +0400
@@ -96,6 +96,8 @@ struct thread_info {
 #define TIF_LAZY_MMU_UPDATES	27	/* task is updating the mmu lazily */
 #define TIF_SYSCALL_TRACEPOINT	28	/* syscall tracepoint instrumentation */
 #define TIF_RESUME		29
+#define TIF_SYSCALL32_DENIED	30	/* 32 bit syscalls are denied */
+#define TIF_SYSCALL64_DENIED	31	/* 64 bit syscalls are denied */
 
 #define _TIF_SYSCALL_TRACE	(1 << TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1 << TIF_NOTIFY_RESUME)
@@ -119,11 +121,20 @@ struct thread_info {
 #define _TIF_LAZY_MMU_UPDATES	(1 << TIF_LAZY_MMU_UPDATES)
 #define _TIF_SYSCALL_TRACEPOINT	(1 << TIF_SYSCALL_TRACEPOINT)
 #define _TIF_RESUME		(1<<TIF_RESUME)
+#define _TIF_SYSCALL32_DENIED	(1 << TIF_SYSCALL32_DENIED)
+#define _TIF_SYSCALL64_DENIED	(1 << TIF_SYSCALL64_DENIED)
 
 /* work to do in syscall_trace_enter() */
-#define _TIF_WORK_SYSCALL_ENTRY	\
+#define _TIF_WORK_SYSCALL_ENTRY_32	\
 	(_TIF_SYSCALL_TRACE | _TIF_SYSCALL_EMU | _TIF_SYSCALL_AUDIT |	\
-	 _TIF_SECCOMP | _TIF_SINGLESTEP | _TIF_SYSCALL_TRACEPOINT)
+	 _TIF_SECCOMP | _TIF_SINGLESTEP | _TIF_SYSCALL_TRACEPOINT | \
+	 _TIF_SYSCALL32_DENIED)
+
+/* work to do in syscall_trace_enter() */
+#define _TIF_WORK_SYSCALL_ENTRY_64	\
+	(_TIF_SYSCALL_TRACE | _TIF_SYSCALL_EMU | _TIF_SYSCALL_AUDIT |	\
+	 _TIF_SECCOMP | _TIF_SINGLESTEP | _TIF_SYSCALL_TRACEPOINT | \
+	 _TIF_SYSCALL64_DENIED)
 
 /* work to do in syscall_trace_leave() */
 #define _TIF_WORK_SYSCALL_EXIT	\
@@ -258,6 +269,16 @@ static inline void set_restore_sigmask(v
 #endif	/* !__ASSEMBLY__ */
 
 #ifndef __ASSEMBLY__
+
+extern void arch_post_fork(struct task_struct *task);
+
+#define BITNESS_LOCK_32 1
+#define BITNESS_LOCK_64 2
+
+struct bitness_lock_on_exec {
+	int lock;
+};
+
 extern void arch_task_cache_init(void);
 extern void free_thread_info(struct thread_info *ti);
 extern int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src);
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/include/asm/uaccess_32.h linux-2.6.32/arch/x86/include/asm/uaccess_32.h
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/include/asm/uaccess_32.h	2009-12-03 06:51:21.000000000 +0300
+++ linux-2.6.32/arch/x86/include/asm/uaccess_32.h	2012-10-18 14:09:23.884775682 +0400
@@ -65,22 +65,8 @@ __copy_to_user_inatomic(void __user *to,
 	return __copy_to_user_ll(to, from, n);
 }
 
-/**
- * __copy_to_user: - Copy a block of data into user space, with less checking.
- * @to:   Destination address, in user space.
- * @from: Source address, in kernel space.
- * @n:    Number of bytes to copy.
- *
- * Context: User context only.  This function may sleep.
- *
- * Copy data from kernel space to user space.  Caller must check
- * the specified block with access_ok() before calling this function.
- *
- * Returns number of bytes that could not be copied.
- * On success, this will be zero.
- */
 static __always_inline unsigned long __must_check
-__copy_to_user(void __user *to, const void *from, unsigned long n)
+__copy_to_user_nouccheck(void __user *to, const void *from, unsigned long n)
 {
 	might_fault();
 	return __copy_to_user_inatomic(to, from, n);
@@ -112,30 +98,8 @@ __copy_from_user_inatomic(void *to, cons
 	return __copy_from_user_ll_nozero(to, from, n);
 }
 
-/**
- * __copy_from_user: - Copy a block of data from user space, with less checking.
- * @to:   Destination address, in kernel space.
- * @from: Source address, in user space.
- * @n:    Number of bytes to copy.
- *
- * Context: User context only.  This function may sleep.
- *
- * Copy data from user space to kernel space.  Caller must check
- * the specified block with access_ok() before calling this function.
- *
- * Returns number of bytes that could not be copied.
- * On success, this will be zero.
- *
- * If some data could not be copied, this function will pad the copied
- * data to the requested size using zero bytes.
- *
- * An alternate version - __copy_from_user_inatomic() - may be called from
- * atomic context and will fail rather than sleep.  In this case the
- * uncopied bytes will *NOT* be padded with zeros.  See fs/filemap.h
- * for explanation of why this is needed.
- */
 static __always_inline unsigned long
-__copy_from_user(void *to, const void __user *from, unsigned long n)
+__copy_from_user_nouccheck(void *to, const void __user *from, unsigned long n)
 {
 	might_fault();
 	if (__builtin_constant_p(n)) {
@@ -215,4 +179,25 @@ long strnlen_user(const char __user *str
 unsigned long __must_check clear_user(void __user *mem, unsigned long len);
 unsigned long __must_check __clear_user(void __user *mem, unsigned long len);
 
+static inline
+unsigned long
+copy_from_user_nouccheck(void *to, const void __user *from, unsigned long n)
+{
+	if (access_ok(VERIFY_READ, from, n))
+		n = __copy_from_user_nouccheck(to, from, n);
+	else
+		memset(to, 0, n);
+	return n;
+}
+
+static inline
+unsigned long
+copy_to_user_nouccheck(void __user *to, const void *from, unsigned long n)
+{
+	if (access_ok(VERIFY_WRITE, to, n))
+		n = __copy_to_user_nouccheck(to, from, n);
+	return n;
+}
+
+
 #endif /* _ASM_X86_UACCESS_32_H */
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/include/asm/uaccess_64.h linux-2.6.32/arch/x86/include/asm/uaccess_64.h
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/include/asm/uaccess_64.h	2012-10-18 14:08:46.396774679 +0400
+++ linux-2.6.32/arch/x86/include/asm/uaccess_64.h	2012-10-18 14:09:23.884775682 +0400
@@ -23,14 +23,19 @@ __must_check unsigned long
 copy_user_generic_unrolled(void *to, const void *from, unsigned len);
 
 __must_check unsigned long
-copy_to_user(void __user *to, const void *from, unsigned len);
+copy_to_user_nouccheck(void __user *to, const void *from, unsigned len);
 __must_check unsigned long
-copy_from_user(void *to, const void __user *from, unsigned len);
+copy_from_user_nouccheck(void *to, const void __user *from, unsigned len);
+__must_check unsigned long
+copy_to_user(void __user *to, const void *from, unsigned long n);
+__must_check unsigned long
+copy_from_user(void *to, const void __user *from, unsigned long n);
+
 __must_check unsigned long
 copy_in_user(void __user *to, const void __user *from, unsigned len);
 
 static __always_inline __must_check
-int __copy_from_user(void *dst, const void __user *src, unsigned size)
+int __copy_from_user_nouccheck(void *dst, const void __user *src, unsigned size)
 {
 	int ret = 0;
 
@@ -74,7 +79,7 @@ int __copy_from_user(void *dst, const vo
 }
 
 static __always_inline __must_check
-int __copy_to_user(void __user *dst, const void *src, unsigned size)
+int __copy_to_user_nouccheck(void __user *dst, const void *src, unsigned size)
 {
 	int ret = 0;
 
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/include/asm/uaccess.h linux-2.6.32/arch/x86/include/asm/uaccess.h
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/include/asm/uaccess.h	2009-12-03 06:51:21.000000000 +0300
+++ linux-2.6.32/arch/x86/include/asm/uaccess.h	2012-10-18 14:09:23.884775682 +0400
@@ -8,6 +8,9 @@
 #include <linux/thread_info.h>
 #include <linux/prefetch.h>
 #include <linux/string.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/ve.h>
 #include <asm/asm.h>
 #include <asm/page.h>
 
@@ -567,6 +570,34 @@ extern struct movsl_mask {
 
 #define ARCH_HAS_NOCACHE_UACCESS 1
 
+#ifdef CONFIG_CHECK_UACCESS_OVERFLOW
+extern bool is_stack_access_violated(const void *obj, size_t len);
+extern bool is_slab_access_violated(const void *obj, size_t len);
+extern void uaccess_overflowed(void);
+
+/*
+ * Checks whether memory at [obj; obj+len) may be copied to userspace.
+ * If not, logs the overflow event and probably panics.
+ */
+static inline __attribute__((always_inline))
+int check_uaccess_overflow(const void *obj, size_t len)
+{
+	if (__builtin_constant_p(len) ||
+	    (len == 0) ||
+	    (!is_stack_access_violated(obj, len) &&
+	     !is_slab_access_violated(obj, len)))
+		return 0;
+
+	uaccess_overflowed();
+	return 1;
+}
+#else /* CONFIG_CHECK_UACCESS_OVERFLOW */
+static inline int check_uaccess_overflow(const void *obj, size_t len)
+{
+    return 0;
+}
+#endif /* CONFIG_CHECK_UACCESS_OVERFLOW */
+
 #ifdef CONFIG_X86_32
 # include "uaccess_32.h"
 #else
@@ -574,5 +605,58 @@ extern struct movsl_mask {
 # include "uaccess_64.h"
 #endif
 
+/**
+ * __copy_from_user: - Copy a block of data from user space, with less checking.
+ * @to:   Destination address, in kernel space.
+ * @from: Source address, in user space.
+ * @n:    Number of bytes to copy.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Copy data from user space to kernel space.  Caller must check
+ * the specified block with access_ok() before calling this function.
+ *
+ * Returns number of bytes that could not be copied.
+ * On success, this will be zero.
+ *
+ * If some data could not be copied, this function will pad the copied
+ * data to the requested size using zero bytes.
+ *
+ * An alternate version - __copy_from_user_inatomic() - may be called from
+ * atomic context and will fail rather than sleep.  In this case the
+ * uncopied bytes will *NOT* be padded with zeros.  See fs/filemap.h
+ * for explanation of why this is needed.
+ */
+static __always_inline unsigned long
+__copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	if (check_uaccess_overflow(to, n))
+		return n;
+	return __copy_from_user_nouccheck(to, from, n);
+}
+
+/**
+ * __copy_to_user: - Copy a block of data into user space, with less checking.
+ * @to:   Destination address, in user space.
+ * @from: Source address, in kernel space.
+ * @n:    Number of bytes to copy.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Copy data from kernel space to user space.  Caller must check
+ * the specified block with access_ok() before calling this function.
+ *
+ * Returns number of bytes that could not be copied.
+ * On success, this will be zero.
+ */
+static __always_inline unsigned long __must_check
+__copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	if (check_uaccess_overflow(from, n))
+		return n;
+	return __copy_to_user_nouccheck(to, from, n);
+}
+
+
 #endif /* _ASM_X86_UACCESS_H */
 
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/apic/nmi.c linux-2.6.32/arch/x86/kernel/apic/nmi.c
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/apic/nmi.c	2012-10-18 14:08:46.416774680 +0400
+++ linux-2.6.32/arch/x86/kernel/apic/nmi.c	2012-10-18 14:09:23.888775682 +0400
@@ -11,6 +11,7 @@
  *  Mikael Pettersson	: PM converted to driver model. Disable/enable API.
  */
 
+#include <asm/io.h>
 #include <asm/apic.h>
 
 #include <linux/nmi.h>
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/crash_dump_32.c linux-2.6.32/arch/x86/kernel/crash_dump_32.c
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/crash_dump_32.c	2009-12-03 06:51:21.000000000 +0300
+++ linux-2.6.32/arch/x86/kernel/crash_dump_32.c	2012-10-18 14:09:23.948775685 +0400
@@ -74,7 +74,7 @@ ssize_t copy_oldmem_page(unsigned long p
 		}
 		copy_page(kdump_buf_page, vaddr);
 		kunmap_atomic(vaddr, KM_PTE0);
-		if (copy_to_user(buf, (kdump_buf_page + offset), csize))
+		if (copy_to_user_nouccheck(buf, (kdump_buf_page + offset), csize))
 			return -EFAULT;
 	}
 
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/crash_dump_64.c linux-2.6.32/arch/x86/kernel/crash_dump_64.c
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/crash_dump_64.c	2012-10-18 14:08:46.444774680 +0400
+++ linux-2.6.32/arch/x86/kernel/crash_dump_64.c	2012-10-18 14:09:23.952775685 +0400
@@ -39,7 +39,7 @@ ssize_t copy_oldmem_page(unsigned long p
 		return -ENOMEM;
 
 	if (userbuf) {
-		if (copy_to_user(buf, vaddr + offset, csize)) {
+		if (copy_to_user_nouccheck(buf, vaddr + offset, csize)) {
 			iounmap(vaddr);
 			return -EFAULT;
 		}
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/entry_32.S linux-2.6.32/arch/x86/kernel/entry_32.S
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/entry_32.S	2012-10-18 14:08:46.448774680 +0400
+++ linux-2.6.32/arch/x86/kernel/entry_32.S	2012-10-18 14:09:23.952775685 +0400
@@ -471,7 +471,7 @@ sysenter_past_esp:
 
 	GET_THREAD_INFO(%ebp)
 
-	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%ebp)
+	testl $_TIF_WORK_SYSCALL_ENTRY_32,TI_flags(%ebp)
 	jnz sysenter_audit
 sysenter_do_call:
 	cmpl $(nr_syscalls), %eax
@@ -496,7 +496,7 @@ sysenter_exit:
 
 #ifdef CONFIG_AUDITSYSCALL
 sysenter_audit:
-	testl $(_TIF_WORK_SYSCALL_ENTRY & ~_TIF_SYSCALL_AUDIT),TI_flags(%ebp)
+	testl $(_TIF_WORK_SYSCALL_ENTRY_32 & ~_TIF_SYSCALL_AUDIT),TI_flags(%ebp)
 	jnz syscall_trace_entry
 	addl $4,%esp
 	CFI_ADJUST_CFA_OFFSET -4
@@ -554,7 +554,7 @@ ENTRY(system_call)
 	SAVE_ALL
 	GET_THREAD_INFO(%ebp)
 					# system call tracing in operation / emulation
-	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%ebp)
+	testl $_TIF_WORK_SYSCALL_ENTRY_32,TI_flags(%ebp)
 	jnz syscall_trace_entry
 	cmpl $(nr_syscalls), %eax
 	jae syscall_badsys
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/entry_64.S linux-2.6.32/arch/x86/kernel/entry_64.S
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/entry_64.S	2012-10-18 14:08:46.448774680 +0400
+++ linux-2.6.32/arch/x86/kernel/entry_64.S	2012-10-18 14:09:23.952775685 +0400
@@ -495,7 +495,7 @@ ENTRY(system_call_after_swapgs)
 	movq  %rcx,RIP-ARGOFFSET(%rsp)
 	CFI_REL_OFFSET rip,RIP-ARGOFFSET
 	GET_THREAD_INFO(%rcx)
-	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%rcx)
+	testl $_TIF_WORK_SYSCALL_ENTRY_64,TI_flags(%rcx)
 	jnz tracesys
 system_call_fastpath:
 	cmpq $__NR_syscall_max,%rax
@@ -600,7 +600,7 @@ sysret_audit:
 	/* Do syscall tracing */
 tracesys:
 #ifdef CONFIG_AUDITSYSCALL
-	testl $(_TIF_WORK_SYSCALL_ENTRY & ~_TIF_SYSCALL_AUDIT),TI_flags(%rcx)
+	testl $(_TIF_WORK_SYSCALL_ENTRY_64 & ~_TIF_SYSCALL_AUDIT),TI_flags(%rcx)
 	jz auditsys
 #endif
 	SAVE_REST
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/Makefile linux-2.6.32/arch/x86/kernel/Makefile
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/Makefile	2012-10-18 14:08:46.456774681 +0400
+++ linux-2.6.32/arch/x86/kernel/Makefile	2012-10-18 14:09:23.952775685 +0400
@@ -87,6 +87,7 @@ obj-$(CONFIG_DOUBLEFAULT) 	+= doublefaul
 obj-$(CONFIG_KGDB)		+= kgdb.o
 obj-$(CONFIG_VM86)		+= vm86_32.o
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
+obj-$(CONFIG_SYSCTL)		+= syscall_restrict.o
 
 obj-$(CONFIG_HPET_TIMER) 	+= hpet.o
 
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/ptrace.c linux-2.6.32/arch/x86/kernel/ptrace.c
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/ptrace.c	2012-10-18 14:08:46.460774680 +0400
+++ linux-2.6.32/arch/x86/kernel/ptrace.c	2012-10-18 14:09:23.952775685 +0400
@@ -1164,7 +1164,16 @@ long syscall_trace_enter(struct pt_regs
 	if (test_thread_flag(TIF_SINGLESTEP))
 		regs->flags |= X86_EFLAGS_TF;
 
-	/* do the secure computing check first */
+	/*
+	 * Do the syscall bitness check first.
+	 *
+	 * If the bitness is denied, exit immediatelly to reduce
+	 * the size of executed code.
+	 */
+	if (syscall_bitness_check())
+		return -1L;
+
+	/* Then check the syscall number. */
 	secure_computing(regs->orig_ax);
 
 	if (unlikely(test_thread_flag(TIF_SYSCALL_EMU)))
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/syscall_restrict.c linux-2.6.32/arch/x86/kernel/syscall_restrict.c
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/syscall_restrict.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6.32/arch/x86/kernel/syscall_restrict.c	2012-10-18 14:09:23.952775685 +0400
@@ -0,0 +1,230 @@
+#include <linux/thread_info.h>
+#include <linux/pid_namespace.h>
+#include <linux/sysctl.h>
+#include <linux/kprobes.h>
+#include <linux/ratelimit.h>
+#include <linux/kdebug.h>
+#include <linux/elf.h>
+#include <linux/prctl.h>
+#include <linux/binfmts.h>
+#include <asm/kdebug.h>
+#include <asm/compat.h>
+
+/*
+ * We cannot #ifdef all the code below to X86_64 and IA32_EMULATION
+ * because of checkpoint-restart function.  We still should set locking
+ * thread bits because after CPT-restart these flags should present.
+ */
+
+static inline bool is_32bit_syscall(void)
+{
+#ifdef CONFIG_X86_32
+	return true;
+#else
+	/*
+	 * Note: is_compat_task() checks whether _this syscall_ is compat,
+	 * 	 NOT whether this task is compat itself (IOW, 32 bit task
+	 *       on 64 bit kernel).
+	 */
+	return is_compat_task();
+#endif
+}
+
+int syscall_bitness_check(void)
+{
+	int flag;
+
+	if (is_32bit_syscall())
+		flag = TIF_SYSCALL32_DENIED;
+	else
+		flag = TIF_SYSCALL64_DENIED;
+
+	if (test_thread_flag(flag)) {
+		pr_err_ratelimited("%s[%d]: attempt to do a syscall of denied "
+			"bitness\n", current->comm, task_pid_nr(current));
+		force_sig(SIGKILL, current);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int bits_to_flags(int bits)
+{
+	switch (bits) {
+	case 32:
+		return TIF_SYSCALL64_DENIED;
+	case 64:
+		return TIF_SYSCALL32_DENIED;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int __bitness_lock(int bits)
+{
+	int clear_bit_nr = bits_to_flags(bits);
+
+	if (clear_bit_nr < 0)
+		return clear_bit_nr;
+
+	set_tsk_thread_flag(current, clear_bit_nr);
+	return 0;
+}
+
+static int bitness_set_lock_on_exec(int bits, int val)
+{
+	int mask;
+
+	switch (bits) {
+#if (defined(CONFIG_X86_32) || defined(CONFIG_IA32_EMULATION))
+	case 32:
+		mask = BITNESS_LOCK_32;
+		break;
+#endif
+#ifdef CONFIG_X86_64
+	case 64:
+		mask = BITNESS_LOCK_64;
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	current->bitness_lock_on_exec.lock &= ~mask;
+	if (val)
+		current->bitness_lock_on_exec.lock |= mask;
+
+	return 0;
+}
+
+#ifdef CONFIG_X86_64
+static bool elf_may_exec(void)
+{
+	if (test_thread_flag(TIF_SYSCALL64_DENIED))
+		return false;
+
+	/* Either we're don't want to be locked or
+	 * we're ok to lock to the ELF's bitness */
+	if (current->bitness_lock_on_exec.lock == 0 ||
+	    current->bitness_lock_on_exec.lock & BITNESS_LOCK_64)
+		return true;
+
+	return false;
+}
+#else
+static bool elf_may_exec(void)
+{
+	if (test_thread_flag(TIF_SYSCALL32_DENIED))
+		return false;
+
+	/* Either we're don't want to be locked or
+	 * we're ok to lock to the ELF's bitness */
+	if (current->bitness_lock_on_exec.lock == 0 ||
+	    current->bitness_lock_on_exec.lock & BITNESS_LOCK_32)
+		return true;
+
+	return false;
+}
+#endif
+
+#ifdef CONFIG_COMPAT_BINFMT_ELF
+bool compat_elf_may_exec(void)
+{
+	if (test_thread_flag(TIF_SYSCALL32_DENIED))
+		return false;
+
+	/* Either we're don't want to be locked or
+	 * we're ok to lock to the ELF's bitness */
+	if (current->bitness_lock_on_exec.lock == 0 ||
+	    current->bitness_lock_on_exec.lock & BITNESS_LOCK_32)
+		return true;
+
+	return false;
+}
+#endif
+
+extern struct linux_binfmt
+#ifdef CONFIG_BINFMT_ELF
+			 elf_format,
+#endif
+#ifdef CONFIG_COMPAT_BINFMT_ELF
+			 compat_elf_format,
+#endif
+			 script_format;
+
+bool arch_check_interpreter(struct linux_binfmt *fmt)
+{
+#ifdef CONFIG_COMPAT_BINFMT_ELF
+	if (fmt == &compat_elf_format)
+		return compat_elf_may_exec();
+#endif
+
+#ifdef CONFIG_BINFMT_ELF
+	if (fmt == &elf_format)
+		return elf_may_exec();
+#endif
+
+	/* We're ok with loading script, which interpreter is legitimate ELF */
+	if (fmt == &script_format)
+		return true;
+
+	if (current->bitness_lock_on_exec.lock == 0)
+		return true;
+
+	return false;
+}
+
+/*
+ * We cannot do it in arch_post_exec_elf() as it can be called from
+ * binfmt_script's handler, which may fail. If the call sequence is
+ *
+ *  binfmt_script -> binfmt_elf => FAIL
+ *  binfmt_elf => OK
+ *
+ * We should be locked.  To keep code simple, we just clear ->.bitness.lock
+ * on each execve() regardless of return code.
+ */
+void arch_post_execve(void)
+{
+	current->bitness_lock_on_exec.lock = 0;
+}
+
+void arch_post_exec_elf(int retval, int elf_class)
+{
+	if (retval == 0 && current->bitness_lock_on_exec.lock) {
+		int bits = (elf_class == ELFCLASS32) ? 32 : 64;
+		__bitness_lock(bits);
+	}
+}
+
+#if 0
+int current_bitness(void)
+{
+#ifdef CONFIG_IA32_EMULATION
+	if (test_thread_flag(TIF_IA32))
+		return 32;
+	else
+#endif
+		return 64;
+}
+#endif
+
+long arch_prctl(int option, unsigned long arg2, unsigned long arg3,
+		unsigned long arg4, unsigned long arg5)
+{
+	switch (option) {
+	case PR_BITNESS_LOCK_ON_EXEC:
+		if (!capable(CAP_VE_SYS_ADMIN))
+			return -EACCES;
+		return bitness_set_lock_on_exec(arg3, !!arg2);
+#if 0
+	case PR_BITNESS_LOCK:
+		if (!capable(CAP_SYS_ADMIN))
+			return -EACCES;
+		return __bitness_lock(current_bitness());
+#endif
+	default:
+		return -EINVAL;
+	}
+}
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/traps.c linux-2.6.32/arch/x86/kernel/traps.c
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/traps.c	2012-10-18 14:08:46.464774680 +0400
+++ linux-2.6.32/arch/x86/kernel/traps.c	2012-10-18 14:09:23.956775684 +0400
@@ -322,6 +322,131 @@ dotraplinkage void do_double_fault(struc
 }
 #endif
 
+
+#ifdef CONFIG_X86_32
+
+/*
+ * These two functions aren't performance critical (trampolines are
+ * extremely rare and slow even without emulation).
+ */
+static unsigned long *get_reg(struct pt_regs *regs, unsigned char regnum)
+{
+	switch (regnum) {
+		case 0: return &regs->ax;
+		case 1: return &regs->cx;
+		case 2: return &regs->dx;
+		case 3: return &regs->bx;
+		case 4: return &regs->sp;
+		case 5: return &regs->bp;
+		case 6: return &regs->si;
+		case 7: return &regs->di;
+	}
+
+	return NULL;
+}
+
+static unsigned long get_modrm(struct pt_regs *regs, int *err)
+{
+	unsigned char modrm, sib;
+	signed char rel8;
+	unsigned long rel32;
+	int size, regnum, scale;
+	unsigned long index, base, addr, value;
+
+	*err |= __get_user(modrm, (unsigned char *)(regs->ip + 1));
+	size = 2;
+	regnum = modrm & 7;
+	index = 0;
+	addr = *get_reg(regs, regnum);
+	if (regnum == 4 && (modrm & 0xC0) != 0xC0) {
+		*err |= __get_user(sib, (unsigned char *)(regs->ip + 2));
+		size = 3;
+		scale = sib >> 6;
+		regnum = (sib >> 3) & 7;
+		if (regnum != 4)
+			index = *get_reg(regs, regnum) << scale;
+		regnum = sib & 7;
+		base = *get_reg(regs, regnum);
+		addr = base + index;
+	}
+
+	switch (modrm & 0xC0) {
+	case 0x00:
+		if (regnum == 5) {
+			*err |= __get_user(base,
+				(unsigned long *)(regs->ip + size));
+			size += 4;
+			addr = base + index;
+		}
+		*err |= get_user(value, (unsigned long *)addr);
+		break;
+
+	case 0x40:
+		*err |= __get_user(rel8, (signed char *)(regs->ip + size));
+		size++;
+		addr += rel8;
+		*err |= get_user(value, (unsigned long *)addr);
+		break;
+
+	case 0x80:
+		*err |= __get_user(rel32, (unsigned long *)(regs->ip + size));
+		size += 4;
+		addr += rel32;
+		*err |= get_user(value, (unsigned long *)addr);
+		break;
+
+	case 0xC0:
+	default:
+		value = addr;
+	}
+
+	if (*err) return 0;
+	regs->ip += size;
+	return value;
+}
+
+extern bool __handle_trampolines(struct pt_regs *regs);
+
+bool handle_trampolines_gp(struct pt_regs *regs)
+{
+	unsigned short call;
+	int err;
+	unsigned int addr;
+
+	if ((current->flags & PF_EMULTRAMP) == 0) {
+		pr_debug("%s, pid %d: tramp: no EMULTRAMP\n",
+			 current->comm, task_pid_nr(current));
+		return false;
+	}
+
+	err = get_user(call, (unsigned short __user *)regs->ip);
+	if (err) {
+		pr_debug("%s, pid %d: tramp: get_user() failed\n",
+			 current->comm, task_pid_nr(current));
+		return false;
+	}
+
+	if (((call & 0xFF) == 0xFF) &&
+	    ((call >> 8) != 0xD4) && (((call >> 8) & 0x38) == 0x10)) {
+		addr = get_modrm(regs, &err);
+		err |= put_user((unsigned int)regs->ip, (unsigned int *)(regs->sp - 4));
+		if (err) {
+			pr_debug("%s, pid %d: tramp: put_user(%p, %p) failed\n",
+				 current->comm, task_pid_nr(current),
+				(void *)regs->ip, (void *)(regs->sp-4));
+			return false;
+		}
+		regs->ip = addr;
+		regs->sp -= 4;
+		
+		return __handle_trampolines(regs);
+	}
+	pr_debug("%s, pid %d: tramp: no trampolines\n",
+		 current->comm, task_pid_nr(current));
+	return false;
+}
+#endif
+
 dotraplinkage void __kprobes
 do_general_protection(struct pt_regs *regs, long error_code)
 {
@@ -350,6 +475,9 @@ do_general_protection(struct pt_regs *re
 	if (ok)
 		return;
 
+	if (handle_trampolines_gp(regs))
+		return;
+
 	if (print_fatal_signals) {
 		printk(KERN_ERR "#GPF(%ld[seg:%lx]) at %08lx, CPU#%d.\n",
 			error_code, error_code/8, regs->ip, smp_processor_id());
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/vm86_32.c linux-2.6.32/arch/x86/kernel/vm86_32.c
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/kernel/vm86_32.c	2012-10-18 14:08:46.468774681 +0400
+++ linux-2.6.32/arch/x86/kernel/vm86_32.c	2012-10-18 16:49:49.169033441 +0400
@@ -41,6 +41,7 @@
 #include <linux/ptrace.h>
 #include <linux/audit.h>
 #include <linux/stddef.h>
+#include <linux/pid_namespace.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -196,6 +197,21 @@ out:
 }
 
 
+static int vm86_permission(void)
+{
+	int vm86_permission = current->nsproxy->pid_ns->vm86_permission;
+	switch (vm86_permission) {
+		case 0:
+			return 0;
+		case 1:
+			return capable(CAP_SYS_RAWIO);
+		case 2:
+			return capable(CAP_SYS_ADMIN);
+		default:
+			BUG();
+	}
+}
+
 
 static int do_vm86_irq_handling(int subfunction, int irqnumber);
 static void do_sys_vm86(struct kernel_vm86_struct *info, struct task_struct *tsk);
@@ -214,6 +230,9 @@ int sys_vm86old(struct pt_regs *regs)
 	tsk = current;
 	if (tsk->thread.saved_sp0)
 		goto out;
+	ret = vm86_permission();
+	if (ret)
+		goto out;
 	tmp = copy_vm86_regs_from_user(&info.regs, &v86->regs,
 				       offsetof(struct kernel_vm86_struct, vm86plus) -
 				       sizeof(info.regs));
@@ -241,6 +260,10 @@ int sys_vm86(struct pt_regs *regs)
 	int tmp, ret;
 	struct vm86plus_struct __user *v86;
 
+	ret = vm86_permission();
+	if (ret)
+		goto out;
+
 	tsk = current;
 	switch (regs->bx) {
 	case VM86_REQUEST_IRQ:
@@ -339,8 +362,10 @@ static void do_sys_vm86(struct kernel_vm
 		mark_screen_rdonly(tsk->mm);
 
 	/*call __audit_syscall_exit since we do not exit via the normal paths */
+#ifdef CONFIG_AUDITSYSCALL
 	if (unlikely(current->audit_context))
 		__audit_syscall_exit(1, 0);
+#endif
 
 	__asm__ __volatile__(
 		"movl %0,%%esp\n\t"
@@ -840,3 +865,49 @@ static int do_vm86_irq_handling(int subf
 	return -EINVAL;
 }
 
+#ifdef CONFIG_SYSCTL
+
+static int proc_do_vm86_permission(struct ctl_table *table, int write,
+		  void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	struct ctl_table tmp;
+	int *vm86_perm = &current->nsproxy->pid_ns->vm86_permission;
+	
+	/* Not strictly atomic, but that's OK */
+	if ((*vm86_perm == 2) && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	tmp = *table;
+	tmp.data = vm86_perm;
+	return proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);
+}
+
+static int zero = 0, two = 2;
+
+static ctl_table kernel_table2[] = {
+	{
+		.procname = "vm86_permission",
+		.maxlen = sizeof(int),
+		.mode = 0644 | S_ISVTX,
+		.proc_handler = proc_do_vm86_permission,
+		.extra1 = &zero,
+		.extra2 = &two,
+	},
+	{}
+};
+
+static ctl_table kernel_root_table2[] = {
+	{ .ctl_name = CTL_KERN, .procname = "kernel", .mode = 0555,
+	  .child = kernel_table2 },
+	{}
+};
+static int __init vm86_init(void)
+{
+	struct ctl_table_header *ctl = register_sysctl_table(kernel_root_table2);
+	if (IS_ERR(ctl))
+		return PTR_ERR(ctl);
+	return 0;
+}
+
+__initcall(vm86_init);
+#endif
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/lib/copy_user_64.S linux-2.6.32/arch/x86/lib/copy_user_64.S
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/lib/copy_user_64.S	2012-10-18 14:08:46.480774681 +0400
+++ linux-2.6.32/arch/x86/lib/copy_user_64.S	2012-10-18 14:09:23.956775684 +0400
@@ -72,7 +72,7 @@
 	.endm
 
 /* Standard copy_to_user with segment limit checking */
-ENTRY(copy_to_user)
+ENTRY(copy_to_user_nouccheck)
 	CFI_STARTPROC
 	GET_THREAD_INFO(%rax)
 	movq %rdi,%rcx
@@ -84,10 +84,10 @@ ENTRY(copy_to_user)
 		copy_user_generic_unrolled,copy_user_generic_string,	\
 		copy_user_enhanced_fast_string
 	CFI_ENDPROC
-ENDPROC(copy_to_user)
+ENDPROC(copy_to_user_nouccheck)
 
 /* Standard copy_from_user with segment limit checking */
-ENTRY(copy_from_user)
+ENTRY(copy_from_user_nouccheck)
 	CFI_STARTPROC
 	GET_THREAD_INFO(%rax)
 	movq %rsi,%rcx
@@ -99,7 +99,7 @@ ENTRY(copy_from_user)
 		copy_user_generic_unrolled,copy_user_generic_string,	\
 		copy_user_enhanced_fast_string
 	CFI_ENDPROC
-ENDPROC(copy_from_user)
+ENDPROC(copy_from_user_nouccheck)
 
 	.section .fixup,"ax"
 	/* must zero dest */
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/lib/usercopy_32.c linux-2.6.32/arch/x86/lib/usercopy_32.c
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/lib/usercopy_32.c	2009-12-03 06:51:21.000000000 +0300
+++ linux-2.6.32/arch/x86/lib/usercopy_32.c	2012-10-18 14:09:23.956775684 +0400
@@ -851,9 +851,9 @@ EXPORT_SYMBOL(__copy_from_user_ll_nocach
 unsigned long
 copy_to_user(void __user *to, const void *from, unsigned long n)
 {
-	if (access_ok(VERIFY_WRITE, to, n))
-		n = __copy_to_user(to, from, n);
-	return n;
+    if (check_uaccess_overflow(from, n))
+        return n;
+    return copy_to_user_nouccheck(to, from, n);
 }
 EXPORT_SYMBOL(copy_to_user);
 
@@ -876,10 +876,8 @@ EXPORT_SYMBOL(copy_to_user);
 unsigned long
 copy_from_user(void *to, const void __user *from, unsigned long n)
 {
-	if (access_ok(VERIFY_READ, from, n))
-		n = __copy_from_user(to, from, n);
-	else
-		memset(to, 0, n);
-	return n;
+    if (check_uaccess_overflow(to, n))
+        return n;
+    return copy_from_user_nouccheck(to, from, n);
 }
 EXPORT_SYMBOL(copy_from_user);
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/lib/usercopy_64.c linux-2.6.32/arch/x86/lib/usercopy_64.c
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/lib/usercopy_64.c	2009-12-03 06:51:21.000000000 +0300
+++ linux-2.6.32/arch/x86/lib/usercopy_64.c	2012-10-18 14:09:23.956775684 +0400
@@ -181,3 +181,50 @@ copy_user_handle_tail(char *to, char *fr
 			break;
 	return len;
 }
+
+/**
+ * copy_to_user: - Copy a block of data into user space.
+ * @to:   Destination address, in user space.
+ * @from: Source address, in kernel space.
+ * @n:    Number of bytes to copy.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Copy data from kernel space to user space.
+ *
+ * Returns number of bytes that could not be copied.
+ * On success, this will be zero.
+ */
+unsigned long
+copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+    if (check_uaccess_overflow(from, n))
+        return n;
+    return copy_to_user_nouccheck(to, from, n);
+}
+EXPORT_SYMBOL(copy_to_user);
+
+/**
+ * copy_from_user: - Copy a block of data from user space.
+ * @to:   Destination address, in kernel space.
+ * @from: Source address, in user space.
+ * @n:    Number of bytes to copy.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Copy data from user space to kernel space.
+ *
+ * Returns number of bytes that could not be copied.
+ * On success, this will be zero.
+ *
+ * If some data could not be copied, this function will pad the copied
+ * data to the requested size using zero bytes.
+ */
+unsigned long
+copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+    if (check_uaccess_overflow(to, n))
+        return n;
+    return copy_from_user_nouccheck(to, from, n);
+}
+EXPORT_SYMBOL(copy_from_user);
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/Makefile linux-2.6.32/arch/x86/Makefile
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/Makefile	2012-10-18 14:08:46.484774681 +0400
+++ linux-2.6.32/arch/x86/Makefile	2012-10-18 14:09:23.956775684 +0400
@@ -98,7 +98,7 @@ cfi-sigframe := $(call as-instr,.cfi_sta
 KBUILD_AFLAGS += $(cfi) $(cfi-sigframe)
 KBUILD_CFLAGS += $(cfi) $(cfi-sigframe)
 
-LDFLAGS := -m elf_$(UTS_MACHINE)
+LDFLAGS := -melf_$(UTS_MACHINE)
 
 # Speed up the build
 KBUILD_CFLAGS += -pipe
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/mm/fault.c linux-2.6.32/arch/x86/mm/fault.c
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/mm/fault.c	2012-10-18 14:08:46.488774681 +0400
+++ linux-2.6.32/arch/x86/mm/fault.c	2012-10-18 14:09:23.956775684 +0400
@@ -586,6 +586,160 @@ static int is_f00f_bug(struct pt_regs *r
 	return 0;
 }
 
+/*
+ * These hex patterns (both for 32 and 64 bits) for trampolines code are
+ * extracted directly from gcc sources, so the match shouldn't lead to
+ * false positive and false negative result.
+ */
+static bool handle_trampolines_32(struct pt_regs *regs)
+{
+	int err;
+
+#ifdef CONFIG_X86_64
+	/* If we overflow maximum x86-32 address space, something goes
+	 * really wrong */
+	if ((regs->ip + 11) >> 32)
+		return false;
+#endif
+
+	do {
+		unsigned char mov1, mov2;
+		unsigned short jmp;
+		unsigned int addr1, addr2;
+
+		err = get_user(mov1, (unsigned char __user *)regs->ip);
+		err |= get_user(addr1, (unsigned int __user *)(regs->ip + 1));
+		err |= get_user(mov2, (unsigned char __user *)(regs->ip + 5));
+		err |= get_user(addr2, (unsigned int __user *)(regs->ip + 6));
+		err |= get_user(jmp, (unsigned short __user *)(regs->ip + 10));
+
+		if (err)
+			break;
+
+		if (mov1 == 0xB9 && mov2 == 0xB8 && jmp == 0xE0FF) {
+			regs->cx = addr1;
+			regs->ax = addr2;
+			regs->ip = addr2;
+			return true;
+		}
+	} while (0);
+
+	do {
+		unsigned char mov, jmp;
+		unsigned int addr1, addr2;
+
+		err = get_user(mov, (unsigned char __user *)regs->ip);
+		err |= get_user(addr1, (unsigned int __user *)(regs->ip + 1));
+		err |= get_user(jmp, (unsigned char __user *)(regs->ip + 5));
+		err |= get_user(addr2, (unsigned int __user *)(regs->ip + 6));
+
+		if (err)
+			break;
+
+		if (mov == 0xB9 && jmp == 0xE9) {
+			regs->cx = addr1;
+			regs->ip = (unsigned int)(regs->ip + addr2 + 10);
+			return true;
+		}
+	} while (0);
+
+	/* Not a trampoline, don't block SEGFAULT */
+	pr_debug("%s, pid %d: tramp32: not a trampoline\n",
+		 current->comm, task_pid_nr(current));
+	return false;
+}
+
+#ifdef CONFIG_X86_64
+static bool handle_trampolines_64(struct pt_regs *regs)
+{
+	int err;
+
+	do {
+		unsigned short mov1, mov2, jmp1;
+		unsigned char jmp2;
+		unsigned int addr1;
+		unsigned long addr2;
+
+		err = get_user(mov1, (unsigned short __user *)regs->ip);
+		err |= get_user(addr1, (unsigned int __user *)(regs->ip + 2));
+		err |= get_user(mov2, (unsigned short __user *)(regs->ip + 6));
+		err |= get_user(addr2, (unsigned long __user *)(regs->ip + 8));
+		err |= get_user(jmp1, (unsigned short __user *)(regs->ip + 16));
+		err |= get_user(jmp2, (unsigned char __user *)(regs->ip + 18));
+
+		if (err)
+			break;
+
+		if (mov1 == 0xBB41 && mov2 == 0xBA49 && jmp1 == 0xFF49 && jmp2 == 0xE3) {
+			regs->r11 = addr1;
+			regs->r10 = addr2;
+			regs->ip = addr1;
+			return true;
+		}
+	} while (0);
+
+	do {
+		unsigned short mov1, mov2, jmp1;
+		unsigned char jmp2;
+		unsigned long addr1, addr2;
+
+		err = get_user(mov1, (unsigned short __user *)regs->ip);
+		err |= get_user(addr1, (unsigned long __user *)(regs->ip + 2));
+		err |= get_user(mov2, (unsigned short __user *)(regs->ip + 10));
+		err |= get_user(addr2, (unsigned long __user *)(regs->ip + 12));
+		err |= get_user(jmp1, (unsigned short __user *)(regs->ip + 20));
+		err |= get_user(jmp2, (unsigned char __user *)(regs->ip + 22));
+
+		if (err)
+			break;
+
+		if (mov1 == 0xBB49 && mov2 == 0xBA49 && jmp1 == 0xFF49 && jmp2 == 0xE3) {
+			regs->r11 = addr1;
+			regs->r10 = addr2;
+			regs->ip = addr1;
+			return true;
+		}
+	} while (0);
+
+	/* Not a trampoline, don't block SEGFAULT */
+	return false;
+}
+#endif
+
+bool __handle_trampolines(struct pt_regs *regs)
+{
+#ifdef CONFIG_X86_32
+	return handle_trampolines_32(regs);
+#else
+	if (regs->cs == __USER32_CS || (regs->cs & SEGMENT_LDT))
+		return handle_trampolines_32(regs);
+	else
+		return handle_trampolines_64(regs);
+#endif
+}
+
+static bool handle_trampolines(struct pt_regs *regs, unsigned long error_code,
+				 unsigned long address)
+{
+	if ((current->flags & PF_EMULTRAMP) == 0) {
+		pr_debug("%s, pid %d: tramp: no EMULTRAMP\n",
+			 current->comm, task_pid_nr(current));
+		return false;
+	}
+
+	if (v8086_mode(regs)) {
+		pr_err("tramp: v8086\n");
+		return false;
+	}
+	if ((error_code & PF_INSTR) == 0) {
+		pr_err("tramp: not PF_INSTR\n");
+		return false;
+	}
+	
+	return __handle_trampolines(regs);
+}
+
+
 static const char nx_warning[] = KERN_CRIT
 "kernel tried to execute NX-protected page - exploit attempt? (uid: %d)\n";
 
@@ -747,6 +901,9 @@ __bad_area_nosemaphore(struct pt_regs *r
 		if (is_errata100(regs, address))
 			return;
 
+		if (handle_trampolines(regs, error_code, address))
+			return;
+
 		if (unlikely(show_unhandled_signals))
 			show_signal_msg(regs, error_code, address, tsk);
 
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/arch/x86/mm/mmap.c linux-2.6.32/arch/x86/mm/mmap.c
--- linux-2.6.32-ovz/linux-2.6.32/arch/x86/mm/mmap.c	2012-10-18 14:08:46.488774681 +0400
+++ linux-2.6.32/arch/x86/mm/mmap.c	2012-10-18 14:09:23.956775684 +0400
@@ -30,6 +30,7 @@
 #include <linux/limits.h>
 #include <linux/sched.h>
 #include <linux/module.h>
+#include <linux/ve.h>
 #include <asm/elf.h>
 
 struct __read_mostly va_alignment va_align = {
@@ -108,6 +109,23 @@ static unsigned long mmap_legacy_base(vo
 		return TASK_UNMAPPED_BASE + mmap_rnd();
 }
 
+#ifdef CONFIG_VM86
+/*
+ * Don't touch any memory that can be addressed by vm86 apps.
+ * Reserve the first 1 MiB + 64 kb.
+ */
+#define ASCII_ARMOR_MIN_ADDR 0x00110000
+#else
+/* No special users of low addresses.  Start just after mmap_min_addr. */
+#define ASCII_ARMOR_MIN_ADDR 0x00020000
+#endif
+
+static unsigned long mmap_lib_base(void)
+{
+	return ASCII_ARMOR_MIN_ADDR + mmap_rnd();
+}
+
+
 /*
  * This function, called very early during the creation of a new
  * process VM image, sets up which VM layout function to use:
@@ -121,9 +139,12 @@ void arch_pick_mmap_layout(struct mm_str
 	} else {
 		mm->mmap_base = mmap_base();
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
-		if (!(current->personality & READ_IMPLIES_EXEC)
-		    && mmap_is_ia32())
+		if (!(current->personality & READ_IMPLIES_EXEC) &&
+				mmap_is_ia32() &&
+				get_exec_env()->ascii_armor) {
 			mm->get_unmapped_exec_area = arch_get_unmapped_exec_area;
+			mm->lib_mmap_base = mmap_lib_base();
+		}
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
 }
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/Documentation/sysctl/fs.txt linux-2.6.32/Documentation/sysctl/fs.txt
--- linux-2.6.32-ovz/linux-2.6.32/Documentation/sysctl/fs.txt	2012-10-18 14:08:46.568774684 +0400
+++ linux-2.6.32/Documentation/sysctl/fs.txt	2012-10-18 14:09:23.956775684 +0400
@@ -32,6 +32,9 @@ Currently, these files are in /proc/sys/
 - nr_open
 - overflowuid
 - overflowgid
+- protected_fifos
+- protected_hardlinks
+- protected_symlinks
 - suid_dumpable
 - super-max
 - super-nr
@@ -158,6 +161,64 @@ The default is 65534.
 
 ==============================================================
 
+protected_fifos:
+
+This option restricts writes
+into untrusted FIFOs (named pipes), to make data spoofing attacks harder.
+Enabling this option disallows writing into FIFOs not owned by the user in
++t directories, unless the owner is the same as that of the directory or
+the FIFO is opened without the O_CREAT flag.
+
+When set to "0", fifos opening behavior is unrestricted.
+
+When set to "1" fifos cannot be opened by users if they don't explicitly pass
+the O_CREAT flag.
+
+This protection is based on the restrictions in Openwall patch for 2.4 kernel
+and grsecurity patch for 2.6/3.0 kernels.
+
+==============================================================
+
+protected_hardlinks:
+
+A long-standing class of security issues is the hardlink-based
+time-of-check-time-of-use race, most commonly seen in world-writable
+directories like /tmp. The common method of exploitation of this flaw
+is to cross privilege boundaries when following a given hardlink (i.e. a
+root process follows a hardlink created by another user). Additionally,
+on systems without separated partitions, this stops unauthorized users
+from "pinning" vulnerable setuid/setgid files against being upgraded by
+the administrator, or linking to special files.
+
+When set to "0", hardlink creation behavior is unrestricted.
+
+When set to "1" hardlinks cannot be created by users if they do not
+already own the source file, or do not have read/write access to it.
+
+This protection is based on the restrictions in Openwall and grsecurity.
+
+==============================================================
+
+protected_symlinks:
+
+A long-standing class of security issues is the symlink-based
+time-of-check-time-of-use race, most commonly seen in world-writable
+directories like /tmp. The common method of exploitation of this flaw
+is to cross privilege boundaries when following a given symlink (i.e. a
+root process follows a symlink belonging to another user). For a likely
+incomplete list of hundreds of examples across the years, please see:
+http://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=/tmp
+
+When set to "0", symlink following behavior is unrestricted.
+
+When set to "1" symlinks are permitted to be followed only when outside
+a sticky world-writable directory, or when the uid of the symlink and
+follower match, or when the directory owner matches the symlink's owner.
+
+This protection is based on the restrictions in Openwall and grsecurity.
+
+==============================================================
+
 suid_dumpable:
 
 This value can be used to query and set the core dump mode for setuid
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/Documentation/sysctl/kernel.txt linux-2.6.32/Documentation/sysctl/kernel.txt
--- linux-2.6.32-ovz/linux-2.6.32/Documentation/sysctl/kernel.txt	2012-10-18 14:08:46.568774684 +0400
+++ linux-2.6.32/Documentation/sysctl/kernel.txt	2012-10-18 14:09:23.956775684 +0400
@@ -28,11 +28,13 @@ show up in /proc/sys/kernel:
 - dentry-state
 - dmesg_restrict
 - domainname
+- execstack_mode
 - hostname
 - hotplug
 - java-appletviewer           [ binfmt_java, obsolete ]
 - java-interpreter            [ binfmt_java, obsolete ]
 - kptr_restrict
+- kref_overflow_action
 - kstack_depth_to_print       [ X86 only ]
 - l2cr                        [ PPC only ]
 - modprobe                    ==> Documentation/debugging-modules.txt
@@ -65,8 +67,10 @@ show up in /proc/sys/kernel:
 - sysrq                       ==> Documentation/sysrq.txt
 - tainted
 - threads-max
+- uaccess_overflow_action
 - unknown_nmi_panic
 - version
+- vm86_permission
 
 ==============================================================
 
@@ -218,6 +222,40 @@ see the hostname(1) man page.
 
 ==============================================================
 
+execstack_mode:
+
+There are some programs and libraries that for one reason or another
+attempt to execute special small code snippets from non-executable
+memory pages.  Most notable examples are the signal handler return code
+generated by the kernel itself and the GCC trampolines.
+
+GCC generates trampolines on the stack to correctly pass control to
+nested functions when calling from outside. Normally, this requires the
+stack being executable.  When trampolines emulation is enabled, the
+kernel will trap faults resulting from trampoline calls, and will
+emulate the trampolines.  However, in some cases this autodetection can
+be fooled in a buffer overflow exploit, so, if you've got no programs
+that use GCC trampolines, it is more secure to disable emulation.
+
+This sysctl specifies how executable stack requests are handled.
+It can take numeric values, which can be ORed together:
+
+1 - if PT_GNU_STACK section demands executable stack, handle it as if it
+    demands nonexecutable stack.
+2 - if PT_GNU_STACK section demands executable stack, emulate GCC
+    trampolines.
+4 - if no PT_GNU_STACK section is present in ELF executable file, handle
+    it as if it presents and demands nonexecutable stack.
+8 - if no PT_GNU_STACK section is present in ELF executable file,
+    emulate GCC trampolines.
+16 - if PT_GNU_STACK is present and doesn't demand executable stack,
+    emulate GCC trampolines.
+
+(16) may be useful in case of some library demands executable stack, but
+the executable file doesn't.
+
+==============================================================
+
 hotplug:
 
 Path for the hotplug policy agent.
@@ -245,6 +283,25 @@ regardless of privileges.
 
 ==============================================================
 
+kref_overflow_action:
+
+The kernel detects and prevent overflowing various (but not all)
+kinds of object reference counters.  Such overflows can normally
+occur due to bugs only and are often, if not always, exploitable.
+
+The behaviour is configurable via kernel.kref_overflow_action
+sysctl.  Possible values:
+
+2 - kernel panics on kref overflow
+1 - kernel writes down kernel stack trace, kills current task,
+    and pins the kref in memory (default)
+0 - fully disables the check
+
+Please note that disabling the check via sysctl is still slower
+than disabling it via config option.
+
+==============================================================
+
 kstack_depth_to_print: (X86 only)
 
 Controls the number of words to print when dumping the raw
@@ -523,6 +580,24 @@ oprofile may have more registers to util
 
 ==============================================================
 
+uaccess_overflow_action:
+
+The kernel enforces the size of heap and stack objects when they
+are copied in either direction between the kernel and userland.
+
+The behaviour is configurable via kernel.uaccess_overflow_action
+sysctl.  Possible values:
+
+2 - kernel panics on copy overflow
+1 - kernel writes down kernel stack trace and kills current task
+    (default)
+0 - fully disables the check
+
+Please note that disabling the check via sysctl is still slower
+than disabling it via config option.
+
+==============================================================
+
 unknown_nmi_panic:
 
 The value in this file affects behavior of handling NMI. When the value is
@@ -545,3 +620,22 @@ A small number of systems do generate NM
 power management so the default is off. That sysctl works like the existing
 panic controls already in that directory.
 
+==============================================================
+
+vm86_permission:
+ 
+On x86 processors, the Virtual 8086 (VM86) mode allows the execution of real
+mode operating systems and applications (primarily DOS) under protected mode
+operating systems such as Linux (with dosemu).  This requires support from the
+kernel.  Although the amount of kernel code needed to support the VM86 mode is
+small and no security problems with it are currently known, that code is
+unused on most Linux systems and as such it poses an unreasonable risk.  This
+option restricts access to system calls used to enter the VM86 mode (vm86 and
+vm86old) in current pid namespace (e.g. OpenVZ container).
+
+Possible values:
+
+0 - syscalls are allowed to any process
+1 - syscalls are allowed to processes with CAP_SYS_RAWIO capability
+2 - syscalls are allowed to processes with CAP_SYS_ADMIN capability.  If set
+    to 2, only processes with CAP_SYS_ADMIN capability may change the sysctl.
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/drivers/char/mem.c linux-2.6.32/drivers/char/mem.c
--- linux-2.6.32-ovz/linux-2.6.32/drivers/char/mem.c	2012-10-18 14:08:46.672774686 +0400
+++ linux-2.6.32/drivers/char/mem.c	2012-10-18 14:09:23.956775684 +0400
@@ -164,7 +164,7 @@ static ssize_t read_mem(struct file * fi
 		if (!ptr)
 			return -EFAULT;
 
-		if (copy_to_user(buf, ptr, sz)) {
+		if (copy_to_user_nouccheck(buf, ptr, sz)) {
 			unxlate_dev_mem_ptr(p, ptr);
 			return -EFAULT;
 		}
@@ -447,7 +447,7 @@ static ssize_t read_kmem(struct file *fi
 			 */
 			kbuf = xlate_dev_kmem_ptr((char *)p);
 
-			if (copy_to_user(buf, kbuf, sz))
+			if (copy_to_user_nouccheck(buf, kbuf, sz))
 				return -EFAULT;
 			buf += sz;
 			p += sz;
@@ -469,7 +469,7 @@ static ssize_t read_kmem(struct file *fi
 			len = vread(kbuf, (char *)p, len);
 			if (!len)
 				break;
-			if (copy_to_user(buf, kbuf, len)) {
+			if (copy_to_user_nouccheck(buf, kbuf, len)) {
 				free_page((unsigned long)kbuf);
 				return -EFAULT;
 			}
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/drivers/char/vt.c linux-2.6.32/drivers/char/vt.c
--- linux-2.6.32-ovz/linux-2.6.32/drivers/char/vt.c	2012-10-18 14:08:46.680774687 +0400
+++ linux-2.6.32/drivers/char/vt.c	2012-10-18 14:09:23.960775684 +0400
@@ -159,7 +159,7 @@ static void blank_screen_t(unsigned long
 static void set_palette(struct vc_data *vc);
 
 static int printable;		/* Is console ready for printing? */
-int default_utf8 = true;
+int default_utf8 = false;
 module_param(default_utf8, int, S_IRUGO | S_IWUSR);
 
 /*
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/drivers/edac/sb_edac.c linux-2.6.32/drivers/edac/sb_edac.c
--- linux-2.6.32-ovz/linux-2.6.32/drivers/edac/sb_edac.c	2012-10-18 14:08:46.700774687 +0400
+++ linux-2.6.32/drivers/edac/sb_edac.c	2012-10-18 14:09:23.960775684 +0400
@@ -673,6 +673,7 @@ static void get_memory_layout(const stru
 	u32 reg;
 	u64 limit, prv = 0;
 	u64 tmp_mb;
+	u32 mb, kb;
 	u32 rir_way;
 
 	/*
@@ -684,9 +685,10 @@ static void get_memory_layout(const stru
 			      &reg);
 	pvt->tolm = GET_TOLM(reg);
 	tmp_mb = (1 + pvt->tolm) >> 20;
+	mb = div_u64_rem(tmp_mb, 1000, &kb);
 
 	debugf0("TOLM: %Lu.%03Lu GB (0x%016Lx)\n",
-		tmp_mb / 1000, tmp_mb % 1000, (u64)pvt->tolm);
+		mb, kb, (u64)pvt->tolm);
 
 	/* Address range is already 45:25 */
 	pci_read_config_dword(pvt->pci_sad1, TOHM,
@@ -695,7 +697,7 @@ static void get_memory_layout(const stru
 	tmp_mb = (1 + pvt->tohm) >> 20;
 
 	debugf0("TOHM: %Lu.%03Lu GB (0x%016Lx)",
-		tmp_mb / 1000, tmp_mb % 1000, (u64)pvt->tohm);
+		mb, kb, (u64)pvt->tohm);
 
 	/*
 	 * Step 2) Get SAD range and SAD Interleave list
@@ -720,7 +722,7 @@ static void get_memory_layout(const stru
 		debugf0("SAD#%d %s up to %Lu.%03Lu GB (0x%016Lx) %s reg=0x%08x\n",
 			n_sads,
 			get_dram_attr(reg),
-			tmp_mb / 1000, tmp_mb % 1000,
+			mb, kb,
 			((u64)tmp_mb) << 20L,
 			INTERLEAVE_MODE(reg) ? "Interleave: 8:6" : "Interleave: [8:6]XOR[18:16]",
 			reg);
@@ -751,7 +753,7 @@ static void get_memory_layout(const stru
 		tmp_mb = (limit + 1) >> 20;
 
 		debugf0("TAD#%d: up to %Lu.%03Lu GB (0x%016Lx), socket interleave %d, memory interleave %d, TGT: %d, %d, %d, %d, reg=0x%08x\n",
-			n_tads, tmp_mb / 1000, tmp_mb % 1000,
+			n_tads, mb, kb,
 			((u64)tmp_mb) << 20L,
 			(u32)TAD_SOCK(reg),
 			(u32)TAD_CH(reg),
@@ -776,7 +778,7 @@ static void get_memory_layout(const stru
 			tmp_mb = TAD_OFFSET(reg) >> 20;
 			debugf0("TAD CH#%d, offset #%d: %Lu.%03Lu GB (0x%016Lx), reg=0x%08x\n",
 				i, j,
-				tmp_mb / 1000, tmp_mb % 1000,
+				mb, kb,
 				((u64)tmp_mb) << 20L,
 				reg);
 		}
@@ -800,7 +802,7 @@ static void get_memory_layout(const stru
 			rir_way = 1 << RIR_WAY(reg);
 			debugf0("CH#%d RIR#%d, limit: %Lu.%03Lu GB (0x%016Lx), way: %d, reg=0x%08x\n",
 				i, j,
-				tmp_mb / 1000, tmp_mb % 1000,
+				mb, kb,
 				((u64)tmp_mb) << 20L,
 				rir_way,
 				reg);
@@ -813,7 +815,7 @@ static void get_memory_layout(const stru
 
 				debugf0("CH#%d RIR#%d INTL#%d, offset %Lu.%03Lu GB (0x%016Lx), tgt: %d, reg=0x%08x\n",
 					i, j, k,
-					tmp_mb / 1000, tmp_mb % 1000,
+					mb, kb,
 					((u64)tmp_mb) << 20L,
 					(u32)RIR_RNK_TGT(reg),
 					reg);
@@ -851,6 +853,7 @@ static int get_memory_error_data(struct
 	u8			ch_way,sck_way;
 	u32			tad_offset;
 	u32			rir_way;
+	u32			mb, kb;
 	u64			ch_addr, offset, limit, prv = 0;
 
 
@@ -1076,10 +1079,11 @@ static int get_memory_error_data(struct
 			continue;
 
 		limit = RIR_LIMIT(reg);
+		mb = div_u64_rem(limit >> 20, 1000, &kb);
 
 		debugf0("RIR#%d, limit: %Lu.%03Lu GB (0x%016Lx), way: %d\n",
 			n_rir,
-			(limit >> 20) / 1000, (limit >> 20) % 1000,
+			mb, kb,
 			limit,
 			1 << RIR_WAY(reg));
 		if  (ch_addr <= limit)
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/drivers/message/fusion/Kconfig linux-2.6.32/drivers/message/fusion/Kconfig
--- linux-2.6.32-ovz/linux-2.6.32/drivers/message/fusion/Kconfig	2009-12-03 06:51:21.000000000 +0300
+++ linux-2.6.32/drivers/message/fusion/Kconfig	2012-10-18 14:09:23.960775684 +0400
@@ -59,6 +59,7 @@ config FUSION_SAS
 	  LSISAS1064E
 	  LSISAS1068E
 	  LSISAS1078
+	  LSISAS8208ELP
 
 config FUSION_MAX_SGE
 	int "Maximum number of scatter gather entries (16 - 128)"
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/drivers/message/fusion/lsi/mpi_cnfg.h linux-2.6.32/drivers/message/fusion/lsi/mpi_cnfg.h
--- linux-2.6.32-ovz/linux-2.6.32/drivers/message/fusion/lsi/mpi_cnfg.h	2012-10-18 14:08:48.524774736 +0400
+++ linux-2.6.32/drivers/message/fusion/lsi/mpi_cnfg.h	2012-10-18 14:09:23.960775684 +0400
@@ -585,6 +585,7 @@ typedef struct _MSG_CONFIG_REPLY
 #define MPI_MANUFACTPAGE_DEVID_SAS1068E             (0x0058)
 #define MPI_MANUFACTPAGE_DEVID_SAS1068_820XELP      (0x0059)
 #define MPI_MANUFACTPAGE_DEVID_SAS1078              (0x0062)
+#define MPI_MANUFACTPAGE_DEVID_SAS8208ELP           (0x0059)
 
 
 typedef struct _CONFIG_PAGE_MANUFACTURING_0
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/drivers/message/fusion/mptbase.c linux-2.6.32/drivers/message/fusion/mptbase.c
--- linux-2.6.32-ovz/linux-2.6.32/drivers/message/fusion/mptbase.c	2012-10-18 14:08:48.524774736 +0400
+++ linux-2.6.32/drivers/message/fusion/mptbase.c	2012-10-18 14:09:23.964775685 +0400
@@ -1527,6 +1527,7 @@ mpt_get_product_name(u16 vendor, u16 dev
 		}
 		break;
 	case MPI_MANUFACTPAGE_DEVID_SAS1068E:
+	case MPI_MANUFACTPAGE_DEVID_SAS8208ELP:
 		switch (revision)
 		{
 		case 0x00:
@@ -1893,6 +1894,7 @@ mpt_attach(struct pci_dev *pdev, const s
 	case MPI_MANUFACTPAGE_DEVID_SAS1064E:
 	case MPI_MANUFACTPAGE_DEVID_SAS1068E:
 	case MPI_MANUFACTPAGE_DEVID_SAS1078:
+	case MPI_MANUFACTPAGE_DEVID_SAS8208ELP:
 		ioc->bus_type = SAS;
 		break;
 	}
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/drivers/message/fusion/mptsas.c linux-2.6.32/drivers/message/fusion/mptsas.c
--- linux-2.6.32-ovz/linux-2.6.32/drivers/message/fusion/mptsas.c	2012-10-18 14:08:48.532774737 +0400
+++ linux-2.6.32/drivers/message/fusion/mptsas.c	2012-10-18 14:09:23.964775685 +0400
@@ -5369,6 +5369,8 @@ static struct pci_device_id mptsas_pci_t
 		PCI_ANY_ID, PCI_ANY_ID },
 	{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVID_SAS1068_820XELP,
 		PCI_ANY_ID, PCI_ANY_ID },
+	{ PCI_VENDOR_ID_LSI_LOGIC, MPI_MANUFACTPAGE_DEVID_SAS8208ELP,
+		PCI_ANY_ID, PCI_ANY_ID },
 	{0}	/* Terminating entry */
 };
 MODULE_DEVICE_TABLE(pci, mptsas_pci_table);
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/binfmt_elf.c linux-2.6.32/fs/binfmt_elf.c
--- linux-2.6.32-ovz/linux-2.6.32/fs/binfmt_elf.c	2012-10-18 14:08:51.324774811 +0400
+++ linux-2.6.32/fs/binfmt_elf.c	2012-10-18 14:09:35.880776004 +0400
@@ -32,12 +32,12 @@
 #include <linux/elf.h>
 #include <linux/utsname.h>
 #include <linux/coredump.h>
+#include <linux/pid_namespace.h>
 #include <asm/uaccess.h>
 #include <asm/param.h>
 #include <asm/page.h>
 
 static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs);
-static int load_elf_library(struct file *);
 static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,
 				int, int, unsigned long);
 
@@ -68,7 +68,6 @@ static int elf_core_dump(struct coredump
 struct linux_binfmt elf_format = {
 		.module		= THIS_MODULE,
 		.load_binary	= load_elf_binary,
-		.load_shlib	= load_elf_library,
 		.core_dump	= elf_core_dump,
 		.min_coredump	= ELF_EXEC_PAGESIZE,
 		.hasvdso	= 1
@@ -137,6 +136,20 @@ static int padzero(unsigned long elf_bss
 #define ELF_BASE_PLATFORM NULL
 #endif
 
+static elf_addr_t get_at_flags(void)
+{
+	enum execstack_mode stack = current->nsproxy->pid_ns->execstack_mode;
+	elf_addr_t flags = 0;
+
+	if (stack & GNU_STACK_X_FORCE_NX)
+		flags |= 1;
+	if (stack & NO_GNU_STACK_FORCE_NX)
+		flags |= 2;
+
+	return flags;
+}
+
+
 static int
 create_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,
 		unsigned long load_addr, unsigned long interp_load_addr)
@@ -158,6 +171,7 @@ create_elf_tables(struct linux_binprm *b
 	int ei_index = 0;
 	const struct cred *cred = current_cred();
 	struct vm_area_struct *vma;
+	elf_addr_t at_flags = get_at_flags();
 
 	/*
 	 * In some cases (e.g. Hyper-Threading), we want to avoid L1
@@ -229,7 +243,7 @@ create_elf_tables(struct linux_binprm *b
 	NEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));
 	NEW_AUX_ENT(AT_PHNUM, exec->e_phnum);
 	NEW_AUX_ENT(AT_BASE, interp_load_addr);
-	NEW_AUX_ENT(AT_FLAGS, 0);
+	NEW_AUX_ENT(AT_FLAGS, at_flags);
 	NEW_AUX_ENT(AT_ENTRY, exec->e_entry);
 	NEW_AUX_ENT(AT_UID, cred->uid);
 	NEW_AUX_ENT(AT_EUID, cred->euid);
@@ -564,6 +578,62 @@ static unsigned long randomize_stack_top
 #endif
 }
 
+static int get_execstack(bool gnu_stack_present, int p_flags)
+{
+	struct pid_namespace *ns = current->nsproxy->pid_ns;
+	int pf_x;
+
+	if (gnu_stack_present) {
+		pf_x = p_flags & PF_X;
+		/* GNU_STACK => NX */
+		if (!pf_x) {
+			pr_debug("%s, pid %d: GNU_FLAGS=NX, EXSTACK_DISABLE_X\n",
+				current->comm, task_pid_nr(current));
+			return EXSTACK_DISABLE_X;
+		}
+
+		/* GNU_STACK => X */
+		if (ns->execstack_mode & GNU_STACK_X_FORCE_NX) {
+			pr_debug("%s, pid %d: GNU_FLAGS=X, EXSTACK_DISABLE_X\n",
+				current->comm, task_pid_nr(current));
+			return EXSTACK_DISABLE_X;
+		}
+
+		pr_debug("%s, pid %d: GNU_FLAGS=X, EXSTACK_ENABLE_X\n",
+			current->comm, task_pid_nr(current));
+		return EXSTACK_ENABLE_X;
+	} else {
+		/* GNU_STACK => ? */
+		if (ns->execstack_mode & NO_GNU_STACK_FORCE_NX) {
+		pr_debug("%s, pid %d: GNU_FLAGS=?, EXSTACK_DISABLE_X\n",
+			current->comm, task_pid_nr(current));
+			return EXSTACK_DISABLE_X;
+		}
+
+		pr_debug("%s, pid %d: GNU_FLAGS=?, EXSTACK_DEFAULT\n",
+			current->comm, task_pid_nr(current));
+		return EXSTACK_DEFAULT;
+	}
+}
+
+static bool need_emultramp(bool gnu_stack_present, int p_flags)
+{
+	struct pid_namespace *ns = current->nsproxy->pid_ns;
+	int pf_x;
+
+	if (gnu_stack_present) {
+		pf_x = p_flags & PF_X;
+		if (pf_x)
+			return ns->execstack_mode & GNU_STACK_X_EMULTRAMP;
+		else
+			return ns->execstack_mode & GNU_STACK_NX_EMULTRAMP;
+	} else {
+		/* GNU_STACK => ? */
+		return ns->execstack_mode & NO_GNU_STACK_EMULTRAMP;
+	}
+
+}
+
 static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
 {
 	struct file *interpreter = NULL; /* to shut gcc up */
@@ -579,12 +649,14 @@ static int load_elf_binary(struct linux_
 	unsigned long interp_load_addr = 0;
 	unsigned long start_code, end_code, start_data, end_data;
 	unsigned long reloc_func_desc = 0;
-	int executable_stack = EXSTACK_DEFAULT;
+	int executable_stack;
 	unsigned long def_flags = 0;
 	struct {
 		struct elfhdr elf_ex;
 		struct elfhdr interp_elf_ex;
 	} *loc;
+	bool gnu_stack_present = false;
+	int gnu_stack_flags = 0; /* unused value */
 
 	loc = kmalloc(sizeof(*loc), GFP_KERNEL);
 	if (!loc) {
@@ -697,18 +769,22 @@ static int load_elf_binary(struct linux_
 	elf_ppnt = elf_phdata;
 	for (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)
 		if (elf_ppnt->p_type == PT_GNU_STACK) {
-			if (elf_ppnt->p_flags & PF_X)
-				executable_stack = EXSTACK_ENABLE_X;
-			else
-				executable_stack = EXSTACK_DISABLE_X;
-			break;
+			gnu_stack_present = true;
+			gnu_stack_flags = elf_ppnt->p_flags;
 		}
 
+	executable_stack = get_execstack(gnu_stack_present, gnu_stack_flags);
+	if (need_emultramp(gnu_stack_present, gnu_stack_flags))
+		current->flags |= PF_EMULTRAMP;
+
 	if (current->personality == PER_LINUX && (exec_shield & 2)) {
 		executable_stack = EXSTACK_DISABLE_X;
 		current->flags |= PF_RANDOMIZE;
 	}
 
+	pr_debug("%s, pid %d: PF_EMULTRAMP = %d\n",
+		current->comm, task_pid_nr(current), !!(current->flags & PF_EMULTRAMP));
+
 	/* Some simple consistency checks for the interpreter */
 	if (elf_interpreter) {
 		retval = -ELIBBAD;
@@ -1000,6 +1076,7 @@ static int load_elf_binary(struct linux_
 out:
 	kfree(loc);
 out_ret:
+	arch_post_exec_elf(retval, ELF_CLASS);
 	return retval;
 
 	/* error cleanup */
@@ -1014,90 +1091,6 @@ out_free_ph:
 	goto out;
 }
 
-/* This is really simpleminded and specialized - we are loading an
-   a.out library that is given an ELF header. */
-static int load_elf_library(struct file *file)
-{
-	struct elf_phdr *elf_phdata;
-	struct elf_phdr *eppnt;
-	unsigned long elf_bss, bss, len;
-	int retval, error, i, j;
-	struct elfhdr elf_ex;
-
-	error = -ENOEXEC;
-	retval = kernel_read(file, 0, (char *)&elf_ex, sizeof(elf_ex));
-	if (retval != sizeof(elf_ex))
-		goto out;
-
-	if (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)
-		goto out;
-
-	/* First of all, some simple consistency checks */
-	if (elf_ex.e_type != ET_EXEC || elf_ex.e_phnum > 2 ||
-	    !elf_check_arch(&elf_ex) || !file->f_op || !file->f_op->mmap)
-		goto out;
-
-	/* Now read in all of the header information */
-
-	j = sizeof(struct elf_phdr) * elf_ex.e_phnum;
-	/* j < ELF_MIN_ALIGN because elf_ex.e_phnum <= 2 */
-
-	error = -ENOMEM;
-	elf_phdata = kmalloc(j, GFP_KERNEL);
-	if (!elf_phdata)
-		goto out;
-
-	eppnt = elf_phdata;
-	error = -ENOEXEC;
-	retval = kernel_read(file, elf_ex.e_phoff, (char *)eppnt, j);
-	if (retval != j)
-		goto out_free_ph;
-
-	for (j = 0, i = 0; i<elf_ex.e_phnum; i++)
-		if ((eppnt + i)->p_type == PT_LOAD)
-			j++;
-	if (j != 1)
-		goto out_free_ph;
-
-	while (eppnt->p_type != PT_LOAD)
-		eppnt++;
-
-	/* Now use mmap to map the library into memory. */
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap(file,
-			ELF_PAGESTART(eppnt->p_vaddr),
-			(eppnt->p_filesz +
-			 ELF_PAGEOFFSET(eppnt->p_vaddr)),
-			PROT_READ | PROT_WRITE | PROT_EXEC,
-			MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,
-			(eppnt->p_offset -
-			 ELF_PAGEOFFSET(eppnt->p_vaddr)));
-	up_write(&current->mm->mmap_sem);
-	if (error != ELF_PAGESTART(eppnt->p_vaddr))
-		goto out_free_ph;
-
-	elf_bss = eppnt->p_vaddr + eppnt->p_filesz;
-	if (padzero(elf_bss)) {
-		error = -EFAULT;
-		goto out_free_ph;
-	}
-
-	len = ELF_PAGESTART(eppnt->p_filesz + eppnt->p_vaddr +
-			    ELF_MIN_ALIGN - 1);
-	bss = eppnt->p_memsz + eppnt->p_vaddr;
-	if (bss > len) {
-		down_write(&current->mm->mmap_sem);
-		do_brk(len, bss - len);
-		up_write(&current->mm->mmap_sem);
-	}
-	error = 0;
-
-out_free_ph:
-	kfree(elf_phdata);
-out:
-	return error;
-}
-
 /*
  * Note that some platforms still use traditional core dumps and not
  * the ELF core dump.  Each platform can select it as appropriate.
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/binfmt_script.c linux-2.6.32/fs/binfmt_script.c
--- linux-2.6.32-ovz/linux-2.6.32/fs/binfmt_script.c	2009-12-03 06:51:21.000000000 +0300
+++ linux-2.6.32/fs/binfmt_script.c	2012-10-18 14:09:35.880776004 +0400
@@ -98,7 +98,7 @@ static int load_script(struct linux_binp
 	return search_binary_handler(bprm,regs);
 }
 
-static struct linux_binfmt script_format = {
+struct linux_binfmt script_format = {
 	.module		= THIS_MODULE,
 	.load_binary	= load_script,
 };
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/compat.c linux-2.6.32/fs/compat.c
--- linux-2.6.32-ovz/linux-2.6.32/fs/compat.c	2012-10-18 14:08:51.392774812 +0400
+++ linux-2.6.32/fs/compat.c	2012-10-18 14:09:35.880776004 +0400
@@ -56,6 +56,8 @@
 #include <asm/ioctls.h>
 #include "internal.h"
 
+extern atomic64_t global_exec_counter;
+
 int compat_log = 1;
 
 int compat_printk(const char *fmt, ...)
@@ -1528,6 +1530,19 @@ int compat_do_execve(char * filename,
 	if (retval)
 		goto out_ret;
 
+	/*
+	 * We check for RLIMIT_NPROC in execve() instead of set_user() because
+	 * too many poorly written programs don't check setuid() return code.
+	 * The check in execve() does the same thing for programs doing
+	 * setuid()+execve(), but without similar security issues.
+	 */
+	if (atomic_read(&current_cred()->user->processes) >
+			current->signal->rlim[RLIMIT_NPROC].rlim_cur &&
+			current_cred()->uid != 0) {
+		retval = -EAGAIN;
+		goto out_ret;
+	}
+
 	retval = -ENOMEM;
 	bprm = kzalloc(sizeof(*bprm), GFP_KERNEL);
 	if (!bprm)
@@ -1588,6 +1603,7 @@ int compat_do_execve(char * filename,
 		goto out;
 
 	/* execve succeeded */
+	current->exec_id = atomic64_inc_return(&global_exec_counter);
 	current->fs->in_exec = 0;
 	current->in_execve = 0;
 	acct_update_integrals(current);
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/exec.c linux-2.6.32/fs/exec.c
--- linux-2.6.32-ovz/linux-2.6.32/fs/exec.c	2012-10-18 14:08:51.408774814 +0400
+++ linux-2.6.32/fs/exec.c	2012-10-18 14:09:35.884776006 +0400
@@ -227,7 +227,8 @@ struct page *get_arg_page(struct linux_b
 		 *    to work from.
 		 */
 		rlim = current->signal->rlim;
-		if (size > rlim[RLIMIT_STACK].rlim_cur / 4) {
+		if (size > rlim[RLIMIT_STACK].rlim_cur / 4 ||
+			size > MAX_ARG_STACK) {
 			put_page(page);
 			return NULL;
 		}
@@ -1330,6 +1331,8 @@ out:
 }
 EXPORT_SYMBOL(remove_arg_zero);
 
+extern bool arch_check_interpreter(struct linux_binfmt *fmt);
+
 /*
  * cycle the list of binary formats handler, until one recognizes the image
  */
@@ -1358,6 +1361,8 @@ int search_binary_handler(struct linux_b
 			int (*fn)(struct linux_binprm *, struct pt_regs *) = fmt->load_binary;
 			if (!fn)
 				continue;
+			if (!arch_check_interpreter(fmt))
+				continue;
 			if (!try_module_get(fmt->module))
 				continue;
 			read_unlock(&binfmt_lock);
@@ -1409,6 +1414,8 @@ int search_binary_handler(struct linux_b
 
 EXPORT_SYMBOL(search_binary_handler);
 
+atomic64_t global_exec_counter = ATOMIC64_INIT(0);
+
 /*
  * sys_execve() executes a new program.
  */
@@ -1427,6 +1434,19 @@ int do_execve(char * filename,
 	if (retval)
 		goto out_ret;
 
+	/*
+	 * We check for RLIMIT_NPROC in execve() instead of set_user() because
+	 * too many poorly written programs don't check setuid() return code.
+	 * The check in execve() does the same thing for programs doing
+	 * setuid()+execve(), but without similar security issues.
+	 */
+	if (atomic_read(&current_cred()->user->processes) >
+			current->signal->rlim[RLIMIT_NPROC].rlim_cur &&
+			current_cred()->uid != 0) {
+		retval = -EAGAIN;
+		goto out_ret;
+	}
+
 	retval = -ENOMEM;
 	bprm = kzalloc(sizeof(*bprm), GFP_KERNEL);
 	if (!bprm)
@@ -1488,9 +1508,11 @@ int do_execve(char * filename,
 		goto out;
 
 	/* execve succeeded */
+	current->exec_id = atomic64_inc_return(&global_exec_counter);
 	current->fs->in_exec = 0;
 	current->in_execve = 0;
 	acct_update_integrals(current);
+	arch_post_execve();
 	free_bprm(bprm);
 	if (displaced)
 		put_files_struct(displaced);
@@ -1520,6 +1542,7 @@ out_files:
 	if (displaced)
 		reset_files_struct(displaced);
 out_ret:
+	arch_post_execve();
 	return retval;
 }
 
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/Kconfig linux-2.6.32/fs/Kconfig
--- linux-2.6.32-ovz/linux-2.6.32/fs/Kconfig	2012-10-18 14:08:51.484774815 +0400
+++ linux-2.6.32/fs/Kconfig	2012-10-18 14:09:35.884776006 +0400
@@ -66,6 +66,7 @@ source "fs/fuse/Kconfig"
 config SIM_FS
 	tristate "VPS filesystem"
 	default m
+	select EXPORTFS
 	help
 	  This file system is a part of Virtuozzo. It intoduces a fake
 	  superblock and blockdev to VE to hide real device and show
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/namei.c linux-2.6.32/fs/namei.c
--- linux-2.6.32-ovz/linux-2.6.32/fs/namei.c	2012-10-18 14:08:51.488774815 +0400
+++ linux-2.6.32/fs/namei.c	2012-10-18 14:09:35.884776006 +0400
@@ -583,6 +583,115 @@ static inline void path_to_nameidata(str
 	nd->path.dentry = path->dentry;
 }
 
+/**
+ * may_follow_link - Check symlink following for unsafe situations
+ * @link: The path of the symlink
+ *
+ * In the case of the sysctl_protected_symlinks sysctl being enabled,
+ * CAP_DAC_OVERRIDE needs to be specifically ignored if the symlink is
+ * in a sticky world-writable directory. This is to protect privileged
+ * processes from failing races against path names that may change out
+ * from under them by way of other users creating malicious symlinks.
+ * It will permit symlinks to be followed only when outside a sticky
+ * world-writable directory, or when the uid of the symlink and follower
+ * match, or when the directory owner matches the symlink's owner.
+ *
+ * Returns 0 if following the symlink is allowed, -ve on error.
+ */
+static inline int may_follow_link(struct path *link, struct nameidata *nd)
+{
+	const struct inode *inode;
+	const struct inode *parent;
+
+	if (!get_exec_env()->protected_symlinks)
+		return 0;
+
+	/* Allowed if owner and follower match. */
+	inode = link->dentry->d_inode;
+	if (current_fsuid() == inode->i_uid)
+		return 0;
+
+	/* Allowed if parent directory not sticky and world-writable. */
+	parent = nd->path.dentry->d_inode;
+	if ((parent->i_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))
+		return 0;
+
+	/* Allowed if parent directory and link owner match. */
+	if (parent->i_uid == inode->i_uid)
+		return 0;
+
+	return -EACCES;
+}
+
+/**
+ * safe_hardlink_source - Check for safe hardlink conditions
+ * @inode: the source inode to hardlink from
+ *
+ * Return false if at least one of the following conditions:
+ *    - inode is not a regular file
+ *    - inode is setuid
+ *    - inode is setgid and group-exec
+ *    - access failure for read and write
+ *
+ * Otherwise returns true.
+ */
+static bool safe_hardlink_source(struct inode *inode)
+{
+	umode_t mode = inode->i_mode;
+
+	/* Special files should not get pinned to the filesystem. */
+	if (!S_ISREG(mode))
+		return false;
+
+	/* Setuid files should not get pinned to the filesystem. */
+	if (mode & S_ISUID)
+		return false;
+
+	/* Executable setgid files should not get pinned to the filesystem. */
+	if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))
+		return false;
+
+	/* Hardlinking to unreadable or unwritable sources is dangerous. */
+	if (inode_permission(inode, MAY_READ | MAY_WRITE))
+		return false;
+
+	return true;
+}
+
+/**
+ * may_linkat - Check permissions for creating a hardlink
+ * @link: the source to hardlink from
+ *
+ * Block hardlink when all of:
+ *  - sysctl_protected_hardlinks enabled
+ *  - fsuid does not match inode
+ *  - hardlink source is unsafe (see safe_hardlink_source() above)
+ *  - not CAP_FOWNER
+ *
+ * Returns 0 if successful, -ve on error.
+ */
+static int may_linkat(struct path *link)
+{
+	const struct cred *cred;
+	struct inode *inode;
+
+	if (!get_exec_env()->protected_hardlinks)
+		return 0;
+
+	cred = current_cred();
+	inode = link->dentry->d_inode;
+
+	/* Source inode owner (or CAP_FOWNER) can hardlink all they like,
+	 * otherwise, it must be a safe source.
+	 */
+	if (cred->fsuid == inode->i_uid || safe_hardlink_source(inode) ||
+	    capable(CAP_FOWNER))
+		return 0;
+
+	return -EPERM;
+}
+
+
 static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)
 {
 	int error;
@@ -1154,6 +1263,9 @@ static int __link_path_walk(const char *
 			err = -ENOENT;
 			if (lookup_flags & LOOKUP_STRICT)
 				goto out_dput;
+			err = may_follow_link(&next, nd);
+			if (unlikely(err))
+				goto out_dput;
 			err = do_follow_link(&next, nd);
 			if (err)
 				goto return_err;
@@ -1199,6 +1311,9 @@ last_component:
 			break;
 		inode = next.dentry->d_inode;
 		if (follow_on_final(inode, lookup_flags)) {
+			err = may_follow_link(&next, nd);
+			if (unlikely(err))
+				goto out_dput;
 			err = do_follow_link(&next, nd);
 			if (err)
 				goto return_err;
@@ -1861,6 +1976,35 @@ static int open_will_truncate(int flag,
 	return (flag & O_TRUNC);
 }
 
+
+static inline int may_open_fifo(struct dentry *dentry, struct dentry *dir, int flag)
+{
+	const struct inode *inode;
+	const struct inode *parent;
+
+	if (flag & O_EXCL)
+		return 0;
+
+	if (!get_exec_env()->protected_fifos)
+		return 0;
+
+	/* Allowed if owner and follower match. */
+	inode = dentry->d_inode;
+	if (current_fsuid() == inode->i_uid)
+		return 0;
+
+	/* Allowed if parent directory not sticky and world-writable. */
+	parent = dir->d_inode;
+	if ((parent->i_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))
+		return 0;
+
+	/* Allowed if parent directory and link owner match. */
+	if (parent->i_uid == inode->i_uid)
+		return 0;
+
+	return -EACCES;
+}
+
 /*
  * Note that the low bits of the passed in "open_flag"
  * are not the same as in the local variable "flag". See
@@ -2003,6 +2147,13 @@ do_last:
 	/*
 	 * It already exists.
 	 */
+
+	if (S_ISFIFO(path.dentry->d_inode->i_mode)) {
+		error = may_open_fifo(path.dentry, dir, flag);
+		if (error)
+			goto exit_mutex_unlock;
+	}
+
 	mutex_unlock(&dir->d_inode->i_mutex);
 	audit_inode(pathname, path.dentry);
 
@@ -2752,6 +2903,9 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
 	error = -EXDEV;
 	if (old_path.mnt != nd.path.mnt)
 		goto out_release;
+	error = may_linkat(&old_path);
+	if (unlikely(error))
+		goto out_release;
 	new_dentry = lookup_create(&nd, 0);
 	error = PTR_ERR(new_dentry);
 	if (IS_ERR(new_dentry))
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/proc/base.c linux-2.6.32/fs/proc/base.c
--- linux-2.6.32-ovz/linux-2.6.32/fs/proc/base.c	2012-10-18 14:08:51.540774816 +0400
+++ linux-2.6.32/fs/proc/base.c	2012-10-18 14:09:35.888776006 +0400
@@ -975,6 +975,21 @@ static int proc_single_open(struct inode
 	return ret;
 }
 
+static int task_dumpable(struct task_struct *task)
+{
+	int dumpable = 0;
+	struct mm_struct *mm;
+
+	task_lock(task);
+	mm = task->mm;
+	if (mm)
+		dumpable = get_dumpable(mm);
+	task_unlock(task);
+	if(dumpable == 1)
+		return 1;
+	return 0;
+}
+
 static const struct file_operations proc_single_file_operations = {
 	.open		= proc_single_open,
 	.read		= seq_read,
@@ -1015,6 +1030,9 @@ static ssize_t mem_read(struct file * fi
 	if (file->private_data != (void*)((long)current->self_exec_id))
 		goto out_put;
 
+	if (!task_dumpable(task) && task == current)
+		goto out_put;
+
 	ret = 0;
  
 	while (count > 0) {
@@ -1832,21 +1850,6 @@ static const struct inode_operations pro
 
 /* building an inode */
 
-static int task_dumpable(struct task_struct *task)
-{
-	int dumpable = 0;
-	struct mm_struct *mm;
-
-	task_lock(task);
-	mm = task->mm;
-	if (mm)
-		dumpable = get_dumpable(mm);
-	task_unlock(task);
-	if(dumpable == 1)
-		return 1;
-	return 0;
-}
-
 
 static struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)
 {
@@ -2991,7 +2994,7 @@ static const struct pid_entry tgid_base_
 	INF("wchan",      S_IRUGO, proc_pid_wchan),
 #endif
 #ifdef CONFIG_STACKTRACE
-	ONE("stack",      S_IRUGO, proc_pid_stack),
+	ONE("stack",      S_IRUSR, proc_pid_stack),
 #endif
 #ifdef CONFIG_SCHEDSTATS
 	INF("schedstat",  S_IRUGO, proc_pid_schedstat),
@@ -3345,7 +3348,7 @@ static const struct pid_entry tid_base_s
 	INF("wchan",     S_IRUGO, proc_pid_wchan),
 #endif
 #ifdef CONFIG_STACKTRACE
-	ONE("stack",      S_IRUGO, proc_pid_stack),
+	ONE("stack",      S_IRUSR, proc_pid_stack),
 #endif
 #ifdef CONFIG_SCHEDSTATS
 	INF("schedstat", S_IRUGO, proc_pid_schedstat),
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/proc/kmsg.c linux-2.6.32/fs/proc/kmsg.c
--- linux-2.6.32-ovz/linux-2.6.32/fs/proc/kmsg.c	2012-10-18 14:08:51.544774816 +0400
+++ linux-2.6.32/fs/proc/kmsg.c	2012-10-20 14:02:47.822266470 +0400
@@ -16,37 +16,38 @@
 #include <linux/sched.h>
 #include <linux/module.h>
 #include <linux/ve.h>
+#include <linux/syslog.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
 extern wait_queue_head_t log_wait;
 
-extern int do_syslog(int type, char __user *bug, int count);
-
 static int kmsg_open(struct inode * inode, struct file * file)
 {
-	return do_syslog(1,NULL,0);
+	return do_syslog(1, NULL, 0, SYSLOG_FROM_FILE);
 }
 
 static int kmsg_release(struct inode * inode, struct file * file)
 {
-	(void) do_syslog(0,NULL,0);
+	(void) do_syslog(0, NULL, 0, SYSLOG_FROM_FILE);
 	return 0;
 }
 
 static ssize_t kmsg_read(struct file *file, char __user *buf,
 			 size_t count, loff_t *ppos)
 {
-	if ((file->f_flags & O_NONBLOCK) && !do_syslog(9, NULL, 0))
-		return -EAGAIN;
-	return do_syslog(2, buf, count);
+	if ((file->f_flags & O_NONBLOCK) &&
+	    !do_syslog(9, NULL, 0, SYSLOG_FROM_FILE))
+ 		return -EAGAIN;
+
+	return do_syslog(2, buf, count, SYSLOG_FROM_FILE);
 }
 
 static unsigned int kmsg_poll(struct file *file, poll_table *wait)
 {
 	poll_wait(file, &ve_log_wait, wait);
-	if (do_syslog(9, NULL, 0))
+	if (do_syslog(9, NULL, 0, SYSLOG_FROM_FILE))
 		return POLLIN | POLLRDNORM;
 	return 0;
 }
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/proc/root.c linux-2.6.32/fs/proc/root.c
--- linux-2.6.32-ovz/linux-2.6.32/fs/proc/root.c	2012-10-18 14:08:51.544774816 +0400
+++ linux-2.6.32/fs/proc/root.c	2012-10-18 14:09:35.888776006 +0400
@@ -128,12 +128,14 @@ static int proc_get_sb(struct file_syste
 	if (IS_ERR(sb))
 		return PTR_ERR(sb);
 
+	if (!proc_parse_options(options, ns)) {
+		deactivate_locked_super(sb);
+		return -EINVAL;
+	}
+
 	if (!sb->s_root) {
 		sb->s_flags = (flags & ~MS_RDONLY);
-		if (!proc_parse_options(options, ns)) {
-			deactivate_locked_super(sb);
-			return -EINVAL;
-		}
+
 		err = proc_fill_super(sb);
 		if (err) {
 			deactivate_locked_super(sb);
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/proc/task_mmu.c linux-2.6.32/fs/proc/task_mmu.c
--- linux-2.6.32-ovz/linux-2.6.32/fs/proc/task_mmu.c	2012-10-18 14:08:51.544774816 +0400
+++ linux-2.6.32/fs/proc/task_mmu.c	2012-10-18 14:09:35.888776006 +0400
@@ -218,6 +218,9 @@ static void show_map_vma(struct seq_file
 	dev_t dev = 0;
 	int len;
 
+	if (current->exec_id != m->exec_id)
+		return;
+
 	if (file) {
 		struct inode *inode = vma->vm_file->f_path.dentry->d_inode;
 		dev = inode->i_sb->s_dev;
@@ -1021,6 +1024,9 @@ static int show_numa_map(struct seq_file
 	if (!mm)
 		return 0;
 
+	if (current->exec_id != m->exec_id)
+		return 0;
+
 	/* Ensure we start with an empty set of numa_maps statistics. */
 	memset(md, 0, sizeof(*md));
 
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/seq_file.c linux-2.6.32/fs/seq_file.c
--- linux-2.6.32-ovz/linux-2.6.32/fs/seq_file.c	2012-10-18 14:08:51.560774817 +0400
+++ linux-2.6.32/fs/seq_file.c	2012-10-18 14:09:35.892776006 +0400
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/seq_file.h>
 #include <linux/slab.h>
+#include <linux/sched.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -40,6 +41,7 @@ int seq_open(struct file *file, const st
 	memset(p, 0, sizeof(*p));
 	mutex_init(&p->lock);
 	p->op = op;
+	p->exec_id = current->exec_id;
 
 	/*
 	 * Wrappers around seq_open(e.g. swaps_open) need to be
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/sysfs/dir.c linux-2.6.32/fs/sysfs/dir.c
--- linux-2.6.32-ovz/linux-2.6.32/fs/sysfs/dir.c	2012-10-18 14:08:51.560774817 +0400
+++ linux-2.6.32/fs/sysfs/dir.c	2012-10-18 14:09:35.892776006 +0400
@@ -367,7 +367,8 @@ struct sysfs_dirent *sysfs_new_dirent(co
 	atomic_set(&sd->s_active, 0);
 
 	sd->s_name = name;
-	sd->s_mode = mode;
+	sd->s_mode = mode & ~get_exec_env()->sysfs_umask;
+	sd->s_gid = get_exec_env()->sysfs_gid;
 	sd->s_flags = type;
 
 	return sd;
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/sysfs/inode.c linux-2.6.32/fs/sysfs/inode.c
--- linux-2.6.32-ovz/linux-2.6.32/fs/sysfs/inode.c	2012-10-18 14:08:51.564774817 +0400
+++ linux-2.6.32/fs/sysfs/inode.c	2012-10-18 14:09:35.892776006 +0400
@@ -55,9 +55,9 @@ struct sysfs_inode_attrs *sysfs_init_ino
 	iattrs = &attrs->ia_iattr;
 
 	/* assign default attributes */
-	iattrs->ia_mode = sd->s_mode;
+	iattrs->ia_mode = sd->s_mode & ~get_exec_env()->sysfs_umask;
 	iattrs->ia_uid = 0;
-	iattrs->ia_gid = 0;
+	iattrs->ia_gid = sd->s_gid;
 	iattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;
 
 	return attrs;
@@ -159,9 +159,10 @@ out:
 	return error;
 }
 
-static inline void set_default_inode_attr(struct inode * inode, mode_t mode)
+static inline void set_default_inode_attr(struct inode * inode, struct sysfs_dirent *sd)
 {
-	inode->i_mode = mode;
+	inode->i_mode = sd->s_mode;
+	inode->i_gid = sd->s_gid;
 	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 }
 
@@ -210,7 +211,7 @@ static void sysfs_init_inode(struct sysf
 						iattrs->ia_secdata,
 						iattrs->ia_secdata_len);
 	} else
-		set_default_inode_attr(inode, sd->s_mode);
+		set_default_inode_attr(inode, sd);
 
 	/* initialize inode according to type */
 	switch (sysfs_type(sd)) {
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/sysfs/Kconfig linux-2.6.32/fs/sysfs/Kconfig
--- linux-2.6.32-ovz/linux-2.6.32/fs/sysfs/Kconfig	2009-12-03 06:51:21.000000000 +0300
+++ linux-2.6.32/fs/sysfs/Kconfig	2012-10-18 14:09:35.892776006 +0400
@@ -21,3 +21,36 @@ config SYSFS
 	example, "root=03:01" for /dev/hda1.
 
 	Designers of embedded systems may wish to say N here to conserve space.
+
+config SYSFS_GID
+	int "Default group id of SYSFS files"
+	depends on SYSFS
+	default 0
+	help
+        Choose gid value for new SYSFS files for CT0.
+
+choice
+	prompt "Default SYSFS umask"
+	default SYSFS_PERMISSION_ROOT_ONLY
+	help
+	Choose umask value for new SYSFS files.
+
+	sysfs (the pseudo-filesystem mounted at /sys) and any filesystem
+	normally mounted under it (e.g. debugfs) generally provide access to hardware
+	and debug information that isn't appropriate for unprivileged users of
+	the system.  Sysfs and debugfs have also become a large source of new
+	vulnerabilities, ranging from infoleaks to local compromise.  There
+	has been very little oversight with an eye toward security involved in
+	adding new exporters of information to these filesystems, so their use
+	is discouraged.
+
+config SYSFS_PERMISSION_ROOT_ONLY
+	bool "077 umask"
+
+config SYSFS_PERMISSION_GROUP_READ
+	bool "027 umask"
+
+config SYSFS_PERMISSION_WORLD_READ
+	bool "022 umask"
+
+endchoice
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/fs/sysfs/mount.c linux-2.6.32/fs/sysfs/mount.c
--- linux-2.6.32-ovz/linux-2.6.32/fs/sysfs/mount.c	2012-10-18 14:08:51.564774817 +0400
+++ linux-2.6.32/fs/sysfs/mount.c	2012-10-18 14:09:35.896776005 +0400
@@ -51,7 +51,9 @@ struct sysfs_dirent sysfs_root = {
 	.s_name		= "",
 	.s_count	= ATOMIC_INIT(1),
 	.s_flags	= SYSFS_DIR,
-	.s_mode		= S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO,
+	.s_mode		= (S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO)
+				& ~VE0_SYSFS_UMASK,
+	.s_gid		= CONFIG_SYSFS_GID,
 	.s_ino		= 1,
 };
 
@@ -72,6 +74,7 @@ static int sysfs_fill_super(struct super
 	sb->s_magic = SYSFS_MAGIC;
 	sb->s_op = &sysfs_ops;
 	sb->s_time_gran = 1;
+	sb->s_fs_info = get_exec_env();
 	sysfs_sb = sb;
 
 	/* get root inode, initialize and unlock it */
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/include/linux/binfmts.h linux-2.6.32/include/linux/binfmts.h
--- linux-2.6.32-ovz/linux-2.6.32/include/linux/binfmts.h	2012-10-18 14:08:51.680774821 +0400
+++ linux-2.6.32/include/linux/binfmts.h	2012-10-18 14:09:35.896776005 +0400
@@ -12,7 +12,8 @@ struct pt_regs;
  * MAX_ARG_STRINGS is chosen to fit in a signed 32-bit integer.
  */
 #define MAX_ARG_STRLEN (PAGE_SIZE * 32)
-#define MAX_ARG_STRINGS 0x7FFFFFFF
+#define MAX_ARG_STACK (0xC0000000UL / 4)
+#define MAX_ARG_STRINGS (MAX_ARG_STACK / 5)
 
 /* sizeof(linux_binprm->buf) */
 #define BINPRM_BUF_SIZE 128
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/include/linux/mm_types.h linux-2.6.32/include/linux/mm_types.h
--- linux-2.6.32-ovz/linux-2.6.32/include/linux/mm_types.h	2012-10-18 14:08:51.728774821 +0400
+++ linux-2.6.32/include/linux/mm_types.h	2012-10-18 14:09:35.896776005 +0400
@@ -224,6 +224,7 @@ struct mm_struct {
 				unsigned long pgoff, unsigned long flags);
 	void (*unmap_area) (struct mm_struct *mm, unsigned long addr);
 	unsigned long mmap_base;		/* base of mmap area */
+	unsigned long lib_mmap_base;		/* base of mmap libraries area (for get_unmapped_exec_area()) */
 	unsigned long task_size;		/* size of task vm space */
 	unsigned long cached_hole_size; 	/* if non-zero, the largest hole below free_area_cache */
 	unsigned long free_area_cache;		/* first hole of size cached_hole_size or larger */
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/include/linux/nmi.h linux-2.6.32/include/linux/nmi.h
--- linux-2.6.32-ovz/linux-2.6.32/include/linux/nmi.h	2012-10-18 14:08:51.744774823 +0400
+++ linux-2.6.32/include/linux/nmi.h	2012-10-18 14:09:35.896776005 +0400
@@ -14,7 +14,7 @@
  * may be used to reset the timeout - for code which intentionally
  * disables interrupts for a long time. This call is stateless.
  */
-#if defined(ARCH_HAS_NMI_WATCHDOG) || defined(CONFIG_HARDLOCKUP_DETECTOR)
+#if defined(ARCH_HAS_NMI_WATCHDOG) || defined(CONFIG_HARDLOCKUP_DETECTOR) || 1
 #include <asm/nmi.h>
 extern void touch_nmi_watchdog(void);
 extern void acpi_nmi_disable(void);
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/include/linux/pid_namespace.h linux-2.6.32/include/linux/pid_namespace.h
--- linux-2.6.32-ovz/linux-2.6.32/include/linux/pid_namespace.h	2012-10-18 14:08:51.752774822 +0400
+++ linux-2.6.32/include/linux/pid_namespace.h	2012-10-18 14:09:35.896776005 +0400
@@ -24,6 +24,14 @@ struct bsd_acct_struct;
 /* if set newly created processes invisible from parent ns*/
 #define PID_NS_HIDDEN		0x00000002
 
+enum execstack_mode {
+	GNU_STACK_X_FORCE_NX 	= (1 << 0),
+	GNU_STACK_X_EMULTRAMP 	= (1 << 1),
+	NO_GNU_STACK_FORCE_NX 	= (1 << 2),
+	NO_GNU_STACK_EMULTRAMP 	= (1 << 3),
+	GNU_STACK_NX_EMULTRAMP 	= (1 << 4),
+};
+
 struct pid_namespace {
 	struct kref kref;
 	struct pidmap pidmap[PIDMAP_ENTRIES];
@@ -44,6 +52,10 @@ struct pid_namespace {
 	gid_t pid_gid;
 	int hide_pid;
 #endif
+#ifdef CONFIG_VM86
+	int vm86_permission;
+#endif
+	enum execstack_mode execstack_mode;
 };
 
 extern struct pid_namespace init_pid_ns;
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/include/linux/prctl.h linux-2.6.32/include/linux/prctl.h
--- linux-2.6.32-ovz/linux-2.6.32/include/linux/prctl.h	2012-10-18 14:08:51.756774823 +0400
+++ linux-2.6.32/include/linux/prctl.h	2012-10-18 14:09:35.896776005 +0400
@@ -102,6 +102,8 @@
 
 #define PR_MCE_KILL_GET 34
 
+#define PR_BITNESS_LOCK_ON_EXEC	35
+
 #define PR_SET_DATA_CSUM	100500
 # define PR_DATA_CSUM_OFF	0
 # define PR_DATA_CSUM_ON	1
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/include/linux/sched.h linux-2.6.32/include/linux/sched.h
--- linux-2.6.32-ovz/linux-2.6.32/include/linux/sched.h	2012-10-18 14:08:51.760774823 +0400
+++ linux-2.6.32/include/linux/sched.h	2012-10-18 14:09:35.896776005 +0400
@@ -1096,7 +1096,6 @@ partition_sched_domains(int ndoms_new, s
 }
 #endif	/* !CONFIG_SMP */
 
-
 struct io_context;			/* See blkdev.h */
 
 
@@ -1489,6 +1488,7 @@ struct task_struct {
 	unsigned int sessionid;
 #endif
 	seccomp_t seccomp;
+	struct bitness_lock_on_exec bitness_lock_on_exec;
 
 #ifdef CONFIG_UTRACE
 	struct utrace *utrace;
@@ -1684,6 +1684,8 @@ struct task_struct {
 	} memcg_batch;
 #endif
 #endif
+
+	u64 exec_id;
 };
 
 /* Future-safe accessor for struct task_struct's cpus_allowed. */
@@ -1918,6 +1920,7 @@ static inline void clear_stop_state(stru
 #define PF_FROZEN	0x00010000	/* frozen for system suspend */
 #define PF_FSTRANS	0x00020000	/* inside a filesystem transaction */
 #define PF_KSWAPD	0x00040000	/* I am kswapd */
+#define PF_EMULTRAMP	0x00080000	/* gcc tramplolines must be emulated */
 #define PF_LESS_THROTTLE 0x00100000	/* Throttle me less: I clean memory */
 #define PF_KTHREAD	0x00200000	/* I am a kernel thread */
 #define PF_RANDOMIZE	0x00400000	/* randomize virtual address space */
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/include/linux/security.h linux-2.6.32/include/linux/security.h
--- linux-2.6.32-ovz/linux-2.6.32/include/linux/security.h	2012-10-18 14:08:51.764774822 +0400
+++ linux-2.6.32/include/linux/security.h	2012-10-20 13:38:28.838227400 +0400
@@ -76,7 +76,7 @@ extern int cap_task_prctl(int option, un
 extern int cap_task_setscheduler(struct task_struct *p, int policy, struct sched_param *lp);
 extern int cap_task_setioprio(struct task_struct *p, int ioprio);
 extern int cap_task_setnice(struct task_struct *p, int nice);
-extern int cap_syslog(int type);
+extern int cap_syslog(int type, bool from_file);
 extern int cap_vm_enough_memory(struct mm_struct *mm, long pages);
 
 struct msghdr;
@@ -1338,6 +1338,7 @@ static inline void security_free_mnt_opt
  *	logging to the console.
  *	See the syslog(2) manual page for an explanation of the @type values.
  *	@type contains the type of action.
+ *	@from_file indicates the context of action (if it came from /proc).
  *	Return 0 if permission is granted.
  * @settime:
  *	Check permission to change the system time.
@@ -1452,7 +1453,7 @@ struct security_operations {
 	int (*sysctl) (struct ctl_table *table, int op);
 	int (*quotactl) (int cmds, int type, int id, struct super_block *sb);
 	int (*quota_on) (struct dentry *dentry);
-	int (*syslog) (int type);
+	int (*syslog) (int type, bool from_file);
 	int (*settime) (struct timespec *ts, struct timezone *tz);
 	int (*vm_enough_memory) (struct mm_struct *mm, long pages);
 
@@ -1750,7 +1751,7 @@ int security_acct(struct file *file);
 int security_sysctl(struct ctl_table *table, int op);
 int security_quotactl(int cmds, int type, int id, struct super_block *sb);
 int security_quota_on(struct dentry *dentry);
-int security_syslog(int type);
+int security_syslog(int type, bool from_file);
 int security_settime(struct timespec *ts, struct timezone *tz);
 int security_vm_enough_memory(long pages);
 int security_vm_enough_memory_mm(struct mm_struct *mm, long pages);
@@ -2001,9 +2002,9 @@ static inline int security_quota_on(stru
 	return 0;
 }
 
-static inline int security_syslog(int type)
+static inline int security_syslog(int type, bool from_file)
 {
-	return cap_syslog(type);
+	return cap_syslog(type, from_file);
 }
 
 static inline int security_settime(struct timespec *ts, struct timezone *tz)
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/include/linux/seq_file.h linux-2.6.32/include/linux/seq_file.h
--- linux-2.6.32-ovz/linux-2.6.32/include/linux/seq_file.h	2009-12-03 06:51:21.000000000 +0300
+++ linux-2.6.32/include/linux/seq_file.h	2012-10-18 14:09:35.896776005 +0400
@@ -24,6 +24,7 @@ struct seq_file {
 	struct mutex lock;
 	const struct seq_operations *op;
 	void *private;
+	u64 exec_id;
 };
 
 struct seq_operations {
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/include/linux/sysfs.h linux-2.6.32/include/linux/sysfs.h
--- linux-2.6.32-ovz/linux-2.6.32/include/linux/sysfs.h	2012-10-18 14:08:51.772774823 +0400
+++ linux-2.6.32/include/linux/sysfs.h	2012-10-18 14:09:35.896776005 +0400
@@ -197,6 +197,7 @@ struct sysfs_dirent {
 
 	unsigned int		s_flags;
 	ino_t			s_ino;
+	gid_t			s_gid;
 	umode_t			s_mode;
 	struct sysfs_inode_attrs *s_iattr;
 };
@@ -269,6 +270,16 @@ extern int init_ve_sysfs_root(struct ve_
 
 extern struct file_system_type sysfs_fs_type;
 
+#if defined(CONFIG_SYSFS_PERMISSION_ROOT_ONLY)
+#define VE0_SYSFS_UMASK		0077
+#elif defined(CONFIG_SYSFS_PERMISSION_GROUP_READ)
+#define VE0_SYSFS_UMASK		0027
+#elif defined(CONFIG_SYSFS_PERMISSION_WORLD_READ)
+#define VE0_SYSFS_UMASK		0022
+#else
+#error Wrong SYSFS_PERMISSION value!
+#endif
+
 #else /* CONFIG_SYSFS */
 
 static inline int sysfs_schedule_callback(struct kobject *kobj,
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/include/linux/syslog.h linux-2.6.32/include/linux/syslog.h
--- linux-2.6.32-ovz/linux-2.6.32/include/linux/syslog.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6.32/include/linux/syslog.h	2012-10-20 13:38:28.842227401 +0400
@@ -0,0 +1,29 @@
+/*  Syslog internals
+ *
+ *  Copyright 2010 Canonical, Ltd.
+ *  Author: Kees Cook <kees.cook@canonical.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _LINUX_SYSLOG_H
+#define _LINUX_SYSLOG_H
+
+#define SYSLOG_FROM_CALL 0
+#define SYSLOG_FROM_FILE 1
+
+int do_syslog(int type, char __user *buf, int count, bool from_file);
+
+#endif /* _LINUX_SYSLOG_H */
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/include/linux/ve.h linux-2.6.32/include/linux/ve.h
--- linux-2.6.32-ovz/linux-2.6.32/include/linux/ve.h	2012-10-18 14:08:51.780774824 +0400
+++ linux-2.6.32/include/linux/ve.h	2012-10-18 14:09:35.896776005 +0400
@@ -183,6 +183,8 @@ struct ve_struct {
 	struct vfsmount		*sysfs_mnt;
 	struct super_block	*sysfs_sb;
 	struct sysfs_dirent	*_sysfs_root;
+	umode_t			sysfs_umask;
+	gid_t			sysfs_gid;
 	struct kobject		*fs_kobj;
 	struct kobject		*cgroup_kobj;
 #if defined(CONFIG_HOTPLUG)
@@ -205,6 +207,7 @@ struct ve_struct {
 	struct class		*net_class;
 #ifdef CONFIG_INET
  	unsigned long		rt_flush_required;
+	unsigned int            ping_group_range[2];
 #endif
 #endif
 #if defined(CONFIG_VE_NETDEV) || defined (CONFIG_VE_NETDEV_MODULE)
@@ -275,6 +278,10 @@ struct ve_struct {
 	struct list_head	bm_entries;
 #endif
 
+	int 			protected_symlinks,
+				protected_hardlinks,
+				protected_fifos;
+        int                     ascii_armor;
 	struct nsproxy		*ve_ns;
 	struct user_namespace	*user_ns;
 	struct cred		*init_cred;
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/include/linux/vzcalluser.h linux-2.6.32/include/linux/vzcalluser.h
--- linux-2.6.32-ovz/linux-2.6.32/include/linux/vzcalluser.h	2012-10-18 14:08:51.784774823 +0400
+++ linux-2.6.32/include/linux/vzcalluser.h	2012-10-18 14:09:35.896776005 +0400
@@ -106,7 +106,7 @@ struct env_create_param3 {
 	__u64 iptables_mask;
 	__u64 feature_mask;
 	__u32 total_vcpus;
-	__u32 pad;
+	__u32 pad_gid;
 	__u64 known_features;
 };
 
@@ -120,6 +120,10 @@ struct env_create_param3 {
 #define VE_FEATURE_BRIDGE	(1ULL << 7)
 #define VE_FEATURE_NFSD		(1ULL << 8)
 
+#define VE_FEATURE_SYSFS_PERM_GROUP		(1ULL << 13)
+#define VE_FEATURE_SYSFS_PERM_ROOT		(1ULL << 14)
+#define VE_FEATURE_SYSFS_GID_IS_VALID		(1ULL << 15)
+
 #define VE_FEATURES_OLD		(VE_FEATURE_SYSFS)
 #define VE_FEATURES_DEF		(VE_FEATURE_SYSFS | \
 				 VE_FEATURE_DEF_PERMS)
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/include/net/netns/ipv4.h linux-2.6.32/include/net/netns/ipv4.h
--- linux-2.6.32-ovz/linux-2.6.32/include/net/netns/ipv4.h	2012-10-18 14:08:51.808774824 +0400
+++ linux-2.6.32/include/net/netns/ipv4.h	2012-10-18 14:09:35.896776005 +0400
@@ -53,6 +53,7 @@ struct netns_ipv4 {
 	int sysctl_rt_cache_rebuild_count;
 	int current_rt_cache_rebuild_count;
 
+	unsigned int sysctl_ping_group_range[2];
 	struct timer_list rt_secret_timer;
 	atomic_t rt_genid;
 
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/include/net/ping.h linux-2.6.32/include/net/ping.h
--- linux-2.6.32-ovz/linux-2.6.32/include/net/ping.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6.32/include/net/ping.h	2012-10-18 14:09:35.896776005 +0400
@@ -0,0 +1,60 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the "ping" module.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _PING_H
+#define _PING_H
+
+#include <net/netns/hash.h>
+
+/* PING_HTABLE_SIZE must be power of 2 */
+#define PING_HTABLE_SIZE 	64
+#define PING_HTABLE_MASK 	(PING_HTABLE_SIZE-1)
+
+#define ping_portaddr_for_each_entry(__sk, node, list) \
+	hlist_nulls_for_each_entry(__sk, node, list, sk_nulls_node)
+
+/*
+ * gid_t is either uint or ushort.  We want to pass it to
+ * proc_dointvec_minmax(), so it must not be larger than MAX_INT
+ */
+#define GID_T_MAX (((gid_t)~0U) >> 1)
+
+struct ping_table {
+	struct hlist_nulls_head	hash[PING_HTABLE_SIZE];
+	rwlock_t		lock;
+};
+
+struct ping_iter_state {
+	struct seq_net_private  p;
+	int			bucket;
+};
+
+extern struct proto ping_prot;
+
+#ifdef CONFIG_IP_PING
+#define icmp_echoreply ping_rcv
+#else
+#define icmp_echoreply icmp_discard
+#endif
+
+extern void ping_rcv(struct sk_buff *);
+extern void ping_err(struct sk_buff *, u32 info);
+
+#ifdef CONFIG_PROC_FS
+extern int __init ping_proc_init(void);
+extern void ping_proc_exit(void);
+#endif
+
+void __init ping_init(void);
+
+
+#endif /* _PING_H */
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/init/do_mounts.c linux-2.6.32/init/do_mounts.c
--- linux-2.6.32-ovz/linux-2.6.32/init/do_mounts.c	2012-10-18 14:08:51.848774825 +0400
+++ linux-2.6.32/init/do_mounts.c	2012-10-18 14:09:35.900776004 +0400
@@ -20,6 +20,10 @@
 #include <linux/nfs_fs_sb.h>
 #include <linux/nfs_mount.h>
 
+#ifdef CONFIG_BLK_DEV_IDECD
+#include <linux/ide.h>
+#endif
+
 #include "do_mounts.h"
 
 int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
@@ -214,12 +218,87 @@ static void __init get_fs_names(char *pa
 	*s = '\0';
 }
 
+struct root_data {
+	char *name;
+	char *fs;
+	int flags;
+	void *data;
+};
+
+int try_mount_ide_root(struct device *ide_device, void *data)
+{
+	char realname[20];
+	int i, err;
+	ide_hwif_t *hwif;
+	ide_drive_t *drive;
+	struct root_data *root_data = data;
+
+	hwif = container_of(ide_device, ide_hwif_t, gendev);
+	if (!hwif->present)
+		return 0;
+
+	ide_port_for_each_present_dev(i, drive, hwif) {
+		if (drive->media != ide_cdrom)
+			continue;
+		snprintf(realname, 20, "/dev/%s", drive->name);
+		printk(KERN_INFO "Trying to mount %s...\n", realname);
+		create_dev(root_data->name, MKDEV(hwif->major, i << PARTN_BITS));
+		err = sys_mount(root_data->name, "/root", root_data->fs, root_data->flags, root_data->data);
+		if (!err)
+			return 1;
+	}
+
+	return 0;
+}
+
 static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 {
-	int err = sys_mount(name, "/root", fs, flags, data);
+	int err = -ENODEV;
+	int res;
+	struct root_data root_data = {
+		.name = name,
+		.fs = fs,
+		.flags = flags,
+		.data = data,
+	};
+
+	if (!strcmp(saved_root_name, "/dev/cdrom")) {
+#ifdef CONFIG_BLK_DEV_IDECD
+		res = bus_for_each_dev(&ide_bus_type, NULL, &root_data, try_mount_ide_root);
+		if (res)
+			goto ok;
+#endif
+#ifdef CONFIG_BLK_DEV_SR
+		char realname[20];
+		strcpy(realname, "/dev/scd0");
+		while (realname[8] < '8') {
+			int retries = root_delay;
+retry:
+			printk(KERN_INFO "Trying to mount %s...\n", realname);
+			if (retries == root_delay)
+				create_dev(name,
+				    MKDEV(SCSI_CDROM_MAJOR, realname[8] - '0'));
+			err = sys_mount(name, "/root", fs, flags, data);
+			if (!err)
+				goto ok;
+			if (err == -ENXIO || err == -ENODEV) {
+				if (retries-- <= 0)
+					return err;
+				printk(KERN_INFO "Retrying in 1 sec...\n");
+				ssleep(1);
+				goto retry;
+			}
+			realname[8]++;
+		}
+#endif
+		return err;
+	}
+
+	err = sys_mount(name, "/root", fs, flags, data);
 	if (err)
 		return err;
 
+ok:
 	sys_chdir("/root");
 	ROOT_DEV = current->fs->pwd.mnt->mnt_sb->s_dev;
 	printk("VFS: Mounted root (%s filesystem)%s on device %u:%u.\n",
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/init/do_mounts_md.c linux-2.6.32/init/do_mounts_md.c
--- linux-2.6.32-ovz/linux-2.6.32/init/do_mounts_md.c	2009-12-03 06:51:21.000000000 +0300
+++ linux-2.6.32/init/do_mounts_md.c	2012-10-18 14:09:35.900776004 +0400
@@ -121,6 +121,7 @@ static void __init md_setup_drive(void)
 
 	for (ent = 0; ent < md_setup_ents ; ent++) {
 		int fd;
+		int disknum = 0;
 		int err = 0;
 		char *devname;
 		mdu_disk_info_t dinfo;
@@ -143,7 +144,7 @@ static void __init md_setup_drive(void)
 
 			p = strchr(devname, ',');
 			if (p)
-				*p++ = 0;
+				*p = 0;
 
 			dev = name_to_dev_t(devname);
 			if (strncmp(devname, "/dev/", 5) == 0)
@@ -153,17 +154,22 @@ static void __init md_setup_drive(void)
 			if (rdev)
 				dev = new_decode_dev(rdev);
 			if (!dev) {
-				printk(KERN_WARNING "md: Unknown device name: %s\n", devname);
-				break;
+				printk(KERN_WARNING "md: Skipping unknown device name: %s\n", devname);
+				if (p)
+					*p++ = ',';
+				devname = p;
+				continue;
 			}
 
-			devices[i] = dev;
+			devices[disknum++] = dev;
 
+			if (p)
+				*p++ = ',';
 			devname = p;
 		}
-		devices[i] = 0;
+		devices[disknum] = 0;
 
-		if (!i)
+		if (!disknum)
 			continue;
 
 		printk(KERN_INFO "md: Loading md%s%d: %s\n",
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/init/main.c linux-2.6.32/init/main.c
--- linux-2.6.32-ovz/linux-2.6.32/init/main.c	2012-10-18 14:08:51.848774825 +0400
+++ linux-2.6.32/init/main.c	2012-10-18 14:09:35.900776004 +0400
@@ -609,7 +609,7 @@ asmlinkage void __init start_kernel(void
 	tick_init();
 	boot_cpu_init();
 	page_address_init();
-	printk(KERN_NOTICE "%s", linux_banner);
+	printk(KERN_NOTICE "%s\n", linux_banner);
 	setup_arch(&command_line);
 	mm_init_owner(&init_mm, &init_task);
 	setup_command_line(command_line);
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/init/version.c linux-2.6.32/init/version.c
--- linux-2.6.32-ovz/linux-2.6.32/init/version.c	2012-10-18 14:08:51.848774825 +0400
+++ linux-2.6.32/init/version.c	2012-10-18 14:09:35.900776004 +0400
@@ -45,7 +45,7 @@ EXPORT_SYMBOL(virt_utsname);
 /* FIXED STRINGS! Don't touch! */
 const char linux_banner[] =
 	"Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"
-	LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION "\n";
+	LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION;
 
 const char linux_proc_banner[] =
 	"%s version %s"
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/kernel/kallsyms.c linux-2.6.32/kernel/kallsyms.c
--- linux-2.6.32-ovz/linux-2.6.32/kernel/kallsyms.c	2012-10-18 14:08:52.276774836 +0400
+++ linux-2.6.32/kernel/kallsyms.c	2012-10-18 14:09:35.900776004 +0400
@@ -521,7 +521,7 @@ static const struct file_operations kall
 
 static int __init kallsyms_init(void)
 {
-	proc_create("kallsyms", 0444, NULL, &kallsyms_operations);
+	proc_create("kallsyms", 0400, NULL, &kallsyms_operations);
 	return 0;
 }
 device_initcall(kallsyms_init);
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/kernel/panic.c linux-2.6.32/kernel/panic.c
--- linux-2.6.32-ovz/linux-2.6.32/kernel/panic.c	2012-10-18 14:08:52.304774838 +0400
+++ linux-2.6.32/kernel/panic.c	2012-10-18 14:09:35.900776004 +0400
@@ -24,7 +24,7 @@
 #include <linux/nmi.h>
 #include <linux/dmi.h>
 
-int panic_on_oops = 1;
+int panic_on_oops;
 static unsigned long tainted_mask;
 static int pause_on_oops;
 static int pause_on_oops_flag;
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/kernel/printk.c linux-2.6.32/kernel/printk.c
--- linux-2.6.32-ovz/linux-2.6.32/kernel/printk.c	2012-10-18 14:08:52.324774838 +0400
+++ linux-2.6.32/kernel/printk.c	2012-10-20 13:39:25.994228931 +0400
@@ -35,6 +35,7 @@
 #include <linux/kexec.h>
 #include <linux/kmsg_dump.h>
 #include <linux/veprintk.h>
+#include <linux/syslog.h>
 
 #include <asm/uaccess.h>
 
@@ -324,7 +325,7 @@ int dmesg_restrict;
  *	9 -- Return number of unread characters in the log buffer
  *     10 -- Return size of the log buffer
  */
-int do_syslog(int type, char __user *buf, int len)
+int do_syslog(int type, char __user *buf, int len, bool from_file)
 {
 	unsigned i, j, limit, count;
 	int do_clear = 0;
@@ -334,7 +335,7 @@ int do_syslog(int type, char __user *buf
 	if (!ve_is_super(get_exec_env()) && (type == 6 || type == 7))
 		goto out;
 
-	error = security_syslog(type);
+	error = security_syslog(type, from_file);
 	if (error)
 		return error;
 
@@ -476,7 +477,7 @@ out:
 
 SYSCALL_DEFINE3(syslog, int, type, char __user *, buf, int, len)
 {
-	return do_syslog(type, buf, len);
+	return do_syslog(type, buf, len, SYSLOG_FROM_CALL);
 }
 
 /*
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/kernel/sched.c linux-2.6.32/kernel/sched.c
--- linux-2.6.32-ovz/linux-2.6.32/kernel/sched.c	2012-10-18 14:08:52.344774839 +0400
+++ linux-2.6.32/kernel/sched.c	2012-10-18 14:09:35.900776004 +0400
@@ -11479,9 +11479,11 @@ cpu_cgroup_exit(struct cgroup_subsys *ss
 		struct taskstats *stats = get_cpu_ptr(tg->taskstats);
 		struct signal_struct *sig = task->signal;
 
+#ifdef CONFIG_TASKSTATS
 		if (sig->stats)
 			delayacct_add_stats(stats, sig->stats);
 		else
+#endif
 			delayacct_add_tsk(stats, task);
 
 		put_cpu_ptr(stats);
@@ -12142,8 +12144,10 @@ static int cpu_cgroup_delay_show(struct
 
 	cgroup_iter_start(cgrp, &it);
 	while ((p = cgroup_iter_next(cgrp, &it))) {
+#ifdef CONFIG_TASKSTATS
 		if (thread_group_leader(p) && p->signal->stats)
 			delayacct_add_stats(&stats, p->signal->stats);
+#endif
 		delayacct_add_tsk(&stats, p);
 	}
 	cgroup_iter_end(cgrp, &it);
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/kernel/sched_idletask.c linux-2.6.32/kernel/sched_idletask.c
--- linux-2.6.32-ovz/linux-2.6.32/kernel/sched_idletask.c	2012-10-18 14:08:52.352774838 +0400
+++ linux-2.6.32/kernel/sched_idletask.c	2012-10-18 14:09:35.900776004 +0400
@@ -22,7 +22,9 @@ static void check_preempt_curr_idle(stru
 
 static struct task_struct *pick_next_task_idle(struct rq *rq)
 {
+#ifdef CONFIG_SCHEDSTATS
 	schedstat_inc(rq, sched_goidle);
+#endif
 	/* adjust the active tasks as we might go into a long sleep */
 	calc_load_account_active(rq);
 	return rq->idle;
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/kernel/sys.c linux-2.6.32/kernel/sys.c
--- linux-2.6.32-ovz/linux-2.6.32/kernel/sys.c	2012-10-18 14:08:52.364774838 +0400
+++ linux-2.6.32/kernel/sys.c	2012-10-18 14:09:35.904776004 +0400
@@ -710,21 +710,18 @@ static int set_user(struct cred *new)
 	struct user_struct *new_user;
 
 	new_user = alloc_uid(current_user_ns(), new->uid);
-	if (!new_user)
+	if (!new_user) {
+		force_sig(SIGKILL, current);
 		return -EAGAIN;
+	}
+
 
 	if (!task_can_switch_user(new_user, current)) {
+		force_sig(SIGKILL, current);
 		free_uid(new_user);
 		return -EINVAL;
 	}
 
-	if (atomic_read(&new_user->processes) >=
-				current->signal->rlim[RLIMIT_NPROC].rlim_cur &&
-			new_user != INIT_USER) {
-		free_uid(new_user);
-		return -EAGAIN;
-	}
-
 	free_uid(new->user);
 	new->user = new_user;
 	return 0;
@@ -1785,7 +1782,7 @@ SYSCALL_DEFINE5(prctl, int, option, unsi
 			}
 			break;
 		default:
-			error = -EINVAL;
+			error = arch_prctl(option, arg2, arg3, arg4, arg5);
 			break;
 	}
 	return error;
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/kernel/sysctl.c linux-2.6.32/kernel/sysctl.c
--- linux-2.6.32-ovz/linux-2.6.32/kernel/sysctl.c	2012-10-18 14:08:52.368774838 +0400
+++ linux-2.6.32/kernel/sysctl.c	2012-10-18 14:09:35.904776004 +0400
@@ -148,6 +148,7 @@ static int neg_one = -1;
 #endif
 
 static int zero;
+static int thirty_one = 31;
 static int __maybe_unused one = 1;
 static int __maybe_unused two = 2;
 static unsigned long one_ul = 1;
@@ -174,6 +175,15 @@ extern int modules_disabled;
 #ifdef CONFIG_CHR_DEV_SG
 extern int sg_big_buff;
 #endif
+static int proc_execstack_mode(struct ctl_table *table, int write,
+				void __user *buffer, size_t *lenp, loff_t *ppos);
+static int three = 3;
+#ifdef CONFIG_REFCOUNT_CHECK
+extern int sysctl_kref_overflow_action;
+#endif
+#ifdef CONFIG_CHECK_UACCESS_OVERFLOW
+int sysctl_uaccess_overflow_action = 2;
+#endif
 
 #ifdef CONFIG_SPARC
 #include <asm/system.h>
@@ -1308,6 +1318,39 @@ static struct ctl_table kern_table[] = {
 		.proc_handler	= &proc_dointvec,
 	},
 #endif
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "execstack_mode",
+		.maxlen		= sizeof(int),
+		.mode		= 0644 | S_ISVTX,
+		.proc_handler	= &proc_execstack_mode,
+		.extra1		= &zero,
+		.extra2		= &thirty_one,
+	},
+#ifdef CONFIG_REFCOUNT_CHECK
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "kref_overflow_action",
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.data		= &sysctl_kref_overflow_action,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= &zero,
+		.extra2		= &three,
+	},
+#endif
+#ifdef CONFIG_CHECK_UACCESS_OVERFLOW
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "uaccess_overflow_action",
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.data		= &sysctl_uaccess_overflow_action,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= &zero,
+		.extra2		= &three,
+	},
+#endif
 /*
  * NOTE: do not add new entries to this table unless you have read
  * Documentation/sysctl/ctl_unnumbered.txt
@@ -2000,6 +2043,38 @@ static struct ctl_table fs_table[] = {
 		.mode           = 0644 | S_ISVTX,
 		.proc_handler   = proc_dointvec,
 	},
+ 	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "ascii_armor",
+		.extra1		= (void *)offsetof(struct ve_struct, ascii_armor),
+		.maxlen		= sizeof(int),
+		.mode		= 0644 | S_ISVTX,
+		.proc_handler	= proc_dointvec,
+	},
+ 	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "protected_symlinks",
+		.extra1		= (void *)offsetof(struct ve_struct, protected_symlinks),
+		.maxlen		= sizeof(int),
+		.mode		= 0600 | S_ISVTX,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "protected_hardlinks",
+		.extra1		= (void *)offsetof(struct ve_struct, protected_hardlinks),
+		.maxlen		= sizeof(int),
+		.mode		= 0600 | S_ISVTX,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "protected_fifos",
+		.extra1		= (void *)offsetof(struct ve_struct, protected_fifos),
+		.maxlen		= sizeof(int),
+		.mode		= 0600 | S_ISVTX,
+		.proc_handler	= proc_dointvec,
+	},
 /*
  * NOTE: do not add new entries to this table unless you have read
  * Documentation/sysctl/ctl_unnumbered.txt
@@ -3112,6 +3187,15 @@ static int proc_dmesg_restrict(struct ct
 }
 #endif
 
+static int proc_execstack_mode(struct ctl_table *table, int write,
+				void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	struct ctl_table tmp = *table;
+	tmp.data = &current->nsproxy->pid_ns->execstack_mode;
+
+	return proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);
+}
+
 struct do_proc_dointvec_minmax_conv_param {
 	int *min;
 	int *max;
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/kernel/ve/ve.c linux-2.6.32/kernel/ve/ve.c
--- linux-2.6.32-ovz/linux-2.6.32/kernel/ve/ve.c	2012-10-18 14:08:52.480774842 +0400
+++ linux-2.6.32/kernel/ve/ve.c	2012-10-18 14:09:35.904776004 +0400
@@ -38,6 +38,7 @@
 #include <linux/user_namespace.h>
 #include <linux/init_task.h>
 #include <linux/mutex.h>
+#include <linux/sysfs.h>
 
 #include <linux/vzcalluser.h>
 
@@ -85,6 +86,7 @@ struct ve_struct ve0 = {
 	._iptables_modules	= VE_IP_NONE,	/* but nothing yet loaded */
 #endif
 	.features		= -1,
+	.ping_group_range       = { 1, 0 },
 	.meminfo_val		= VE_MEMINFO_SYSTEM,
 	._randomize_va_space	=
 #ifdef CONFIG_COMPAT_BRK
@@ -96,6 +98,13 @@ struct ve_struct ve0 = {
 	.init_cred		= &init_cred,
 	.fsync_enable		= FSYNC_FILTERED,
 	.sync_mutex		= __MUTEX_INITIALIZER(ve0.sync_mutex),
+
+	.sysfs_umask		= VE0_SYSFS_UMASK,
+	.sysfs_gid		= CONFIG_SYSFS_GID,
+	.protected_hardlinks	= 1,
+	.protected_symlinks	= 1,
+	.protected_fifos	= 1,
+        .ascii_armor            = 1,
 };
 
 EXPORT_SYMBOL(ve0);
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/kernel/ve/vecalls.c linux-2.6.32/kernel/ve/vecalls.c
--- linux-2.6.32-ovz/linux-2.6.32/kernel/ve/vecalls.c	2012-10-18 14:08:52.484774842 +0400
+++ linux-2.6.32/kernel/ve/vecalls.c	2012-10-18 14:09:35.904776004 +0400
@@ -899,6 +899,26 @@ static int init_ve_struct(struct ve_stru
  
 	ve->odirect_enable = 2;
 	ve->fsync_enable = 2;
+	ve->ping_group_range[0] = 1;
+	ve->ping_group_range[1] = 0;
+
+	ve->protected_symlinks = 1;
+	ve->protected_hardlinks = 1;
+	ve->protected_fifos = 1;
+        ve->ascii_armor = 1;
+
+#ifdef CONFIG_SYSFS
+	if (ve->features & VE_FEATURE_SYSFS_GID_IS_VALID)
+		ve->sysfs_gid = data->pad_gid;
+	else
+		ve->sysfs_gid = 0;
+	if (ve->features & VE_FEATURE_SYSFS_PERM_ROOT)
+		ve->sysfs_umask = 0077;
+	else if (ve->features & VE_FEATURE_SYSFS_PERM_GROUP)
+		ve->sysfs_umask = 0027;
+	else
+		ve->sysfs_umask = 0022;
+#endif
 
 	INIT_LIST_HEAD(&ve->ve_list);
 	init_waitqueue_head(&ve->ve_list_wait);
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/lib/Kconfig linux-2.6.32/lib/Kconfig
--- linux-2.6.32-ovz/linux-2.6.32/lib/Kconfig	2012-10-18 14:08:52.536774843 +0400
+++ linux-2.6.32/lib/Kconfig	2012-10-18 14:09:35.904776004 +0400
@@ -210,3 +210,48 @@ config AVERAGE
 	bool
 
 endmenu
+
+config REFCOUNT_CHECK
+	bool "Check for kernel refcounters overflows"
+	default y
+	help
+	  By saying Y here the kernel will detect and prevent overflowing
+	  various (but not all) kinds of object reference counters.  Such
+	  overflows can normally occur due to bugs only and are often, if
+	  not always, exploitable.
+
+	  The tradeoff is that data structures protected by an overflowed
+	  refcount will never be freed and therefore will leak memory.  Note
+	  that this leak also happens even without this protection but in
+	  that case the overflow can eventually trigger the freeing of the
+	  data structure while it is still being used elsewhere, resulting
+	  in the exploitable situation that this feature prevents.
+
+	  The behaviour is configurable via kernel.kref_overflow_action
+	  sysctl.  2 makes kernel panic on kref overflow, 1 makes kernel
+	  write down kernel stack trace, kills current task, and pins the
+	  kref in memory (default), 0 fully disables the check (disabling
+	  the check via sysctl is still slower than disabling it via config
+	  option).
+
+	  This feature is a light version of PAX_REFCOUNT from PaX kernel.
+	  PaX watches all atomic_t, atomic64_t counters, not only kref.
+
+config CHECK_UACCESS_OVERFLOW
+	bool "check uaccess overflow"
+	default y
+	help
+      By saying Y here the kernel will enforce the size of heap and stack
+      objects when they are copied in either direction between the kernel
+      and userland, even if only a part of the object is copied.
+
+      Specifically, this checking prevents information leaking from the
+      kernel heap during kernel to userland copies (if the kernel heap
+      object is otherwise fully initialized) and prevents kernel heap
+      overflows during userland to kernel copies.
+
+      Note that the current implementation provides the strictest bounds
+      checks for the SLUB allocator.
+
+      Since this has a negligible performance impact, you should enable
+      this feature.
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/lib/kref.c linux-2.6.32/lib/kref.c
--- linux-2.6.32-ovz/linux-2.6.32/lib/kref.c	2012-10-18 14:08:52.548774843 +0400
+++ linux-2.6.32/lib/kref.c	2012-10-18 14:09:35.904776004 +0400
@@ -12,6 +12,7 @@
  */
 
 #include <linux/kref.h>
+#include <linux/kernel.h>
 #include <linux/module.h>
 
 /**
@@ -34,6 +35,10 @@ void kref_init(struct kref *kref)
 	kref_set(kref, 1);
 }
 
+#ifdef CONFIG_REFCOUNT_CHECK
+int sysctl_kref_overflow_action = 2;
+#endif
+
 /**
  * kref_get - increment refcount for object.
  * @kref: object.
@@ -41,7 +46,39 @@ void kref_init(struct kref *kref)
 void kref_get(struct kref *kref)
 {
 	WARN_ON(!atomic_read(&kref->refcount));
+#ifndef CONFIG_REFCOUNT_CHECK
 	atomic_inc(&kref->refcount);
+#else
+
+	if (unlikely((unsigned int)atomic_inc_return(&kref->refcount) >
+		     (unsigned int)INT_MAX)) {
+
+		/* TODO: add_taint() */
+
+		if (unlikely(sysctl_kref_overflow_action)) {
+			pr_err("Kernel refcount overflow spotted! " 
+			       "It might be an attempt to exploit the kernel. "
+			       "VEID: %u, Pid: %u, Comm: %s, Uid/Euid: %u/%u.\n",
+				(int)get_exec_env()->veid, (int)task_pid_nr(current),
+				current->comm, current_uid(), current_euid());
+			dump_stack();
+
+			if (sysctl_kref_overflow_action == 3)
+				panic("kref refcount overflow spotted.\n");
+
+			/* 
+			 * Pin this object in memory, choose memory leak
+			 * instead of refcounter overflow and the following
+			 * use-after-free.
+			 */
+			atomic_dec(&kref->refcount);
+
+			if ((sysctl_kref_overflow_action == 2) &&
+			    !(current->flags & PF_KTHREAD))
+				force_sig_specific(SIGKILL, current);
+		}
+	}
+#endif
 	smp_mb__after_atomic_inc();
 }
 
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/lib/vsprintf.c linux-2.6.32/lib/vsprintf.c
--- linux-2.6.32-ovz/linux-2.6.32/lib/vsprintf.c	2012-10-18 14:08:52.612774845 +0400
+++ linux-2.6.32/lib/vsprintf.c	2012-10-18 14:24:20.900799704 +0400
@@ -546,25 +546,49 @@ static char *number(char *buf, char *end
 	return buf;
 }
 
+static bool is_printable(char c)
+{
+	return (((c >= ' ') && (c < 127)) ||
+		(c == '\t'));
+}
+
 static char *string(char *buf, char *end, const char *s, struct printf_spec spec)
 {
-	int len, i;
+	int len, i, non_printable_num;
+	static const char digits[16] = "0123456789ABCDEF";
 
 	if ((unsigned long)s < PAGE_SIZE)
 		s = "(null)";
 
 	len = strnlen(s, spec.precision);
 
+	non_printable_num = 0;
+	for (i = 0; i < len; ++i)
+		if (!is_printable(s[i]))
+			non_printable_num++;
+
 	if (!(spec.flags & LEFT)) {
-		while (len < spec.field_width--) {
+		while (len + non_printable_num*4 < spec.field_width--) {
 			if (buf < end)
 				*buf = ' ';
 			++buf;
 		}
 	}
 	for (i = 0; i < len; ++i) {
-		if (buf < end)
-			*buf = *s;
+		if (buf < end) {
+			if (is_printable(*s))
+				*buf = *s;
+			else if (buf + 4 < end) {
+				*buf++ = '#';
+				*buf++ = '%';
+				*buf++ = digits[((unsigned char)(*s)) / 16];
+				*buf++ = digits[((unsigned char)(*s)) % 16];
+				*buf = 'x';
+			} else
+				/* Probably we have some place in buf,
+				 * but still not enough for #%CCx... */
+				break;
+		}
 		++buf; ++s;
 	}
 	while (len < spec.field_width--) {
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/Makefile linux-2.6.32/Makefile
--- linux-2.6.32-ovz/linux-2.6.32/Makefile	2012-10-18 14:08:52.616774846 +0400
+++ linux-2.6.32/Makefile	2012-10-18 14:10:12.280776979 +0400
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 32
-EXTRAVERSION =
+EXTRAVERSION = -042stab062.2.owl1
 VZVERSION = 042stab062_2
 NAME = Man-Eating Seals of Antiquity
 RHEL_MAJOR = 6
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/mm/maccess.c linux-2.6.32/mm/maccess.c
--- linux-2.6.32-ovz/linux-2.6.32/mm/maccess.c	2009-12-03 06:51:21.000000000 +0300
+++ linux-2.6.32/mm/maccess.c	2012-10-18 14:55:13.736849323 +0400
@@ -53,3 +53,110 @@ long notrace __weak probe_kernel_write(v
 	return ret ? -EFAULT : 0;
 }
 EXPORT_SYMBOL_GPL(probe_kernel_write);
+
+/*
+ * low ----------------------------------------------> high
+ * [saved bp][saved ip][args][local vars][saved bp][saved ip]
+ *		       ^----------------^
+ *		  allow copies only within here
+*/
+inline bool __is_stack_access_violated(const void *obj, size_t len)
+{
+	const void * const stack = task_stack_page(current);
+	const void * const stackend = stack + THREAD_SIZE;
+	const void *frame = NULL;
+	const void *oldframe;
+
+	/* Does obj+len overflow vm space? */
+	if (unlikely(obj + len < obj))
+		return true;
+
+	/* Does [obj; obj+len) at least touch our stack? */
+	if (unlikely(obj + len <= stack || stackend <= obj))
+		return false;
+
+	/* Does [obj; obj+len) overflow/underflow the stack? */
+	if (unlikely(obj < stack || stackend < obj + len))
+		return true;
+
+	pr_debug("our stack (%p:%d)\n", obj, (int)len);
+
+	/*
+	 * OK, the object is somewhere at our stack.
+	 */
+
+	/* Get the stack_access_ok() caller frame. */
+	oldframe = __builtin_frame_address(0);
+	if (oldframe)
+		frame = __builtin_frame_address(1);
+
+	while (stack <= frame && frame < stackend) {
+        pr_debug("frame %p-%p\n", oldframe, frame);
+		/*
+		 * If obj + len extends past the last frame, this
+		 * check won't pass and the next frame will be 0,
+		 * causing us to bail out and correctly report
+		 * the copy as invalid.
+		 */
+		if (obj + len <= frame) {
+			/* EBP + EIP */
+			int protected_regs_size = 2*sizeof(void *);
+
+			pr_debug("got it\n");
+
+			if (obj >= oldframe + protected_regs_size)
+				return false;
+			return true;
+		}
+		oldframe = frame;
+		frame = *(const void * const *)frame;
+	}
+
+	pr_debug("overflow!\n");
+	return true;
+}
+
+bool is_stack_access_violated(const void *obj, size_t len)
+{
+	if (__is_stack_access_violated(obj, len)) {
+		pr_debug("pid=%d stack_access_violated\n", task_pid_nr(current));
+		return true;
+	}
+	return false;
+}
+EXPORT_SYMBOL(is_stack_access_violated);
+
+extern bool __is_slab_access_violated(const void *ptr, size_t len);
+
+bool is_slab_access_violated(const void *ptr, size_t len)
+{
+	if (virt_addr_valid(ptr) && __is_slab_access_violated(ptr, len)) {
+		pr_debug("pid=%d slab_access_violated\n", task_pid_nr(current));
+		return true;
+	}
+	return false;
+}
+EXPORT_SYMBOL(is_slab_access_violated);
+
+extern int sysctl_uaccess_overflow_action __read_mostly;
+
+void uaccess_overflowed(void)
+{
+	if (unlikely(sysctl_uaccess_overflow_action == 0))
+		return;
+
+	pr_err("Usercopy overflow spotted! " 
+			"It might be an attempt to exploit the kernel. "
+			"VEID: %u, Pid: %u, Comm: %s, Uid/Euid: %u/%u.\n",
+			(int)get_exec_env()->veid, (int)task_pid_nr(current),
+			current->comm, current_uid(), current_euid());
+	dump_stack();
+
+	if (sysctl_uaccess_overflow_action == 3)
+		panic("Usercopy overflow spotted.\n");
+
+	if ((sysctl_uaccess_overflow_action == 2) &&
+			!(current->flags & PF_KTHREAD))
+		force_sig_specific(SIGKILL, current);
+}
+EXPORT_SYMBOL(uaccess_overflowed);
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/mm/mmap.c linux-2.6.32/mm/mmap.c
--- linux-2.6.32-ovz/linux-2.6.32/mm/mmap.c	2012-10-18 14:08:52.676774848 +0400
+++ linux-2.6.32/mm/mmap.c	2012-10-18 14:09:35.908776005 +0400
@@ -1604,6 +1604,7 @@ static bool should_randomize(void)
 		!(current->personality & ADDR_NO_RANDOMIZE);
 }
 
+#if 0
 #define SHLIB_BASE	0x00110000
 
 unsigned long
@@ -1672,7 +1673,68 @@ arch_get_unmapped_exec_area(struct file
 failed:
 	return current->mm->get_unmapped_area(filp, addr0, len0, pgoff, flags);
 }
+#endif
 
+/* Addresses before this value contain at least one zero byte. */
+#define ASCII_ARMOR_MAX_ADDR 0x01000000
+
+/*
+ * This function finds the first unmapped region inside of
+ * [mm->lib_mmap_base; ASCII_ARMOR_MAX_ADDR) region.  Addresses from this
+ * region contain at least one zero byte, which complicates
+ * exploitation of C string buffer overflows (C strings cannot contain zero
+ * byte inside) in return to libc class of attacks.
+ *
+ * This allocator is bottom up allocator like arch_get_unmapped_area(), but
+ * it differs from the latter.  get_unmapped_exec_area() does its best to
+ * allocate as low address as possible.
+ */
+unsigned long
+arch_get_unmapped_exec_area(struct file *filp, unsigned long addr0,
+		unsigned long len, unsigned long pgoff, unsigned long flags)
+{
+	unsigned long addr = addr0;
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+
+	if (len > TASK_SIZE)
+		return -ENOMEM;
+
+	if (flags & MAP_FIXED)
+		return addr;
+
+	/* We ALWAYS start from the beginning as base addresses
+	 * with zero high bits is a valued resource */
+	addr = max_t(unsigned long, mm->lib_mmap_base, mmap_min_addr);
+
+	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
+		/* At this point:  (!vma || addr < vma->vm_end). */
+		if (addr > TASK_SIZE - len)
+			return -ENOMEM;
+
+		/*
+		 * If kernel.randomize_va_space < 2, the executable is build as
+		 * non-PIE, and exec image base is lower than ASCII_ARMOR_MAX_ADDR,
+		 * it's possible to touch or overrun brk area in ASCII-armor
+		 * zone.  We don't want to reduce future brk growth, so we
+		 * fallback to the default allocator in this case.
+		 */
+		if (mm->brk && addr + len > mm->brk)
+			goto failed;
+
+		if (!vma || addr + len <= vma->vm_start)
+			return addr;
+
+		addr = vma->vm_end;
+
+		/* If ACSII-armor area is over, the algo gives up */
+		if (addr >= ASCII_ARMOR_MAX_ADDR)
+			goto failed;
+	}
+
+failed:
+	return current->mm->get_unmapped_area(filp, addr0, len, pgoff, flags);
+}
 
 /* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */
 struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/mm/slab.c linux-2.6.32/mm/slab.c
--- linux-2.6.32-ovz/linux-2.6.32/mm/slab.c	2012-10-18 14:08:52.732774849 +0400
+++ linux-2.6.32/mm/slab.c	2012-10-18 14:09:35.908776005 +0400
@@ -4819,7 +4819,7 @@ static const struct file_operations proc
 
 static int __init slab_proc_init(void)
 {
-	proc_create("slabinfo",S_IWUSR|S_IRUGO,NULL,&proc_slabinfo_operations);
+	proc_create("slabinfo",S_IRUSR,NULL,&proc_slabinfo_operations);
 #ifdef CONFIG_DEBUG_SLAB_LEAK
 	proc_create("slab_allocators", 0, NULL, &proc_slabstats_operations);
 #endif
@@ -4879,3 +4879,32 @@ void slab_obj_walk(struct kmem_cache *c,
 	}
 }
 EXPORT_SYMBOL(slab_obj_walk);
+
+ /*
+ * Returns true if and only if [ptr; ptr+len) touches the slab,
+ * but breaks objects boundaries.  It doesn't check whether the
+ * accessed object is actually allocated.
+ */
+bool __is_slab_access_violated(const void *ptr, size_t len)
+{
+	struct page *page;
+	struct kmem_cache *cachep = NULL;
+	struct slab *slabp;
+	unsigned int objnr;
+	unsigned long offset;
+
+	page = virt_to_head_page(ptr);
+	if (!PageSlab(page))
+		return false;
+
+	cachep = page_get_cache(page);
+	slabp = page_get_slab(page);
+	objnr = obj_to_index(cachep, slabp, (void *)ptr);
+	BUG_ON(objnr >= cachep->num);
+	offset = (const char *)ptr - obj_offset(cachep) -
+	    (const char *)index_to_obj(cachep, slabp, objnr);
+	if (offset <= obj_size(cachep) && len <= obj_size(cachep) - offset)
+		return false;
+
+	return true;
+}
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/mm/slub.c linux-2.6.32/mm/slub.c
--- linux-2.6.32-ovz/linux-2.6.32/mm/slub.c	2012-10-18 14:08:52.736774848 +0400
+++ linux-2.6.32/mm/slub.c	2012-10-18 14:09:35.908776005 +0400
@@ -5040,3 +5040,26 @@ static int __init slab_proc_init(void)
 }
 module_init(slab_proc_init);
 #endif /* CONFIG_SLABINFO */
+
+/*
+ * Returns true if and only if [ptr; ptr+len) touches the slab,
+ * but breaks objects boundaries.  It doesn't check whether the
+ * accessed object is actually allocated.
+ */
+bool __is_slab_access_violated(const void *ptr, unsigned long len)
+{
+	struct page *page;
+	struct kmem_cache *s = NULL;
+	unsigned long offset;
+
+	page = virt_to_head_page(ptr);
+	if (!PageSlab(page))
+		return false;
+
+	s = page->slab;
+	offset = ((const char *)ptr - (const char *)page_address(page)) % s->size;
+	if (offset <= s->objsize && len <= s->objsize - offset)
+		return false;
+
+	return true;
+}
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/net/ipv4/af_inet.c linux-2.6.32/net/ipv4/af_inet.c
--- linux-2.6.32-ovz/linux-2.6.32/net/ipv4/af_inet.c	2012-10-18 14:08:53.224774861 +0400
+++ linux-2.6.32/net/ipv4/af_inet.c	2012-10-18 14:09:35.912776005 +0400
@@ -104,6 +104,7 @@
 #include <net/tcp.h>
 #include <net/udp.h>
 #include <net/udplite.h>
+#include <net/ping.h>
 #include <linux/skbuff.h>
 #include <net/sock.h>
 #include <net/raw.h>
@@ -1004,6 +1005,16 @@ static struct inet_protosw inetsw_array[
 		.flags =      INET_PROTOSW_PERMANENT,
        },
 
+#ifdef CONFIG_IP_PING
+	{
+		.type =       SOCK_DGRAM,
+		.protocol =   IPPROTO_ICMP,
+		.prot =       &ping_prot,
+		.ops =        &inet_dgram_ops,
+		.no_check =   UDP_CSUM_DEFAULT,
+		.flags =      INET_PROTOSW_REUSE,
+	},
+#endif
 
        {
 	       .type =       SOCK_RAW,
@@ -1502,6 +1513,9 @@ static const struct net_protocol udp_pro
 
 static const struct net_protocol icmp_protocol = {
 	.handler =	icmp_rcv,
+#ifdef CONFIG_IP_PING
+	.err_handler =  ping_err,
+#endif
 	.no_policy =	1,
 	.netns_ok =	1,
 };
@@ -1610,6 +1624,13 @@ static int __init inet_init(void)
 	if (rc)
 		goto out_unregister_udp_proto;
 
+#ifdef CONFIG_IP_PING
+	rc = proto_register(&ping_prot, 1);
+	if (rc)
+		goto out_unregister_raw_proto;
+#endif
+
+
 	/*
 	 *	Tell SOCKET that we are alive...
 	 */
@@ -1665,6 +1686,10 @@ static int __init inet_init(void)
 	/* Add UDP-Lite (RFC 3828) */
 	udplite4_register();
 
+#ifdef CONFIG_IP_PING
+	ping_init();
+#endif
+
 	/*
 	 *	Set the ICMP layer up
 	 */
@@ -1695,6 +1720,10 @@ static int __init inet_init(void)
 	rc = 0;
 out:
 	return rc;
+#ifdef CONFIG_IP_PING
+out_unregister_raw_proto:
+       proto_unregister(&raw_prot);
+#endif
 out_unregister_udp_proto:
 	proto_unregister(&udp_prot);
 out_unregister_tcp_proto:
@@ -1719,11 +1748,19 @@ static int __init ipv4_proc_init(void)
 		goto out_tcp;
 	if (udp4_proc_init())
 		goto out_udp;
+#ifdef CONFIG_IP_PING
+	if (ping_proc_init())
+		goto out_ping;
+#endif
 	if (ip_misc_proc_init())
 		goto out_misc;
 out:
 	return rc;
 out_misc:
+#ifdef CONFIG_IP_PING
+	ping_proc_exit();
+out_ping:
+#endif
 	udp4_proc_exit();
 out_udp:
 	tcp4_proc_exit();
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/net/ipv4/icmp.c linux-2.6.32/net/ipv4/icmp.c
--- linux-2.6.32-ovz/linux-2.6.32/net/ipv4/icmp.c	2012-10-18 14:08:53.228774862 +0400
+++ linux-2.6.32/net/ipv4/icmp.c	2012-10-18 14:09:35.912776005 +0400
@@ -82,6 +82,7 @@
 #include <net/tcp.h>
 #include <net/udp.h>
 #include <net/raw.h>
+#include <net/ping.h>
 #include <linux/skbuff.h>
 #include <net/sock.h>
 #include <linux/errno.h>
@@ -799,6 +800,17 @@ static void icmp_redirect(struct sk_buff
 			       iph->saddr, skb->dev);
 		break;
 	}
+
+#ifdef CONFIG_IP_PING
+	/* Ping wants to see redirects.
+	 * Let's pretend they are errors of sorts... */
+	if (iph->protocol == IPPROTO_ICMP &&
+			iph->ihl >= 5 &&
+			pskb_may_pull(skb, (iph->ihl<<2)+8)) {
+		ping_err(skb, icmp_hdr(skb)->un.gateway);
+	}
+#endif
+
 out:
 	return;
 out_err:
@@ -1061,7 +1073,7 @@ error:
  */
 static const struct icmp_control icmp_pointers[NR_ICMP_TYPES + 1] = {
 	[ICMP_ECHOREPLY] = {
-		.handler = icmp_discard,
+		.handler = icmp_echoreply,
 	},
 	[1] = {
 		.handler = icmp_discard,
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/net/ipv4/Kconfig linux-2.6.32/net/ipv4/Kconfig
--- linux-2.6.32-ovz/linux-2.6.32/net/ipv4/Kconfig	2012-10-18 14:08:53.236774863 +0400
+++ linux-2.6.32/net/ipv4/Kconfig	2012-10-18 14:09:35.912776005 +0400
@@ -641,3 +641,13 @@ config TCP_MD5SIG
 
 	  If unsure, say N.
 
+config IP_PING
+        bool "IP: ping socket"
+        help
+          This option introduces a new kind of sockets - "ping sockets".
+ 
+          A ping socket makes it possible to send ICMP Echo messages and receive
+          corresponding ICMP Echo Reply messages without any special privileges.
+          In other words, it makes is possible to implement setuid-less /bin/ping.
+ 
+          A new ping socket is created with socket(PF_INET, SOCK_DGRAM, PROT_ICMP).
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/net/ipv4/Makefile linux-2.6.32/net/ipv4/Makefile
--- linux-2.6.32-ovz/linux-2.6.32/net/ipv4/Makefile	2009-12-03 06:51:21.000000000 +0300
+++ linux-2.6.32/net/ipv4/Makefile	2012-10-18 14:09:35.912776005 +0400
@@ -19,6 +19,7 @@ obj-$(CONFIG_IP_FIB_TRIE) += fib_trie.o
 obj-$(CONFIG_PROC_FS) += proc.o
 obj-$(CONFIG_IP_MULTIPLE_TABLES) += fib_rules.o
 obj-$(CONFIG_IP_MROUTE) += ipmr.o
+obj-$(CONFIG_IP_PING) += ping.o
 obj-$(CONFIG_NET_IPIP) += ipip.o
 obj-$(CONFIG_NET_IPGRE) += ip_gre.o
 obj-$(CONFIG_SYN_COOKIES) += syncookies.o
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/net/ipv4/ping.c linux-2.6.32/net/ipv4/ping.c
--- linux-2.6.32-ovz/linux-2.6.32/net/ipv4/ping.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6.32/net/ipv4/ping.c	2012-10-18 14:09:35.912776005 +0400
@@ -0,0 +1,927 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		"Ping" sockets
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * Based on ipv4/udp.c code.
+ *
+ * Authors:	Vasiliy Kulikov / Openwall (for Linux 2.6),
+ *		Pavel Kankovsky (for Linux 2.4.32)
+ *
+ * Pavel gave all rights to bugs to Vasiliy,
+ * none of the bugs are Pavel's now.
+ *
+ */
+
+#include <linux/uaccess.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/inet.h>
+#include <linux/netdevice.h>
+#include <net/snmp.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <net/icmp.h>
+#include <net/protocol.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+//#include <linux/export.h>
+#include <net/sock.h>
+#include <net/ping.h>
+#include <net/udp.h>
+#include <net/route.h>
+#include <net/inet_common.h>
+#include <net/checksum.h>
+
+
+static struct ping_table ping_table;
+
+static u16 ping_port_rover;
+
+static inline int ping_hashfn(struct net *net, unsigned int num, unsigned int mask)
+{
+	int res = (num + net_hash_mix(net)) & mask;
+
+	pr_debug("hash(%d) = %d\n", num, res);
+	return res;
+}
+
+static inline struct hlist_nulls_head *ping_hashslot(struct ping_table *table,
+					     struct net *net, unsigned int num)
+{
+	return &table->hash[ping_hashfn(net, num, PING_HTABLE_MASK)];
+}
+
+static int ping_v4_get_port(struct sock *sk, unsigned short ident)
+{
+	struct hlist_nulls_node *node;
+	struct hlist_nulls_head *hlist;
+	struct inet_sock *isk, *isk2;
+	struct sock *sk2 = NULL;
+
+	isk = inet_sk(sk);
+	write_lock_bh(&ping_table.lock);
+	if (ident == 0) {
+		u32 i;
+		u16 result = ping_port_rover + 1;
+
+		for (i = 0; i < (1L << 16); i++, result++) {
+			if (!result)
+				result++; /* avoid zero */
+			hlist = ping_hashslot(&ping_table, sock_net(sk),
+					    result);
+			ping_portaddr_for_each_entry(sk2, node, hlist) {
+				isk2 = inet_sk(sk2);
+
+				if (isk2->num == result)
+					goto next_port;
+			}
+
+			/* found */
+			ping_port_rover = ident = result;
+			break;
+next_port:
+			;
+		}
+		if (i >= (1L << 16))
+			goto fail;
+	} else {
+		hlist = ping_hashslot(&ping_table, sock_net(sk), ident);
+		ping_portaddr_for_each_entry(sk2, node, hlist) {
+			isk2 = inet_sk(sk2);
+
+			if ((isk2->num == ident) &&
+			    (sk2 != sk) &&
+			    (!sk2->sk_reuse || !sk->sk_reuse))
+				goto fail;
+		}
+	}
+
+	pr_debug("found port/ident = %d\n", ident);
+	isk->num = ident;
+	if (sk_unhashed(sk)) {
+		pr_debug("was not hashed\n");
+		sock_hold(sk);
+		hlist_nulls_add_head(&sk->sk_nulls_node, hlist);
+		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);
+	}
+	write_unlock_bh(&ping_table.lock);
+	return 0;
+
+fail:
+	write_unlock_bh(&ping_table.lock);
+	return 1;
+}
+
+static void ping_v4_hash(struct sock *sk)
+{
+	pr_debug("ping_v4_hash(sk->port=%u)\n", inet_sk(sk)->num);
+	BUG(); /* "Please do not press this button again." */
+}
+
+static void ping_v4_unhash(struct sock *sk)
+{
+	struct inet_sock *isk = inet_sk(sk);
+	pr_debug("ping_v4_unhash(isk=%p,isk->num=%u)\n", isk, isk->num);
+	if (sk_hashed(sk)) {
+		write_lock_bh(&ping_table.lock);
+		hlist_nulls_del(&sk->sk_nulls_node);
+		sock_put(sk);
+		isk->num = 0;
+		isk->sport = 0;
+		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
+		write_unlock_bh(&ping_table.lock);
+	}
+}
+
+static struct sock *ping_v4_lookup(struct net *net, __be32 saddr, __be32 daddr,
+				   u16 ident, int dif)
+{
+	struct hlist_nulls_head *hslot = ping_hashslot(&ping_table, net, ident);
+	struct sock *sk = NULL;
+	struct inet_sock *isk;
+	struct hlist_nulls_node *hnode;
+
+	pr_debug("try to find: num = %d, daddr = %pI4, dif = %d\n",
+		 (int)ident, &daddr, dif);
+	read_lock_bh(&ping_table.lock);
+
+	ping_portaddr_for_each_entry(sk, hnode, hslot) {
+		isk = inet_sk(sk);
+
+		pr_debug("found: %p: num = %d, daddr = %pI4, dif = %d\n", sk,
+			 (int)isk->num, &isk->rcv_saddr,
+			 sk->sk_bound_dev_if);
+
+		pr_debug("iterate\n");
+		if (isk->num != ident)
+			continue;
+		if (isk->rcv_saddr && isk->rcv_saddr != daddr)
+			continue;
+		if (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif)
+			continue;
+
+		sock_hold(sk);
+		goto exit;
+	}
+
+	sk = NULL;
+exit:
+	read_unlock_bh(&ping_table.lock);
+
+	return sk;
+}
+
+static void inet_get_ping_group_range_net(struct net *net, gid_t *low,
+					  gid_t *high)
+{
+	gid_t *data = net->ipv4.sysctl_ping_group_range;
+	unsigned int seq;
+
+	do {
+		seq = read_seqbegin(&sysctl_local_ports.lock);
+
+		*low = data[0];
+		*high = data[1];
+	} while (read_seqretry(&sysctl_local_ports.lock, seq));
+}
+
+
+static int ping_init_sock(struct sock *sk)
+{
+	struct net *net = sock_net(sk);
+	gid_t group = current_egid();
+	gid_t range[2];
+	struct group_info *group_info = get_current_groups();
+	int i, j, count = group_info->ngroups;
+
+	inet_get_ping_group_range_net(net, range, range+1);
+	if (range[0] <= group && group <= range[1])
+		return 0;
+
+	for (i = 0; i < group_info->nblocks; i++) {
+		int cp_count = min_t(int, NGROUPS_PER_BLOCK, count);
+
+		for (j = 0; j < cp_count; j++) {
+			group = group_info->blocks[i][j];
+			if (range[0] <= group && group <= range[1])
+				return 0;
+		}
+
+		count -= cp_count;
+	}
+
+	return -EACCES;
+}
+
+static void ping_close(struct sock *sk, long timeout)
+{
+	pr_debug("ping_close(sk=%p,sk->num=%u)\n",
+		 inet_sk(sk), inet_sk(sk)->num);
+	pr_debug("isk->refcnt = %d\n", sk->sk_refcnt.counter);
+
+	sk_common_release(sk);
+}
+
+/*
+ * We need our own bind because there are no privileged id's == local ports.
+ * Moreover, we don't allow binding to multi- and broadcast addresses.
+ */
+
+static int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
+{
+	struct sockaddr_in *addr = (struct sockaddr_in *)uaddr;
+	struct inet_sock *isk = inet_sk(sk);
+	unsigned short snum;
+	int chk_addr_ret;
+	int err;
+
+	if (addr_len < sizeof(struct sockaddr_in))
+		return -EINVAL;
+
+	pr_debug("ping_v4_bind(sk=%p,sa_addr=%08x,sa_port=%d)\n",
+		 sk, addr->sin_addr.s_addr, ntohs(addr->sin_port));
+
+	chk_addr_ret = inet_addr_type(sock_net(sk), addr->sin_addr.s_addr);
+	if (addr->sin_addr.s_addr == htonl(INADDR_ANY))
+		chk_addr_ret = RTN_LOCAL;
+
+	if ((sysctl_ip_nonlocal_bind == 0 &&
+	    isk->freebind == 0 && isk->transparent == 0 &&
+	     chk_addr_ret != RTN_LOCAL) ||
+	    chk_addr_ret == RTN_MULTICAST ||
+	    chk_addr_ret == RTN_BROADCAST)
+		return -EADDRNOTAVAIL;
+
+	lock_sock(sk);
+
+	err = -EINVAL;
+	if (isk->num != 0)
+		goto out;
+
+	err = -EADDRINUSE;
+	isk->rcv_saddr = isk->saddr = addr->sin_addr.s_addr;
+	snum = ntohs(addr->sin_port);
+	if (ping_v4_get_port(sk, snum) != 0) {
+		isk->saddr = isk->rcv_saddr = 0;
+		goto out;
+	}
+
+	pr_debug("after bind(): num = %d, daddr = %pI4, dif = %d\n",
+		 (int)isk->num,
+		 &isk->rcv_saddr,
+		 (int)sk->sk_bound_dev_if);
+
+	err = 0;
+	if (isk->rcv_saddr)
+		sk->sk_userlocks |= SOCK_BINDADDR_LOCK;
+	if (snum)
+		sk->sk_userlocks |= SOCK_BINDPORT_LOCK;
+	isk->sport = htons(isk->num);
+	isk->daddr = 0;
+	isk->dport = 0;
+	sk_dst_reset(sk);
+out:
+	release_sock(sk);
+	pr_debug("ping_v4_bind -> %d\n", err);
+	return err;
+}
+
+/*
+ * Is this a supported type of ICMP message?
+ */
+
+static inline int ping_supported(int type, int code)
+{
+	if (type == ICMP_ECHO && code == 0)
+		return 1;
+	return 0;
+}
+
+/*
+ * This routine is called by the ICMP module when it gets some
+ * sort of error condition.
+ */
+
+static int ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb);
+
+void ping_err(struct sk_buff *skb, u32 info)
+{
+	struct iphdr *iph = (struct iphdr *)skb->data;
+	struct icmphdr *icmph = (struct icmphdr *)(skb->data+(iph->ihl<<2));
+	struct inet_sock *inet_sock;
+	int type = icmph->type;
+	int code = icmph->code;
+	struct net *net = dev_net(skb->dev);
+	struct sock *sk;
+	int harderr;
+	int err;
+
+	/* We assume the packet has already been checked by icmp_unreach */
+
+	if (!ping_supported(icmph->type, icmph->code))
+		return;
+
+	pr_debug("ping_err(type=%04x,code=%04x,id=%04x,seq=%04x)\n", type,
+		 code, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));
+
+	sk = ping_v4_lookup(net, iph->daddr, iph->saddr,
+			    ntohs(icmph->un.echo.id), skb->dev->ifindex);
+	if (sk == NULL) {
+		pr_debug("no socket, dropping\n");
+		return;	/* No socket for error */
+	}
+	pr_debug("err on socket %p\n", sk);
+
+	err = 0;
+	harderr = 0;
+	inet_sock = inet_sk(sk);
+
+	switch (type) {
+	default:
+	case ICMP_TIME_EXCEEDED:
+		err = EHOSTUNREACH;
+		break;
+	case ICMP_SOURCE_QUENCH:
+		/* This is not a real error but ping wants to see it.
+		 * Report it with some fake errno. */
+		err = EREMOTEIO;
+		break;
+	case ICMP_PARAMETERPROB:
+		err = EPROTO;
+		harderr = 1;
+		break;
+	case ICMP_DEST_UNREACH:
+		if (code == ICMP_FRAG_NEEDED) { /* Path MTU discovery */
+			if (inet_sock->pmtudisc != IP_PMTUDISC_DONT) {
+				err = EMSGSIZE;
+				harderr = 1;
+				break;
+			}
+			goto out;
+		}
+		err = EHOSTUNREACH;
+		if (code <= NR_ICMP_UNREACH) {
+			harderr = icmp_err_convert[code].fatal;
+			err = icmp_err_convert[code].errno;
+		}
+		break;
+	case ICMP_REDIRECT:
+		/* See ICMP_SOURCE_QUENCH */
+		err = EREMOTEIO;
+		break;
+	}
+
+	/*
+	 *      RFC1122: OK.  Passes ICMP errors back to application, as per
+	 *	4.1.3.3.
+	 */
+	if (!inet_sock->recverr) {
+		if (!harderr || sk->sk_state != TCP_ESTABLISHED)
+			goto out;
+	} else {
+		ip_icmp_error(sk, skb, err, 0 /* no remote port */,
+			 info, (u8 *)icmph);
+	}
+	sk->sk_err = err;
+	sk->sk_error_report(sk);
+out:
+	sock_put(sk);
+}
+
+/*
+ *	Copy and checksum an ICMP Echo packet from user space into a buffer.
+ */
+
+struct pingfakehdr {
+	struct icmphdr icmph;
+	struct iovec *iov;
+	__wsum wcheck;
+};
+
+static int ping_getfrag(void *from, char *to,
+			int offset, int fraglen, int odd, struct sk_buff *skb)
+{
+	struct pingfakehdr *pfh = (struct pingfakehdr *)from;
+
+	if (offset == 0) {
+		if (fraglen < sizeof(struct icmphdr))
+			BUG();
+		if (csum_partial_copy_fromiovecend(to + sizeof(struct icmphdr),
+			    pfh->iov, 0, fraglen - sizeof(struct icmphdr),
+			    &pfh->wcheck))
+			return -EFAULT;
+
+		return 0;
+	}
+	if (offset < sizeof(struct icmphdr))
+		BUG();
+	if (csum_partial_copy_fromiovecend
+			(to, pfh->iov, offset - sizeof(struct icmphdr),
+			 fraglen, &pfh->wcheck))
+		return -EFAULT;
+	return 0;
+}
+
+static int ping_push_pending_frames(struct sock *sk, struct pingfakehdr *pfh)
+{
+	struct sk_buff *skb = skb_peek(&sk->sk_write_queue);
+
+	pfh->wcheck = csum_partial((char *)&pfh->icmph,
+		sizeof(struct icmphdr), pfh->wcheck);
+	pfh->icmph.checksum = csum_fold(pfh->wcheck);
+	memcpy(icmp_hdr(skb), &pfh->icmph, sizeof(struct icmphdr));
+	skb->ip_summed = CHECKSUM_NONE;
+	return ip_push_pending_frames(sk);
+}
+
+static int ping_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+			size_t len)
+{
+	struct net *net = sock_net(sk);
+	struct inet_sock *inet = inet_sk(sk);
+	struct ipcm_cookie ipc;
+	struct icmphdr user_icmph;
+	struct pingfakehdr pfh;
+	struct rtable *rt = NULL;
+	int free = 0;
+	__be32 saddr, daddr, faddr;
+	u8  tos;
+	int err;
+
+	pr_debug("ping_sendmsg(sk=%p,sk->num=%u)\n", inet, inet->num);
+
+
+	if (len > 0xFFFF)
+		return -EMSGSIZE;
+
+	/*
+	 *	Check the flags.
+	 */
+
+	/* Mirror BSD error message compatibility */
+	if (msg->msg_flags & MSG_OOB)
+		return -EOPNOTSUPP;
+
+	/*
+	 *	Fetch the ICMP header provided by the userland.
+	 *	iovec is modified!
+	 */
+
+	if (memcpy_fromiovec((u8 *)&user_icmph, msg->msg_iov,
+			     sizeof(struct icmphdr)))
+		return -EFAULT;
+	if (!ping_supported(user_icmph.type, user_icmph.code))
+		return -EINVAL;
+
+	/*
+	 *	Get and verify the address.
+	 */
+
+	if (msg->msg_name) {
+		struct sockaddr_in *usin = (struct sockaddr_in *)msg->msg_name;
+		if (msg->msg_namelen < sizeof(*usin))
+			return -EINVAL;
+		if (usin->sin_family != AF_INET)
+			return -EINVAL;
+		daddr = usin->sin_addr.s_addr;
+		/* no remote port */
+	} else {
+		if (sk->sk_state != TCP_ESTABLISHED)
+			return -EDESTADDRREQ;
+		daddr = inet->daddr;
+		/* no remote port */
+	}
+
+	ipc.addr = inet->saddr;
+	ipc.opt = NULL;
+	ipc.oif = sk->sk_bound_dev_if;
+	ipc.shtx.flags = 0;
+	err = sock_tx_timestamp(msg, sk, &ipc.shtx);
+	if (err)
+		return err;
+
+	if (msg->msg_controllen) {
+		err = ip_cmsg_send(sock_net(sk), msg, &ipc);
+		if (err)
+			return err;
+		if (ipc.opt)
+			free = 1;
+	}
+	if (!ipc.opt)
+		ipc.opt = inet->opt;
+
+	saddr = ipc.addr;
+	ipc.addr = faddr = daddr;
+
+	if (ipc.opt && ipc.opt->srr) {
+		if (!daddr)
+			return -EINVAL;
+		faddr = ipc.opt->faddr;
+	}
+	tos = RT_TOS(inet->tos);
+	if (sock_flag(sk, SOCK_LOCALROUTE) ||
+	    (msg->msg_flags & MSG_DONTROUTE) ||
+	    (ipc.opt && ipc.opt->is_strictroute)) {
+		tos |= RTO_ONLINK;
+	}
+
+	if (ipv4_is_multicast(daddr)) {
+		if (!ipc.oif)
+			ipc.oif = inet->mc_index;
+		if (!saddr)
+			saddr = inet->mc_addr;
+	}
+
+	{
+		struct flowi fl = { .oif = ipc.oif,
+				    .mark = sk->sk_mark,
+				    .nl_u = { .ip4_u = {
+						.daddr = daddr,
+						.saddr = saddr,
+						.tos = tos } },
+				    .proto = IPPROTO_ICMP,
+				    .flags = inet_sk_flowi_flags(sk),
+		};
+
+		security_sk_classify_flow(sk, &fl);
+		err = ip_route_output_flow(net, &rt, &fl, sk, 1);
+		if (err) {
+			rt = NULL;
+			if (err == -ENETUNREACH)
+				IP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);
+			goto out;
+		}
+
+		err = -EACCES;
+		if ((rt->rt_flags & RTCF_BROADCAST) &&
+		    !sock_flag(sk, SOCK_BROADCAST))
+			goto out;
+	}
+
+	if (msg->msg_flags & MSG_CONFIRM)
+		goto do_confirm;
+back_from_confirm:
+
+	if (!ipc.addr)
+		ipc.addr = rt->rt_dst;
+
+	lock_sock(sk);
+
+	pfh.icmph.type = user_icmph.type; /* already checked */
+	pfh.icmph.code = user_icmph.code; /* ditto */
+	pfh.icmph.checksum = 0;
+	pfh.icmph.un.echo.id = inet->sport;
+	pfh.icmph.un.echo.sequence = user_icmph.un.echo.sequence;
+	pfh.iov = msg->msg_iov;
+	pfh.wcheck = 0;
+
+	err = ip_append_data(sk, ping_getfrag, &pfh, len,
+			0, &ipc, &rt, msg->msg_flags);
+	if (err)
+		ip_flush_pending_frames(sk);
+	else
+		err = ping_push_pending_frames(sk, &pfh);
+	release_sock(sk);
+
+out:
+	ip_rt_put(rt);
+	if (free)
+		kfree(ipc.opt);
+	if (!err) {
+		icmp_out_count(sock_net(sk), user_icmph.type);
+		return len;
+	}
+	return err;
+
+do_confirm:
+	dst_confirm(&rt->u.dst);
+	if (!(msg->msg_flags & MSG_PROBE) || len)
+		goto back_from_confirm;
+	err = 0;
+	goto out;
+}
+
+static int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+			size_t len, int noblock, int flags, int *addr_len)
+{
+	struct inet_sock *isk = inet_sk(sk);
+	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
+	struct sk_buff *skb;
+	int copied, err;
+
+	pr_debug("ping_recvmsg(sk=%p,sk->num=%u)\n", isk, isk->num);
+
+	err = -EOPNOTSUPP;
+	if (flags & MSG_OOB)
+		goto out;
+
+	if (addr_len)
+		*addr_len = sizeof(*sin);
+
+	if (flags & MSG_ERRQUEUE)
+		return ip_recv_error(sk, msg, len);
+
+	skb = skb_recv_datagram(sk, flags, noblock, &err);
+	if (!skb)
+		goto out;
+
+	copied = skb->len;
+	if (copied > len) {
+		msg->msg_flags |= MSG_TRUNC;
+		copied = len;
+	}
+
+	/* Don't bother checking the checksum */
+	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
+	if (err)
+		goto done;
+
+	sock_recv_timestamp(msg, sk, skb);
+
+	/* Copy the address. */
+	if (sin) {
+		sin->sin_family = AF_INET;
+		sin->sin_port = 0 /* skb->h.uh->source */;
+		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
+		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+	}
+	if (isk->cmsg_flags)
+		ip_cmsg_recv(msg, skb);
+	err = copied;
+
+done:
+	skb_free_datagram(sk, skb);
+out:
+	pr_debug("ping_recvmsg -> %d\n", err);
+	return err;
+}
+
+static int ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
+{
+	pr_debug("ping_queue_rcv_skb(sk=%p,sk->num=%d,skb=%p)\n",
+		 inet_sk(sk), inet_sk(sk)->num, skb);
+	if (sock_queue_rcv_skb(sk, skb) < 0) {
+		kfree_skb(skb);
+		pr_debug("ping_queue_rcv_skb -> failed\n");
+		return -1;
+	}
+	return 0;
+}
+
+
+/*
+ *	All we need to do is get the socket.
+ */
+
+void ping_rcv(struct sk_buff *skb)
+{
+	struct sock *sk;
+	struct net *net = dev_net(skb->dev);
+	struct iphdr *iph = ip_hdr(skb);
+	struct icmphdr *icmph = icmp_hdr(skb);
+	__be32 saddr = iph->saddr;
+	__be32 daddr = iph->daddr;
+
+	/* We assume the packet has already been checked by icmp_rcv */
+
+	pr_debug("ping_rcv(skb=%p,id=%04x,seq=%04x)\n",
+		 skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));
+
+	/* Push ICMP header back */
+	skb_push(skb, skb->data - (u8 *)icmph);
+
+	sk = ping_v4_lookup(net, saddr, daddr, ntohs(icmph->un.echo.id),
+			    skb->dev->ifindex);
+	if (sk != NULL) {
+		pr_debug("rcv on socket %p\n", sk);
+		ping_queue_rcv_skb(sk, skb_get(skb));
+		sock_put(sk);
+		return;
+	}
+	pr_debug("no socket, dropping\n");
+
+	/* We're called from icmp_rcv(). kfree_skb() is done there. */
+}
+
+struct proto ping_prot = {
+	.name =		"PING",
+	.owner =	THIS_MODULE,
+	.init =		ping_init_sock,
+	.close =	ping_close,
+	.connect =	ip4_datagram_connect,
+	.disconnect =	udp_disconnect,
+	.setsockopt =	ip_setsockopt,
+	.getsockopt =	ip_getsockopt,
+	.sendmsg =	ping_sendmsg,
+	.recvmsg =	ping_recvmsg,
+	.bind =		ping_bind,
+	.backlog_rcv =	ping_queue_rcv_skb,
+	.hash =		ping_v4_hash,
+	.unhash =	ping_v4_unhash,
+	.get_port =	ping_v4_get_port,
+	.obj_size =	sizeof(struct inet_sock),
+};
+EXPORT_SYMBOL(ping_prot);
+
+#ifdef CONFIG_PROC_FS
+
+static struct sock *ping_get_first(struct seq_file *seq, int start)
+{
+	struct sock *sk;
+	struct ping_iter_state *state = seq->private;
+	struct net *net = seq_file_net(seq);
+
+	for (state->bucket = start; state->bucket < PING_HTABLE_SIZE;
+	     ++state->bucket) {
+		struct hlist_nulls_node *node;
+		struct hlist_nulls_head *hslot;
+
+		hslot = &ping_table.hash[state->bucket];
+
+		if (hlist_nulls_empty(hslot))
+			continue;
+
+		sk_nulls_for_each(sk, node, hslot) {
+			if (net_eq(sock_net(sk), net))
+				goto found;
+		}
+	}
+	sk = NULL;
+found:
+	return sk;
+}
+
+static struct sock *ping_get_next(struct seq_file *seq, struct sock *sk)
+{
+	struct ping_iter_state *state = seq->private;
+	struct net *net = seq_file_net(seq);
+
+	do {
+		sk = sk_nulls_next(sk);
+	} while (sk && (!net_eq(sock_net(sk), net)));
+
+	if (!sk)
+		return ping_get_first(seq, state->bucket + 1);
+	return sk;
+}
+
+static struct sock *ping_get_idx(struct seq_file *seq, loff_t pos)
+{
+	struct sock *sk = ping_get_first(seq, 0);
+
+	if (sk)
+		while (pos && (sk = ping_get_next(seq, sk)) != NULL)
+			--pos;
+	return pos ? NULL : sk;
+}
+
+static void *ping_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	struct ping_iter_state *state = seq->private;
+	state->bucket = 0;
+
+	read_lock_bh(&ping_table.lock);
+
+	return *pos ? ping_get_idx(seq, *pos-1) : SEQ_START_TOKEN;
+}
+
+static void *ping_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	struct sock *sk;
+
+	if (v == SEQ_START_TOKEN)
+		sk = ping_get_idx(seq, 0);
+	else
+		sk = ping_get_next(seq, v);
+
+	++*pos;
+	return sk;
+}
+
+static void ping_seq_stop(struct seq_file *seq, void *v)
+{
+	read_unlock_bh(&ping_table.lock);
+}
+
+static void ping_format_sock(struct sock *sp, struct seq_file *f,
+		int bucket, int *len)
+{
+	struct inet_sock *inet = inet_sk(sp);
+	__be32 dest = inet->daddr;
+	__be32 src = inet->rcv_saddr;
+	__u16 destp = ntohs(inet->dport);
+	__u16 srcp = ntohs(inet->sport);
+
+	seq_printf(f, "%5d: %08X:%04X %08X:%04X"
+		" %02X %08X:%08X %02X:%08lX %08X %5d %8d %lu %d %pK %d%n",
+		bucket, src, srcp, dest, destp, sp->sk_state,
+		sk_wmem_alloc_get(sp),
+		sk_rmem_alloc_get(sp),
+		0, 0L, 0, sock_i_uid(sp), 0, sock_i_ino(sp),
+		atomic_read(&sp->sk_refcnt), sp,
+		atomic_read(&sp->sk_drops), len);
+}
+
+static int ping_seq_show(struct seq_file *seq, void *v)
+{
+	if (v == SEQ_START_TOKEN)
+		seq_printf(seq, "%-127s\n",
+			   "  sl  local_address rem_address   st tx_queue "
+			   "rx_queue tr tm->when retrnsmt   uid  timeout "
+			   "inode ref pointer drops");
+	else {
+		struct ping_iter_state *state = seq->private;
+		int len;
+
+		ping_format_sock(v, seq, state->bucket, &len);
+		seq_printf(seq, "%*s\n", 127 - len, "");
+	}
+	return 0;
+}
+
+static const struct seq_operations ping_seq_ops = {
+	.show		= ping_seq_show,
+	.start		= ping_seq_start,
+	.next		= ping_seq_next,
+	.stop		= ping_seq_stop,
+};
+
+static int ping_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open_net(inode, file, &ping_seq_ops,
+			   sizeof(struct ping_iter_state));
+}
+
+static const struct file_operations ping_seq_fops = {
+	.open		= ping_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release_net,
+};
+
+static int ping_proc_register(struct net *net)
+{
+	struct proc_dir_entry *p;
+	int rc = 0;
+
+	p = proc_net_fops_create(net, "icmp", S_IRUGO, &ping_seq_fops);
+	if (!p)
+		rc = -ENOMEM;
+	return rc;
+}
+
+static void ping_proc_unregister(struct net *net)
+{
+	proc_net_remove(net, "icmp");
+}
+
+
+static int __net_init ping_proc_init_net(struct net *net)
+{
+	return ping_proc_register(net);
+}
+
+static void __net_exit ping_proc_exit_net(struct net *net)
+{
+	ping_proc_unregister(net);
+}
+
+static struct pernet_operations ping_net_ops = {
+	.init = ping_proc_init_net,
+	.exit = ping_proc_exit_net,
+};
+
+int __init ping_proc_init(void)
+{
+	return register_pernet_subsys(&ping_net_ops);
+}
+
+void ping_proc_exit(void)
+{
+	unregister_pernet_subsys(&ping_net_ops);
+}
+
+#endif
+
+void __init ping_init(void)
+{
+	int i;
+
+	for (i = 0; i < PING_HTABLE_SIZE; i++)
+		INIT_HLIST_NULLS_HEAD(&ping_table.hash[i], i);
+	rwlock_init(&ping_table.lock);
+}
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/net/ipv4/sysctl_net_ipv4.c linux-2.6.32/net/ipv4/sysctl_net_ipv4.c
--- linux-2.6.32-ovz/linux-2.6.32/net/ipv4/sysctl_net_ipv4.c	2012-10-18 14:08:53.244774862 +0400
+++ linux-2.6.32/net/ipv4/sysctl_net_ipv4.c	2012-10-18 14:09:35.912776005 +0400
@@ -12,6 +12,7 @@
 #include <linux/inetdevice.h>
 #include <linux/seqlock.h>
 #include <linux/init.h>
+#include <linux/nsproxy.h>
 #include <net/snmp.h>
 #include <net/icmp.h>
 #include <net/ip.h>
@@ -25,6 +26,8 @@ static int zero;
 static int tcp_retr1_max = 255;
 static int ip_local_port_range_min[] = { 1, 1 };
 static int ip_local_port_range_max[] = { 65535, 65535 };
+static int ip_ping_group_range_min[] = { 0, 0 };
+static int ip_ping_group_range_max[] = { 65535, 65535 };
 
 int sysctl_tcp_use_sg = 1;
 EXPORT_SYMBOL(sysctl_tcp_use_sg);
@@ -93,6 +96,65 @@ static int ipv4_sysctl_local_port_range(
 	return ret;
 }
 
+void inet_get_ping_group_range_net(struct net *net, unsigned int *low, unsigned int *high)
+{
+	unsigned int *data = net->ipv4.sysctl_ping_group_range;
+	unsigned seq;
+	do {
+		seq = read_seqbegin(&sysctl_local_ports.lock);
+
+		*low = data[0];
+		*high = data[1];
+	} while (read_seqretry(&sysctl_local_ports.lock, seq));
+}
+
+void inet_get_ping_group_range_table(struct ctl_table *table, unsigned int *low, unsigned int *high)
+{
+	unsigned int *data = table->data;
+	unsigned seq;
+	do {
+		seq = read_seqbegin(&sysctl_local_ports.lock);
+
+		*low = data[0];
+		*high = data[1];
+	} while (read_seqretry(&sysctl_local_ports.lock, seq));
+}
+
+/* Update system visible IP port range */
+static void set_ping_group_range(struct ctl_table *table, int range[2])
+{
+	int *data = table->data;
+	write_seqlock(&sysctl_local_ports.lock);
+	data[0] = range[0];
+	data[1] = range[1];
+	write_sequnlock(&sysctl_local_ports.lock);
+}
+
+/* Validate changes from /proc interface. */
+static int ipv4_ping_group_range(ctl_table *table, int write,
+		void __user *buffer,
+		size_t *lenp, loff_t *ppos)
+{
+	int ret;
+	int range[2];
+	ctl_table tmp = {
+		.data = &range,
+		.maxlen = sizeof(range),
+		.mode = table->mode,
+		.extra1 = &ip_ping_group_range_min,
+		.extra2 = &ip_ping_group_range_max,
+	};
+
+	inet_get_ping_group_range_table(table, range, range + 1);
+	ret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);
+
+	if (write && ret == 0)
+		set_ping_group_range(table, range);
+
+	return ret;
+}
+
+
 
 static int proc_tcp_congestion_control(ctl_table *ctl, int write,
 				       void __user *buffer, size_t *lenp, loff_t *ppos)
@@ -850,6 +912,15 @@ static struct ctl_table ipv4_net_table[]
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec
 	},
+#ifdef CONFIG_IP_PING
+	{
+		.procname	= "ping_group_range",
+		.data		= &init_net.ipv4.sysctl_ping_group_range,
+		.maxlen		= sizeof(init_net.ipv4.sysctl_ping_group_range),
+		.mode		= 0644,
+		.proc_handler	= ipv4_ping_group_range,
+	},
+#endif
 	{ }
 };
 
@@ -884,8 +955,22 @@ static __net_init int ipv4_sysctl_init_n
 			&net->ipv4.sysctl_icmp_ratemask;
 		table[6].data =
 			&net->ipv4.sysctl_rt_cache_rebuild_count;
+#ifdef CONFIG_IP_PING
+		table[7].data =
+			&net->ipv4.sysctl_ping_group_range;
+#endif
+
 	}
 
+#ifdef CONFIG_IP_PING
+	/*
+	 * Sane defaults - only processes with CAP_NET_RAW
+	 * may create ping sockets.
+	 */
+	net->ipv4.sysctl_ping_group_range[0] = 1;
+	net->ipv4.sysctl_ping_group_range[1] = 0;
+#endif
+
 	net->ipv4.sysctl_rt_cache_rebuild_count = 4;
 
 	net->ipv4.ipv4_hdr = register_net_sysctl_table(net,
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/net/netfilter/xt_AUDIT.c linux-2.6.32/net/netfilter/xt_AUDIT.c
--- linux-2.6.32-ovz/linux-2.6.32/net/netfilter/xt_AUDIT.c	2012-10-18 14:08:53.328774865 +0400
+++ linux-2.6.32/net/netfilter/xt_AUDIT.c	2012-10-18 14:09:35.912776005 +0400
@@ -93,6 +93,7 @@ static void audit_ip4(struct audit_buffe
 	audit_proto(ab, skb, ih->protocol, ih->ihl * 4);
 }
 
+#ifdef CONFIG_IPV6
 static void audit_ip6(struct audit_buffer *ab, struct sk_buff *skb)
 {
 	struct ipv6hdr _ip6h;
@@ -117,6 +118,7 @@ static void audit_ip6(struct audit_buffe
 	if (offset)
 		audit_proto(ab, skb, nexthdr, offset);
 }
+#endif
 
 static unsigned int
 audit_tg(struct sk_buff *skb, const struct xt_target_param *par)
@@ -147,9 +149,11 @@ audit_tg(struct sk_buff *skb, const stru
 				audit_ip4(ab, skb);
 				break;
 
+#ifdef CONFIG_IPV6
 			case __constant_htons(ETH_P_IPV6):
 				audit_ip6(ab, skb);
 				break;
+#endif
 			}
 		}
 	}
@@ -159,9 +163,11 @@ audit_tg(struct sk_buff *skb, const stru
 		audit_ip4(ab, skb);
 		break;
 
+#ifdef CONFIG_IPV6
 	case NFPROTO_IPV6:
 		audit_ip6(ab, skb);
 		break;
+#endif
 	}
 
 	audit_log_end(ab);
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/scripts/mkcompile_h linux-2.6.32/scripts/mkcompile_h
--- linux-2.6.32-ovz/linux-2.6.32/scripts/mkcompile_h	2009-12-03 06:51:21.000000000 +0300
+++ linux-2.6.32/scripts/mkcompile_h	2012-10-18 14:09:35.912776005 +0400
@@ -64,21 +64,9 @@ UTS_TRUNCATE="cut -b -$UTS_LEN"
   echo \#define UTS_VERSION \"`echo $UTS_VERSION | $UTS_TRUNCATE`\"
 
   echo \#define LINUX_COMPILE_TIME \"`date +%T`\"
-  echo \#define LINUX_COMPILE_BY \"`whoami`\"
-  echo \#define LINUX_COMPILE_HOST \"`hostname | $UTS_TRUNCATE`\"
-
-  if [ -x /bin/dnsdomainname ]; then
-    domain=`dnsdomainname 2> /dev/null`
-  elif [ -x /bin/domainname ]; then
-    domain=`domainname 2> /dev/null`
-  fi
-
-  if [ -n "$domain" ]; then
-    echo \#define LINUX_COMPILE_DOMAIN \"`echo $domain | $UTS_TRUNCATE`\"
-  else
-    echo \#define LINUX_COMPILE_DOMAIN
-  fi
-
+  echo \#define LINUX_COMPILE_BY \"sources\"
+  echo \#define LINUX_COMPILE_HOST \"${ARCH}.example.org\"
+  echo \#define LINUX_COMPILE_DOMAIN \"\"
   echo \#define LINUX_COMPILER \"`$CC -v 2>&1 | tail -n 1`\"
 ) > .tmpcompile
 
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/security/commoncap.c linux-2.6.32/security/commoncap.c
--- linux-2.6.32-ovz/linux-2.6.32/security/commoncap.c	2012-10-18 14:08:53.432774867 +0400
+++ linux-2.6.32/security/commoncap.c	2012-10-20 13:41:15.462231862 +0400
@@ -28,6 +28,7 @@
 #include <linux/prctl.h>
 #include <linux/securebits.h>
 #include <linux/personality.h>
+#include <linux/syslog.h>
 
 /*
  * If a non-root user executes a setuid-root binary in
@@ -975,12 +976,17 @@ error:
 /**
  * cap_syslog - Determine whether syslog function is permitted
  * @type: Function requested
+ * @from_file: Whether this request came from an open file (i.e. /proc)
  *
  * Determine whether the current process is permitted to use a particular
  * syslog function, returning 0 if permission is granted, -ve if not.
  */
-int cap_syslog(int type)
+int cap_syslog(int type, bool from_file)
 {
+	/* /proc/kmsg can open be opened by CAP_SYS_ADMIN */
+	if (type != 1 && from_file)
+		return 0;
+
 	if (dmesg_restrict && !capable(CAP_SYS_ADMIN) &&
 		 ve_is_super(get_exec_env()))
 			return -EPERM;
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/security/Kconfig linux-2.6.32/security/Kconfig
--- linux-2.6.32-ovz/linux-2.6.32/security/Kconfig	2012-10-18 14:08:53.436774868 +0400
+++ linux-2.6.32/security/Kconfig	2012-10-18 14:09:35.912776005 +0400
@@ -47,7 +47,7 @@ config SECURITY_DMESG_RESTRICT
 	  syslog via dmesg(8).
 
 	  If this option is not selected, no restrictions will be enforced
-	  unless the dmesg_restrict sysctl is explicitly set to (1).
+	  unless the dmesg_restrict sysctl is explicitly set to 1.
 
 	  If you are unsure how to answer this question, answer N.
 
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/security/security.c linux-2.6.32/security/security.c
--- linux-2.6.32-ovz/linux-2.6.32/security/security.c	2012-10-18 14:08:53.440774868 +0400
+++ linux-2.6.32/security/security.c	2012-10-20 13:38:28.866227401 +0400
@@ -199,9 +199,9 @@ int security_quota_on(struct dentry *den
 	return security_ops->quota_on(dentry);
 }
 
-int security_syslog(int type)
+int security_syslog(int type, bool from_file)
 {
-	return security_ops->syslog(type);
+	return security_ops->syslog(type, from_file);
 }
 
 int security_settime(struct timespec *ts, struct timezone *tz)
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/security/selinux/hooks.c linux-2.6.32/security/selinux/hooks.c
--- linux-2.6.32-ovz/linux-2.6.32/security/selinux/hooks.c	2012-10-18 14:08:53.444774867 +0400
+++ linux-2.6.32/security/selinux/hooks.c	2012-10-20 13:38:28.874227401 +0400
@@ -76,6 +76,7 @@
 #include <linux/selinux.h>
 #include <linux/mutex.h>
 #include <linux/posix-timers.h>
+#include <linux/syslog.h>
 
 #include "avc.h"
 #include "objsec.h"
@@ -2057,11 +2058,11 @@ static int selinux_quota_on(struct dentr
 	return dentry_has_perm(cred, NULL, dentry, FILE__QUOTAON);
 }
 
-static int selinux_syslog(int type)
+static int selinux_syslog(int type, bool from_file)
 {
 	int rc;
 
-	rc = cap_syslog(type);
+	rc = cap_syslog(type, from_file);
 	if (rc)
 		return rc;
 
diff -uNrp -X exclude-diff-names linux-2.6.32-ovz/linux-2.6.32/security/smack/smack_lsm.c linux-2.6.32/security/smack/smack_lsm.c
--- linux-2.6.32-ovz/linux-2.6.32/security/smack/smack_lsm.c	2009-12-03 06:51:21.000000000 +0300
+++ linux-2.6.32/security/smack/smack_lsm.c	2012-10-20 13:38:28.886227402 +0400
@@ -157,12 +157,12 @@ static int smack_ptrace_traceme(struct t
  *
  * Returns 0 on success, error code otherwise.
  */
-static int smack_syslog(int type)
+static int smack_syslog(int type, bool from_file)
 {
 	int rc;
 	char *sp = current_security();
 
-	rc = cap_syslog(type);
+	rc = cap_syslog(type, from_file);
 	if (rc != 0)
 		return rc;
 

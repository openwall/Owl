diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/Documentation/sysctl/kernel.txt linux-2.6.18-194.26.1.el5.028stab079.1-owl/Documentation/sysctl/kernel.txt
--- linux-2.6.18-194.26.1.el5.028stab079.1/Documentation/sysctl/kernel.txt	2010-11-30 12:25:58 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/Documentation/sysctl/kernel.txt	2010-12-08 05:54:43 +0000
@@ -22,6 +22,7 @@ show up in /proc/sys/kernel:
 - core_uses_pid
 - ctrl-alt-del
 - dentry-state
+- dmesg_restrict
 - domainname
 - hostname
 - hotplug
@@ -133,6 +134,19 @@ to decide what to do with it.
 
 ==============================================================
 
+dmesg_restrict:
+
+This toggle indicates whether unprivileged users are prevented from using
+dmesg(8) to view messages from the kernel's log buffer.  When
+dmesg_restrict is set to (0) there are no restrictions.  When
+dmesg_restrict is set set to (1), users must have CAP_SYS_ADMIN to use
+dmesg(8).
+
+The kernel config option CONFIG_SECURITY_DMESG_RESTRICT sets the default
+value of dmesg_restrict.
+
+==============================================================
+
 domainname & hostname:
 
 These files can be used to set the NIS/YP domainname and the
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/Makefile linux-2.6.18-194.26.1.el5.028stab079.1-owl/Makefile
--- linux-2.6.18-194.26.1.el5.028stab079.1/Makefile	2010-11-30 12:26:54 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/Makefile	2010-12-08 03:31:52 +0000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 18
-EXTRAVERSION = -194.26.1.el5.028stab079.1
+EXTRAVERSION = -194.26.1.el5.028stab079.1.owl1
 RHEL_MAJOR = 5
 RHEL_MINOR = 5
 NAME=Avast! A bilge rat!
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/arch/i386/kernel/cpu/amd.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/arch/i386/kernel/cpu/amd.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/arch/i386/kernel/cpu/amd.c	2010-11-30 12:26:47 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/arch/i386/kernel/cpu/amd.c	2010-12-08 03:31:52 +0000
@@ -45,11 +45,14 @@ static void __cpuinit amd_fixup_dcm(stru
 	if (cpu_has(c, X86_FEATURE_AMD_DCM))
 		return;
 
+#if 0
+/* early_is_k8_nb() is only defined under arch/x86_64/ */
 	/* proceed only if there is a valid AMD northbridge
 	 * (not in virtualized environments!)
 	 */
 	if (!early_is_k8_nb(read_pci_config(0, 24, 3, 0x00)))
 		return;
+#endif
 
 	rdmsrl(0xc001100c, value);
 
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/arch/i386/kernel/cpu/intel_cacheinfo.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/arch/i386/kernel/cpu/intel_cacheinfo.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/arch/i386/kernel/cpu/intel_cacheinfo.c	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/arch/i386/kernel/cpu/intel_cacheinfo.c	2010-12-08 03:31:52 +0000
@@ -47,10 +47,12 @@ static void wbinvd_on_cpu(int cpu)
 	smp_call_function_single(cpu, __wbinvd, NULL, 0, 1);
 }
 
+#if 0
 static int wbinvd_on_all_cpus(void)
 {
 	return on_each_cpu(__wbinvd, NULL, 0, 1);
 }
+#endif
 
 /* from arch/x86/kernel/cpu/amd.c upstream */
 static int amd_get_nb_id(int cpu)
@@ -331,9 +333,12 @@ amd_check_l3_disable(int index, struct _
 	     (boot_cpu_data.x86_mask  < 0x1)))
 		return;
 
+#if 0
+/* num_k8_northbridges is only defined under arch/x86_64/ */
 	/* not in virtualized environments */
 	if (num_k8_northbridges == 0)
 		return;
+#endif
 
 	this_leaf->can_disable = true;
 	this_leaf->l3_indices  = amd_calc_l3_indices();
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/arch/x86_64/Kconfig linux-2.6.18-194.26.1.el5.028stab079.1-owl/arch/x86_64/Kconfig
--- linux-2.6.18-194.26.1.el5.028stab079.1/arch/x86_64/Kconfig	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/arch/x86_64/Kconfig	2010-12-08 03:31:52 +0000
@@ -476,6 +476,7 @@ config IOMMU
 	default y
 	select SWIOTLB
 	select AGP
+	select IOMMU_HELPER
 	depends on PCI && !X86_64_XEN
 	help
 	  Support for full DMA access of devices with 32bit memory access only
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/drivers/ata/Kconfig linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/ata/Kconfig
--- linux-2.6.18-194.26.1.el5.028stab079.1/drivers/ata/Kconfig	2010-11-30 12:26:17 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/ata/Kconfig	2010-12-08 03:31:52 +0000
@@ -445,8 +445,10 @@ config PATA_MARVELL
 	tristate "Marvell PATA support via legacy mode"
 	depends on PCI
 	help
-	  This option enables limited support for the Marvell 88SE6145 ATA
-	  controller.
+	  This option enables limited support for the Marvell 88SE61xx ATA
+	  controllers. If you wish to use only the SATA ports then select
+	  the AHCI driver alone. If you wish to use the PATA port or both
+	  SATA and PATA include this driver.
 
 	  If unsure, say N.
 
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/drivers/ata/ahci.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/ata/ahci.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/drivers/ata/ahci.c	2010-11-30 12:26:38 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/ata/ahci.c	2010-12-08 03:31:52 +0000
@@ -616,6 +616,15 @@ module_param(ahci_em_messages, int, 0444
 MODULE_PARM_DESC(ahci_em_messages,
 	"Set AHCI Enclosure Management Message type (0 = disabled, 1 = LED");
 
+#if defined(CONFIG_PATA_MARVELL) || defined(CONFIG_PATA_MARVELL_MODULE)
+static int marvell_enable;
+#else
+static int marvell_enable = 1;
+#endif
+module_param(marvell_enable, int, 0644);
+MODULE_PARM_DESC(marvell_enable, "Marvell SATA via AHCI (1 = enabled)");
+
+
 static inline int ahci_nr_ports(u32 cap)
 {
 	return (cap & 0x1f) + 1;
@@ -735,6 +744,8 @@ static void ahci_save_initial_config(str
 			   "MV_AHCI HACK: port_map %x -> %x\n",
 			   port_map,
 			   port_map & mv);
+		dev_printk(KERN_ERR, &pdev->dev,
+			  "Disabling your PATA port on the Marvell SATA/PATA controller, which is unsupported by the AHCI driver. Use the boot option 'ahci.marvell_enable=0' to avoid this and let the likely slower Marvell PATA driver take over, supporting both SATA and PATA ports.\n");
 
 		port_map &= mv;
 	}
@@ -2568,6 +2579,15 @@ static int ahci_init_one(struct pci_dev 
 	if (!printed_version++)
 		dev_printk(KERN_DEBUG, &pdev->dev, "version " DRV_VERSION "\n");
 
+	/* The AHCI driver can only drive the SATA ports, the PATA driver
+	   can drive them all so if both drivers are selected make sure
+	   AHCI stays out of the way */
+	if (pdev->vendor == PCI_VENDOR_ID_MARVELL && !marvell_enable) {
+		dev_printk(KERN_ERR, &pdev->dev,
+			  "Skipping the Marvell SATA/PATA controller in order to let the Marvell PATA driver take over. Use the boot option 'ahci.marvell_enable=1' to avoid this, likely gaining a bit of performance but losing support for your PATA port.\n");
+		return -ENODEV;
+	}
+
 	/* acquire resources */
 	rc = pcim_enable_device(pdev);
 	if (rc)
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/drivers/ata/pata_marvell.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/ata/pata_marvell.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/drivers/ata/pata_marvell.c	2010-11-30 12:26:17 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/ata/pata_marvell.c	2010-12-08 03:31:52 +0000
@@ -5,7 +5,7 @@
  *	isn't making full use of the device functionality but it is
  *	easy to get working.
  *
- *	(c) 2006 Red Hat  <alan@redhat.com>
+ *	(c) 2006 Red Hat
  */
 
 #include <linux/kernel.h>
@@ -20,29 +20,30 @@
 #include <linux/ata.h>
 
 #define DRV_NAME	"pata_marvell"
-#define DRV_VERSION	"0.1.4"
+#define DRV_VERSION	"0.1.6"
 
 /**
- *	marvell_pre_reset	-	check for 40/80 pin
- *	@link: link
- *	@deadline: deadline jiffies for the operation
+ *	marvell_pata_active	-	check if PATA is active
+ *	@pdev: PCI device
  *
- *	Perform the PATA port setup we need.
+ *	Returns 1 if the PATA port may be active. We know how to check this
+ *	for the 6145 but not the other devices
  */
 
-static int marvell_pre_reset(struct ata_link *link, unsigned long deadline)
+static int marvell_pata_active(struct pci_dev *pdev)
 {
-	struct ata_port *ap = link->ap;
-	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
+	int i;
 	u32 devices;
 	void __iomem *barp;
-	int i;
 
-	/* Check if our port is enabled */
+	/* We don't yet know how to do this for other devices */
+	if (pdev->device != 0x6145)
+		return 1;	
 
 	barp = pci_iomap(pdev, 5, 0x10);
 	if (barp == NULL)
 		return -ENOMEM;
+
 	printk("BAR5:");
 	for(i = 0; i <= 0x0F; i++)
 		printk("%02X:%02X ", i, ioread8(barp + i));
@@ -51,9 +52,27 @@ static int marvell_pre_reset(struct ata_
 	devices = ioread32(barp + 0x0C);
 	pci_iounmap(pdev, barp);
 
-	if ((pdev->device == 0x6145) && (ap->port_no == 0) &&
-	    (!(devices & 0x10)))	/* PATA enable ? */
-		return -ENOENT;
+	if (devices & 0x10)
+		return 1;
+	return 0;
+}
+
+/**
+ *	marvell_pre_reset	-	probe begin
+ *	@link: link
+ *	@deadline: deadline jiffies for the operation
+ *
+ *	Perform the PATA port setup we need.
+ */
+
+static int marvell_pre_reset(struct ata_link *link, unsigned long deadline)
+{
+	struct ata_port *ap = link->ap;
+	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
+
+	if (pdev->device == 0x6145 && ap->port_no == 0 &&
+		!marvell_pata_active(pdev))	/* PATA enable ? */
+			return -ENOENT;
 
 	return ata_sff_prereset(link, deadline);
 }
@@ -107,8 +126,8 @@ static int marvell_init_one (struct pci_
 	static const struct ata_port_info info = {
 		.flags		= ATA_FLAG_SLAVE_POSS,
 
-		.pio_mask	= 0x1f,
-		.mwdma_mask	= 0x07,
+		.pio_mask	= ATA_PIO4,
+		.mwdma_mask	= ATA_MWDMA2,
 		.udma_mask 	= ATA_UDMA5,
 
 		.port_ops	= &marvell_ops,
@@ -117,8 +136,8 @@ static int marvell_init_one (struct pci_
 		/* Slave possible as its magically mapped not real */
 		.flags		= ATA_FLAG_SLAVE_POSS,
 
-		.pio_mask	= 0x1f,
-		.mwdma_mask	= 0x07,
+		.pio_mask	= ATA_PIO4,
+		.mwdma_mask	= ATA_MWDMA2,
 		.udma_mask 	= ATA_UDMA6,
 
 		.port_ops	= &marvell_ops,
@@ -128,6 +147,12 @@ static int marvell_init_one (struct pci_
 	if (pdev->device == 0x6101)
 		ppi[1] = &ata_dummy_port_info;
 
+#if defined(CONFIG_SATA_AHCI) || defined(CONFIG_SATA_AHCI_MODULE)
+	if (!marvell_pata_active(pdev)) {
+		printk(KERN_INFO DRV_NAME ": PATA port not active, deferring to AHCI driver.\n");
+		return -ENODEV;
+	}
+#endif
 	return ata_pci_sff_init_one(pdev, ppi, &marvell_sht, NULL);
 }
 
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/drivers/char/keyboard.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/char/keyboard.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/drivers/char/keyboard.c	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/char/keyboard.c	2010-12-08 03:31:52 +0000
@@ -1376,7 +1376,7 @@ int __init kbd_init(void)
 		kbd_table[i].lockstate = KBD_DEFLOCK;
 		kbd_table[i].slockstate = 0;
 		kbd_table[i].modeflags = KBD_DEFMODE;
-		kbd_table[i].kbdmode = VC_UNICODE;
+		kbd_table[i].kbdmode = VC_XLATE;
 	}
 
 	input_register_handler(&kbd_handler);
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/drivers/char/vt.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/char/vt.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/drivers/char/vt.c	2010-11-30 12:26:48 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/char/vt.c	2010-12-08 03:31:52 +0000
@@ -1497,7 +1497,7 @@ static void reset_terminal(struct vc_dat
 	vc->vc_charset		= 0;
 	vc->vc_need_wrap	= 0;
 	vc->vc_report_mouse	= 0;
-	vc->vc_utf		= 1;
+	vc->vc_utf		= 0;
 	vc->vc_utf_count	= 0;
 
 	vc->vc_disp_ctrl	= 0;
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/drivers/dca/Kconfig linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/dca/Kconfig
--- linux-2.6.18-194.26.1.el5.028stab079.1/drivers/dca/Kconfig	2010-11-30 12:26:28 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/dca/Kconfig	2010-12-08 03:31:52 +0000
@@ -3,7 +3,7 @@
 #
 
 config DCA
-	tristate
+	tristate "DCA server configuration"
 	depends on DMA_ENGINE_V3 && PCI
 	default m
 	---help---
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/drivers/message/fusion/mptsas.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/message/fusion/mptsas.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/drivers/message/fusion/mptsas.c	2010-11-30 12:26:48 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/message/fusion/mptsas.c	2010-12-08 03:31:52 +0000
@@ -436,6 +436,23 @@ mptsas_is_end_device(struct mptsas_devin
 		return 0;
 }
 
+static inline void
+mptsas_set_rphy(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_rphy *rphy)
+{
+	if (phy_info->port_details) {
+		phy_info->port_details->rphy = rphy;
+		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "sas_rphy_add: rphy=%p\n",
+		    ioc->name, rphy));
+	}
+
+	if (rphy) {
+		dsaswideprintk(ioc, dev_printk(KERN_DEBUG,
+		    &rphy->dev, MYIOC_s_FMT "add:", ioc->name));
+		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "rphy=%p release=%p\n",
+		    ioc->name, rphy, rphy->dev.release));
+	}
+}
+
 /* no mutex */
 static void
 mptsas_port_delete(MPT_ADAPTER *ioc, struct mptsas_portinfo_details * port_details)
@@ -474,23 +491,6 @@ mptsas_get_rphy(struct mptsas_phyinfo *p
 		return NULL;
 }
 
-static inline void
-mptsas_set_rphy(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_rphy *rphy)
-{
-	if (phy_info->port_details) {
-		phy_info->port_details->rphy = rphy;
-		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "sas_rphy_add: rphy=%p\n",
-		    ioc->name, rphy));
-	}
-
-	if (rphy) {
-		dsaswideprintk(ioc, dev_printk(KERN_DEBUG,
-		    &rphy->dev, MYIOC_s_FMT "add:", ioc->name));
-		dsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "rphy=%p release=%p\n",
-		    ioc->name, rphy, rphy->dev.release));
-	}
-}
-
 static inline struct sas_port *
 mptsas_get_port(struct mptsas_phyinfo *phy_info)
 {
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/drivers/serial/serial_core.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/serial/serial_core.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/drivers/serial/serial_core.c	2010-11-30 12:26:26 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/drivers/serial/serial_core.c	2010-12-08 06:12:16 +0000
@@ -1046,6 +1046,7 @@ static int uart_get_count(struct uart_st
 	struct uart_icount cnow;
 	struct uart_port *port = state->port;
 
+	memset(&icount, 0, sizeof(struct serial_icounter_struct));
 	spin_lock_irq(&port->lock);
 	memcpy(&cnow, &port->icount, sizeof(struct uart_icount));
 	spin_unlock_irq(&port->lock);
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/fs/Kconfig linux-2.6.18-194.26.1.el5.028stab079.1-owl/fs/Kconfig
--- linux-2.6.18-194.26.1.el5.028stab079.1/fs/Kconfig	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/fs/Kconfig	2010-12-08 03:31:52 +0000
@@ -473,6 +473,7 @@ config QFMT_V2
 config SIM_FS
 	tristate "VPS filesystem"
 	depends on VZ_QUOTA
+	select EXPORTFS
 	default m
 	help
 	  This file system is a part of Virtuozzo. It intoduces a fake
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/fs/exec.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/fs/exec.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/fs/exec.c	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/fs/exec.c	2010-12-09 16:50:30 +0000
@@ -214,7 +214,8 @@ struct page *get_arg_page(struct linux_b
 		 *  - the program will have a reasonable amount of stack left
 		 *    to work from.
 		 */
-		if (size > rlim[RLIMIT_STACK].rlim_cur / 4) {
+		if (size > rlim[RLIMIT_STACK].rlim_cur / 4 ||
+		    size > MAX_ARG_STACK) {
 			put_page(page);
 			return NULL;
 		}
@@ -269,7 +270,10 @@ static int __bprm_mm_init(struct linux_b
 
 	vma->vm_flags = VM_STACK_FLAGS;
 	vma->vm_page_prot = protection_map[vma->vm_flags & 0x7];
-	err = insert_vm_struct(mm, vma);
+
+	err = security_file_mmap_addr(NULL, 0, 0, 0, vma->vm_start, 1);
+	if (!err)
+		err = insert_vm_struct(mm, vma);
 	if (err) {
 		up_write(&mm->mmap_sem);
 		goto err;
@@ -621,6 +625,11 @@ int setup_arg_pages(struct linux_binprm 
 #else
 	stack_top = arch_align_stack(stack_top);
 	stack_top = PAGE_ALIGN(stack_top);
+
+	if (unlikely(stack_top < mmap_min_addr) ||
+	    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))
+		return -ENOMEM;
+
 	stack_shift = vma->vm_end - stack_top;
 
 	bprm->p -= stack_shift;
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/fs/ext4/ext4.h linux-2.6.18-194.26.1.el5.028stab079.1-owl/fs/ext4/ext4.h
--- linux-2.6.18-194.26.1.el5.028stab079.1/fs/ext4/ext4.h	2010-11-30 12:26:49 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/fs/ext4/ext4.h	2010-12-08 05:53:59 +0000
@@ -904,7 +904,7 @@ struct ext4_sb_info {
 	struct percpu_counter s_freeinodes_counter;
 	struct percpu_counter s_dirs_counter;
 	struct percpu_counter s_dirtyblocks_counter;
-	struct blockgroup_lock s_blockgroup_lock;
+	struct blockgroup_lock *s_blockgroup_lock;
 	struct proc_dir_entry *s_proc;
 	struct kobject s_kobj;
 	struct completion s_kobj_unregister;
@@ -1650,7 +1650,7 @@ bgl_lock_ptr(struct blockgroup_lock *bgl
 static inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,
 					      ext4_group_t group)
 {
-	return bgl_lock_ptr(&EXT4_SB(sb)->s_blockgroup_lock, group);
+	return bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);
 }
 
 /*
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/fs/ext4/super.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/fs/ext4/super.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/fs/ext4/super.c	2010-11-30 12:26:54 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/fs/ext4/super.c	2010-12-08 05:53:59 +0000
@@ -669,6 +669,7 @@ static void ext4_put_super(struct super_
 	wait_for_completion(&sbi->s_kobj_unregister);
 	lock_super(sb);
 	lock_kernel();
+	kfree(sbi->s_blockgroup_lock);
 	kfree(sbi);
 }
 
@@ -2354,6 +2355,13 @@ static int ext4_fill_super(struct super_
 	sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);
 	if (!sbi)
 		return -ENOMEM;
+
+	sbi->s_blockgroup_lock =
+		kzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);
+	if (!sbi->s_blockgroup_lock) {
+		kfree(sbi);
+		return -ENOMEM;
+	}
 	sb->s_fs_info = sbi;
 	sbi->s_mount_opt = 0;
 	sbi->s_resuid = EXT4_DEF_RESUID;
@@ -2660,7 +2668,7 @@ static int ext4_fill_super(struct super_
 		sbi->s_proc = proc_mkdir(sb->s_id, ext4_proc_root);
 #endif
 
-	bgl_lock_init(&sbi->s_blockgroup_lock);
+	bgl_lock_init(sbi->s_blockgroup_lock);
 
 	for (i = 0; i < db_count; i++) {
 		block = descriptor_loc(sb, logical_sb_block, i);
@@ -2976,7 +2984,7 @@ failed_mount:
 	brelse(bh);
 out_fail:
 	sb->s_fs_info = NULL;
-	kfree(&sbi->s_blockgroup_lock);
+	kfree(sbi->s_blockgroup_lock);
 	kfree(sbi);
 	lock_kernel();
 	return ret;
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/fs/proc/base.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/fs/proc/base.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/fs/proc/base.c	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/fs/proc/base.c	2010-12-08 03:31:52 +0000
@@ -260,10 +260,10 @@ static struct pid_entry tgid_base_stuff[
 	  S_IFREG|S_IRUGO|S_IWUSR),
 #endif
 #ifdef CONFIG_TASK_IO_ACCOUNTING
-	E(PROC_TGID_IO,             "io",  S_IFREG|S_IRUGO),
+	E(PROC_TGID_IO,             "io",  S_IFREG|S_IRUSR),
 #endif
 #ifdef CONFIG_STACKTRACE_PROC
-	E(PROC_TGID_STACK,     "stack",   S_IFREG|S_IRUGO),
+	E(PROC_TGID_STACK,     "stack",   S_IFREG|S_IRUSR),
 #endif
 
 	{0,0,NULL,0}
@@ -310,10 +310,10 @@ static struct pid_entry tid_base_stuff[]
 #endif
 	E(PROC_TID_LIMITS, "limits", S_IFREG|S_IRUSR),
 #ifdef CONFIG_TASK_IO_ACCOUNTING
-	E(PROC_TID_IO,         "io",      S_IFREG|S_IRUGO),
+	E(PROC_TID_IO,         "io",      S_IFREG|S_IRUSR),
 #endif
 #ifdef CONFIG_STACKTRACE_PROC
-	E(PROC_TID_STACK,      "stack",   S_IFREG|S_IRUGO),
+	E(PROC_TID_STACK,      "stack",   S_IFREG|S_IRUSR),
 #endif
 
 	{0,0,NULL,0}
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/include/linux/binfmts.h linux-2.6.18-194.26.1.el5.028stab079.1-owl/include/linux/binfmts.h
--- linux-2.6.18-194.26.1.el5.028stab079.1/include/linux/binfmts.h	2010-11-30 12:26:48 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/include/linux/binfmts.h	2010-12-08 03:31:52 +0000
@@ -13,7 +13,8 @@ struct pt_regs;
  */
 #define MAX_ARG_PAGES 32
 #define MAX_ARG_STRLEN (PAGE_SIZE * 32)
-#define MAX_ARG_STRINGS 0x7FFFFFFF
+#define MAX_ARG_STACK (0xC0000000UL / 4)
+#define MAX_ARG_STRINGS (MAX_ARG_STACK / 5)
 
 /* sizeof(linux_binprm->buf) */
 #define BINPRM_BUF_SIZE 128
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/include/linux/compat.h linux-2.6.18-194.26.1.el5.028stab079.1-owl/include/linux/compat.h
--- linux-2.6.18-194.26.1.el5.028stab079.1/include/linux/compat.h	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/include/linux/compat.h	2010-12-08 03:36:43 +0000
@@ -263,5 +263,6 @@ asmlinkage long compat_sys_epoll_pwait(i
 asmlinkage long compat_sys_signalfd(int ufd,
 				const compat_sigset_t __user *sigmask,
 				compat_size_t sigsetsize);
+
 #endif /* CONFIG_COMPAT */
 #endif /* _LINUX_COMPAT_H */
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/include/linux/dmar.h linux-2.6.18-194.26.1.el5.028stab079.1-owl/include/linux/dmar.h
--- linux-2.6.18-194.26.1.el5.028stab079.1/include/linux/dmar.h	2010-11-30 12:26:43 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/include/linux/dmar.h	2010-12-08 03:31:52 +0000
@@ -125,10 +125,6 @@ extern int irq_remapped(int irq);
 extern struct intel_iommu *map_dev_to_ir(struct pci_dev *dev);
 extern struct intel_iommu *map_ioapic_to_ir(int apic);
 #else
-static inline int enable_drhd_fault_handling(void)
-{
-	return -1;
-}
 static inline int alloc_irte(struct intel_iommu *iommu, int irq, u16 count)
 {
 	return -1;
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/include/linux/kernel.h linux-2.6.18-194.26.1.el5.028stab079.1-owl/include/linux/kernel.h
--- linux-2.6.18-194.26.1.el5.028stab079.1/include/linux/kernel.h	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/include/linux/kernel.h	2010-12-08 05:54:43 +0000
@@ -184,6 +184,7 @@ asmlinkage int ve_printk(int, const char
 	__attribute__ ((format (printf, 2, 3)));
 void prepare_printk(void);
 extern void log_buf_kexec_setup(void);
+extern int dmesg_restrict;
 #else
 static inline int vprintk(const char *s, va_list args)
 	__attribute__ ((format (printf, 1, 0)));
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/include/linux/sysctl.h linux-2.6.18-194.26.1.el5.028stab079.1-owl/include/linux/sysctl.h
--- linux-2.6.18-194.26.1.el5.028stab079.1/include/linux/sysctl.h	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/include/linux/sysctl.h	2010-12-08 05:54:43 +0000
@@ -47,6 +47,7 @@ struct __sysctl_args {
 /* For internal pattern-matching use only: */
 #ifdef __KERNEL__
 #define CTL_ANY		-1	/* Matches any name */
+#define CTL_UNNUMBERED	-2
 #define CTL_NONE	0
 #endif
 
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/init/do_mounts.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/init/do_mounts.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/init/do_mounts.c	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/init/do_mounts.c	2010-08-29 20:46:04 +0000
@@ -13,6 +13,10 @@
 #include <linux/nfs_fs_sb.h>
 #include <linux/nfs_mount.h>
 
+#ifdef CONFIG_BLK_DEV_IDECD
+#include <linux/ide.h>
+#endif
+
 #include "do_mounts.h"
 
 extern int get_filesystem_list(char * buf);
@@ -267,10 +271,63 @@ static void __init get_fs_names(char *pa
 
 static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 {
-	int err = sys_mount(name, "/root", fs, flags, data);
+	int err = -ENODEV;
+
+	if (!strcmp(saved_root_name, "/dev/cdrom")) {
+		char realname[10];
+#ifdef CONFIG_BLK_DEV_IDECD
+		int h, unit;
+		for (h = 0; h < MAX_HWIFS; h++) {
+			ide_hwif_t *hwif = &ide_hwifs[h];
+			if (!hwif->present)
+				continue;
+			for (unit = 0; unit < MAX_DRIVES; unit++) {
+				ide_drive_t *drive = &hwif->drives[unit];
+				if (!drive->present ||
+				    drive->media != ide_cdrom)
+					continue;
+				snprintf(realname, sizeof(realname),
+				    "/dev/%s", drive->name);
+				printk(KERN_INFO "Trying to mount %s...\n",
+				    realname);
+				create_dev(name,
+				    MKDEV(hwif->major, unit << PARTN_BITS));
+				err = sys_mount(name, "/root", fs, flags, data);
+				if (!err)
+					goto ok;
+			}
+		}
+#endif
+#ifdef CONFIG_BLK_DEV_SR
+		strcpy(realname, "/dev/scd0");
+		while (realname[8] < '8') {
+			int retries = root_delay;
+retry:
+			printk(KERN_INFO "Trying to mount %s...\n", realname);
+			if (retries == root_delay)
+				create_dev(name,
+				    MKDEV(SCSI_CDROM_MAJOR, realname[8] - '0'));
+			err = sys_mount(name, "/root", fs, flags, data);
+			if (!err)
+				goto ok;
+			if (err == -ENXIO || err == -ENODEV) {
+				if (retries-- <= 0)
+					return err;
+				printk(KERN_INFO "Retrying in 1 sec...\n");
+				ssleep(1);
+				goto retry;
+			}
+			realname[8]++;
+		}
+#endif
+		return err;
+	}
+
+	err = sys_mount(name, "/root", fs, flags, data);
 	if (err)
 		return err;
 
+ok:
 	sys_chdir("/root");
 	ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
 	printk("VFS: Mounted root (%s filesystem)%s.\n",
@@ -397,7 +454,7 @@ void __init prepare_namespace(void)
 {
 	int is_floppy;
 
-	if (root_delay) {
+	if (root_delay && strcmp(saved_root_name, "/dev/cdrom")) {
 		printk(KERN_INFO "Waiting %dsec before mounting root device...\n",
 		       root_delay);
 		ssleep(root_delay);
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/init/do_mounts_md.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/init/do_mounts_md.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/init/do_mounts_md.c	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/init/do_mounts_md.c	2007-10-03 03:57:50 +0000
@@ -122,6 +122,7 @@ static void __init md_setup_drive(void)
 
 	for (ent = 0; ent < md_setup_ents ; ent++) {
 		int fd;
+		int disknum = 0;
 		int err = 0;
 		char *devname;
 		mdu_disk_info_t dinfo;
@@ -144,7 +145,7 @@ static void __init md_setup_drive(void)
 
 			p = strchr(devname, ',');
 			if (p)
-				*p++ = 0;
+				*p = 0;
 
 			dev = name_to_dev_t(devname);
 			if (strncmp(devname, "/dev/", 5) == 0)
@@ -154,17 +155,22 @@ static void __init md_setup_drive(void)
 			if (rdev)
 				dev = new_decode_dev(rdev);
 			if (!dev) {
-				printk(KERN_WARNING "md: Unknown device name: %s\n", devname);
-				break;
+				printk(KERN_WARNING "md: Skipping unknown device name: %s\n", devname);
+				if (p)
+					*p++ = ',';
+				devname = p;
+				continue;
 			}
 
-			devices[i] = dev;
+			devices[disknum++] = dev;
 
+			if (p)
+				*p++ = ',';
 			devname = p;
 		}
-		devices[i] = 0;
+		devices[disknum] = 0;
 
-		if (!i)
+		if (!disknum)
 			continue;
 
 		printk(KERN_INFO "md: Loading md%s%d: %s\n",
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/ipc/compat.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/ipc/compat.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/ipc/compat.c	2010-11-30 12:25:51 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/ipc/compat.c	2010-12-08 06:11:38 +0000
@@ -242,6 +242,8 @@ long compat_sys_semctl(int first, int se
 	struct semid64_ds __user *up64;
 	int version = compat_ipc_parse_version(&third);
 
+	memset(&s64, 0, sizeof(s64));
+
 	if (!uptr)
 		return -EINVAL;
 	if (get_user(pad, (u32 __user *) uptr))
@@ -422,6 +424,8 @@ long compat_sys_msgctl(int first, int se
 	int version = compat_ipc_parse_version(&second);
 	void __user *p;
 
+	memset(&m64, 0, sizeof(m64));
+
 	switch (second & (~IPC_64)) {
 	case IPC_INFO:
 	case IPC_RMID:
@@ -595,6 +599,8 @@ long compat_sys_shmctl(int first, int se
 	int err, err2;
 	int version = compat_ipc_parse_version(&second);
 
+	memset(&s64, 0, sizeof(s64));
+
 	switch (second & (~IPC_64)) {
 	case IPC_RMID:
 	case SHM_LOCK:
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/ipc/compat_mq.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/ipc/compat_mq.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/ipc/compat_mq.c	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/ipc/compat_mq.c	2010-12-08 06:11:38 +0000
@@ -53,6 +53,9 @@ asmlinkage long compat_sys_mq_open(const
 	void __user *p = NULL;
 	if (u_attr && oflag & O_CREAT) {
 		struct mq_attr attr;
+
+		memset(&attr, 0, sizeof(attr));
+
 		p = compat_alloc_user_space(sizeof(attr));
 		if (get_compat_mq_attr(&attr, u_attr) ||
 		    copy_to_user(p, &attr, sizeof(attr)))
@@ -127,6 +130,8 @@ asmlinkage long compat_sys_mq_getsetattr
 	struct mq_attr __user *p = compat_alloc_user_space(2 * sizeof(*p));
 	long ret;
 
+	memset(&mqstat, 0, sizeof(mqstat));
+
 	if (u_mqstat) {
 		if (get_compat_mq_attr(&mqstat, u_mqstat) ||
 		    copy_to_user(p, &mqstat, sizeof(mqstat)))
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/ipc/sem.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/ipc/sem.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/ipc/sem.c	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/ipc/sem.c	2010-12-08 06:11:48 +0000
@@ -541,6 +541,8 @@ static unsigned long copy_semid_to_user(
 	    {
 		struct semid_ds out;
 
+		memset(&out, 0, sizeof(out));
+
 		ipc64_perm_to_ipc_perm(&in->sem_perm, &out.sem_perm);
 
 		out.sem_otime	= in->sem_otime;
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/ipc/shm.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/ipc/shm.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/ipc/shm.c	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/ipc/shm.c	2010-12-08 06:11:42 +0000
@@ -456,6 +456,7 @@ static inline unsigned long copy_shmid_t
 	    {
 		struct shmid_ds out;
 
+		memset(&out, 0, sizeof(out));
 		ipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);
 		out.shm_segsz	= in->shm_segsz;
 		out.shm_atime	= in->shm_atime;
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/kernel/exit.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/kernel/exit.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/kernel/exit.c	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/kernel/exit.c	2010-12-09 09:49:18 +0000
@@ -949,12 +949,28 @@ fastcall NORET_TYPE void do_exit(long co
 	int group_dead;
 	unsigned int mycpu;
 
+	/*
+	 * Check this first since set_fs() below depends on
+	 * current_thread_info(), which we better not access when we're in
+	 * interrupt context.  Other than that, we want to do the set_fs()
+	 * as early as possible.
+	 */
+	if (unlikely(in_interrupt()))
+		panic("Aiee, killing interrupt handler!");
+
+	/*
+	 * If do_exit is called because this process Oops'ed, it's possible
+	 * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before
+	 * continuing. Amongst other possible reasons, this is to prevent
+	 * mm_release()->clear_child_tid() from writing to a user-controlled
+	 * kernel address.
+	 */
+	set_fs(USER_DS);
+
 	profile_task_exit(tsk);
 
 	WARN_ON(atomic_read(&tsk->fs_excl));
 
-	if (unlikely(in_interrupt()))
-		panic("Aiee, killing interrupt handler!");
 	if (unlikely(!tsk->pid))
 		panic("Attempted to kill the idle task!");
 #ifdef CONFIG_VE
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/kernel/kallsyms.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/kernel/kallsyms.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/kernel/kallsyms.c	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/kernel/kallsyms.c	2010-12-08 03:31:52 +0000
@@ -421,7 +421,7 @@ static int __init kallsyms_init(void)
 {
 	struct proc_dir_entry *entry;
 
-	entry = create_proc_entry("kallsyms", 0444, NULL);
+	entry = create_proc_entry("kallsyms", 0400, NULL);
 	if (entry)
 		entry->proc_fops = &kallsyms_operations;
 	return 0;
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/kernel/panic.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/kernel/panic.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/kernel/panic.c	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/kernel/panic.c	2010-12-08 03:31:52 +0000
@@ -20,7 +20,7 @@
 #include <linux/kexec.h>
 #include <linux/debug_locks.h>
 
-int panic_on_oops = 1;
+int panic_on_oops;
 int tainted = 1;
 static int pause_on_oops;
 static int pause_on_oops_flag;
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/kernel/printk.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/kernel/printk.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/kernel/printk.c	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/kernel/printk.c	2010-12-08 05:54:43 +0000
@@ -224,6 +224,12 @@ static void boot_delay_msec(int millisec
 
 #endif
 
+#ifdef CONFIG_SECURITY_DMESG_RESTRICT
+int dmesg_restrict = 1;
+#else
+int dmesg_restrict;
+#endif
+
 /*
  * Commands to do_syslog:
  *
@@ -249,10 +255,6 @@ int do_syslog(int type, char __user *buf
 	if (!ve_is_super(get_exec_env()) && (type == 6 || type == 7))
 		goto out;
 
-	error = security_syslog(type);
-	if (error)
-		return error;
-
 	switch (type) {
 	case 0:		/* Close log */
 		break;
@@ -384,6 +386,12 @@ out:
 
 asmlinkage long sys_syslog(int type, char __user *buf, int len)
 {
+	int error = 0;
+
+	error = security_syslog(type);
+	if (error)
+		return error;
+		
 	return do_syslog(type, buf, len);
 }
 
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/kernel/sysctl.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/kernel/sysctl.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/kernel/sysctl.c	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/kernel/sysctl.c	2010-12-08 05:54:43 +0000
@@ -919,6 +919,16 @@ static ctl_table kern_table[] = {
 		.proc_handler	= &proc_dointvec,
 	},
 	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname       = "dmesg_restrict",
+		.data           = &dmesg_restrict,
+		.maxlen         = sizeof(int),
+		.mode           = 0644,
+		.proc_handler   = &proc_dointvec_minmax,
+		.extra1         = &zero,
+		.extra2         = &one,
+	},
+	{
 		.ctl_name	= KERN_NGROUPS_MAX,
 		.procname	= "ngroups_max",
 		.data		= &ngroups_max,
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/mm/mmap.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/mm/mmap.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/mm/mmap.c	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/mm/mmap.c	2010-12-09 16:53:29 +0000
@@ -2398,6 +2398,11 @@ int install_special_mapping(struct mm_st
 	vma->vm_ops = &special_mapping_vmops;
 	vma->vm_private_data = pages;
 
+	if (unlikely(security_file_mmap_addr(NULL, 0, 0, 0, vma->vm_start, 1))) {
+		kmem_cache_free(vm_area_cachep, vma);
+		return -EPERM;
+	}
+
 	if (unlikely(insert_vm_struct(mm, vma))) {
 		kmem_cache_free(vm_area_cachep, vma);
 		return -ENOMEM;
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/net/core/filter.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/net/core/filter.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/net/core/filter.c	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/net/core/filter.c	2010-12-08 06:12:08 +0000
@@ -77,39 +77,41 @@ static inline void *load_pointer(struct 
  */
 unsigned int sk_run_filter(struct sk_buff *skb, struct sock_filter *filter, int flen)
 {
-	struct sock_filter *fentry;	/* We walk down these */
 	void *ptr;
 	u32 A = 0;			/* Accumulator */
 	u32 X = 0;			/* Index Register */
 	u32 mem[BPF_MEMWORDS];		/* Scratch Memory Store */
+	unsigned long memvalid = 0;
 	u32 tmp;
 	int k;
 	int pc;
 
+	BUILD_BUG_ON(BPF_MEMWORDS > BITS_PER_LONG);
 	/*
 	 * Process array of filter instructions.
 	 */
 	for (pc = 0; pc < flen; pc++) {
-		fentry = &filter[pc];
-			
+		const struct sock_filter *fentry = &filter[pc];
+		u32 f_k = fentry->k;
+
 		switch (fentry->code) {
 		case BPF_ALU|BPF_ADD|BPF_X:
 			A += X;
 			continue;
 		case BPF_ALU|BPF_ADD|BPF_K:
-			A += fentry->k;
+			A += f_k;
 			continue;
 		case BPF_ALU|BPF_SUB|BPF_X:
 			A -= X;
 			continue;
 		case BPF_ALU|BPF_SUB|BPF_K:
-			A -= fentry->k;
+			A -= f_k;
 			continue;
 		case BPF_ALU|BPF_MUL|BPF_X:
 			A *= X;
 			continue;
 		case BPF_ALU|BPF_MUL|BPF_K:
-			A *= fentry->k;
+			A *= f_k;
 			continue;
 		case BPF_ALU|BPF_DIV|BPF_X:
 			if (X == 0)
@@ -117,49 +119,49 @@ unsigned int sk_run_filter(struct sk_buf
 			A /= X;
 			continue;
 		case BPF_ALU|BPF_DIV|BPF_K:
-			A /= fentry->k;
+			A /= f_k;
 			continue;
 		case BPF_ALU|BPF_AND|BPF_X:
 			A &= X;
 			continue;
 		case BPF_ALU|BPF_AND|BPF_K:
-			A &= fentry->k;
+			A &= f_k;
 			continue;
 		case BPF_ALU|BPF_OR|BPF_X:
 			A |= X;
 			continue;
 		case BPF_ALU|BPF_OR|BPF_K:
-			A |= fentry->k;
+			A |= f_k;
 			continue;
 		case BPF_ALU|BPF_LSH|BPF_X:
 			A <<= X;
 			continue;
 		case BPF_ALU|BPF_LSH|BPF_K:
-			A <<= fentry->k;
+			A <<= f_k;
 			continue;
 		case BPF_ALU|BPF_RSH|BPF_X:
 			A >>= X;
 			continue;
 		case BPF_ALU|BPF_RSH|BPF_K:
-			A >>= fentry->k;
+			A >>= f_k;
 			continue;
 		case BPF_ALU|BPF_NEG:
 			A = -A;
 			continue;
 		case BPF_JMP|BPF_JA:
-			pc += fentry->k;
+			pc += f_k;
 			continue;
 		case BPF_JMP|BPF_JGT|BPF_K:
-			pc += (A > fentry->k) ? fentry->jt : fentry->jf;
+			pc += (A > f_k) ? fentry->jt : fentry->jf;
 			continue;
 		case BPF_JMP|BPF_JGE|BPF_K:
-			pc += (A >= fentry->k) ? fentry->jt : fentry->jf;
+			pc += (A >= f_k) ? fentry->jt : fentry->jf;
 			continue;
 		case BPF_JMP|BPF_JEQ|BPF_K:
-			pc += (A == fentry->k) ? fentry->jt : fentry->jf;
+			pc += (A == f_k) ? fentry->jt : fentry->jf;
 			continue;
 		case BPF_JMP|BPF_JSET|BPF_K:
-			pc += (A & fentry->k) ? fentry->jt : fentry->jf;
+			pc += (A & f_k) ? fentry->jt : fentry->jf;
 			continue;
 		case BPF_JMP|BPF_JGT|BPF_X:
 			pc += (A > X) ? fentry->jt : fentry->jf;
@@ -174,7 +176,7 @@ unsigned int sk_run_filter(struct sk_buf
 			pc += (A & X) ? fentry->jt : fentry->jf;
 			continue;
 		case BPF_LD|BPF_W|BPF_ABS:
-			k = fentry->k;
+			k = f_k;
 load_w:
 			ptr = load_pointer(skb, k, 4, &tmp);
 			if (ptr != NULL) {
@@ -183,7 +185,7 @@ load_w:
 			}
 			break;
 		case BPF_LD|BPF_H|BPF_ABS:
-			k = fentry->k;
+			k = f_k;
 load_h:
 			ptr = load_pointer(skb, k, 2, &tmp);
 			if (ptr != NULL) {
@@ -192,7 +194,7 @@ load_h:
 			}
 			break;
 		case BPF_LD|BPF_B|BPF_ABS:
-			k = fentry->k;
+			k = f_k;
 load_b:
 			ptr = load_pointer(skb, k, 1, &tmp);
 			if (ptr != NULL) {
@@ -207,32 +209,34 @@ load_b:
 			X = skb->len;
 			continue;
 		case BPF_LD|BPF_W|BPF_IND:
-			k = X + fentry->k;
+			k = X + f_k;
 			goto load_w;
 		case BPF_LD|BPF_H|BPF_IND:
-			k = X + fentry->k;
+			k = X + f_k;
 			goto load_h;
 		case BPF_LD|BPF_B|BPF_IND:
-			k = X + fentry->k;
+			k = X + f_k;
 			goto load_b;
 		case BPF_LDX|BPF_B|BPF_MSH:
-			ptr = load_pointer(skb, fentry->k, 1, &tmp);
+			ptr = load_pointer(skb, f_k, 1, &tmp);
 			if (ptr != NULL) {
 				X = (*(u8 *)ptr & 0xf) << 2;
 				continue;
 			}
 			return 0;
 		case BPF_LD|BPF_IMM:
-			A = fentry->k;
+			A = f_k;
 			continue;
 		case BPF_LDX|BPF_IMM:
-			X = fentry->k;
+			X = f_k;
 			continue;
 		case BPF_LD|BPF_MEM:
-			A = mem[fentry->k];
+			A = (memvalid & (1UL << f_k)) ?
+				mem[f_k] : 0;
 			continue;
 		case BPF_LDX|BPF_MEM:
-			X = mem[fentry->k];
+			X = (memvalid & (1UL << f_k)) ?
+				mem[f_k] : 0;
 			continue;
 		case BPF_MISC|BPF_TAX:
 			X = A;
@@ -241,14 +245,16 @@ load_b:
 			A = X;
 			continue;
 		case BPF_RET|BPF_K:
-			return fentry->k;
+			return f_k;
 		case BPF_RET|BPF_A:
 			return A;
 		case BPF_ST:
-			mem[fentry->k] = A;
+			memvalid |= 1UL << f_k;
+			mem[f_k] = A;
 			continue;
 		case BPF_STX:
-			mem[fentry->k] = X;
+			memvalid |= 1UL << f_k;
+			mem[f_k] = X;
 			continue;
 		default:
 			WARN_ON(1);
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/net/llc/af_llc.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/net/llc/af_llc.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/net/llc/af_llc.c	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/net/llc/af_llc.c	2009-08-26 10:16:29 +0000
@@ -155,6 +155,9 @@ static int llc_ui_create(struct socket *
 	struct sock *sk;
 	int rc = -ESOCKTNOSUPPORT;
 
+	if (!capable(CAP_NET_RAW))
+		return -EPERM;
+
 	if (likely(sock->type == SOCK_DGRAM || sock->type == SOCK_STREAM)) {
 		rc = -ENOMEM;
 		sk = llc_sk_alloc(PF_LLC, GFP_KERNEL, &llc_proto);
@@ -911,6 +914,7 @@ static int llc_ui_getname(struct socket 
 	struct llc_sock *llc = llc_sk(sk);
 	int rc = 0;
 
+	memset(&sllc, 0, sizeof(sllc));
 	lock_sock(sk);
 	if (sock_flag(sk, SOCK_ZAPPED))
 		goto out;
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/scripts/mkcompile_h linux-2.6.18-194.26.1.el5.028stab079.1-owl/scripts/mkcompile_h
--- linux-2.6.18-194.26.1.el5.028stab079.1/scripts/mkcompile_h	2006-09-20 03:42:06 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/scripts/mkcompile_h	2009-03-01 05:35:12 +0000
@@ -47,17 +47,9 @@ UTS_TRUNCATE="sed -e s/\(.\{1,$UTS_LEN\}
   echo \#define UTS_VERSION \"`echo $UTS_VERSION | $UTS_TRUNCATE`\"
 
   echo \#define LINUX_COMPILE_TIME \"`LC_ALL=C LANG=C date +%T`\"
-  echo \#define LINUX_COMPILE_BY \"`whoami`\"
-  echo \#define LINUX_COMPILE_HOST \"`hostname | $UTS_TRUNCATE`\"
-
-  if [ -x /bin/dnsdomainname ]; then
-    echo \#define LINUX_COMPILE_DOMAIN \"`dnsdomainname | $UTS_TRUNCATE`\"
-  elif [ -x /bin/domainname ]; then
-    echo \#define LINUX_COMPILE_DOMAIN \"`domainname | $UTS_TRUNCATE`\"
-  else
-    echo \#define LINUX_COMPILE_DOMAIN
-  fi
-
+  echo \#define LINUX_COMPILE_BY \"sources\"
+  echo \#define LINUX_COMPILE_HOST \"${ARCH}.example.org\"
+  echo \#define LINUX_COMPILE_DOMAIN \"\"
   echo \#define LINUX_COMPILER \"`$CC -v 2>&1 | tail -n 1`\"
 ) > .tmpcompile
 
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/security/Kconfig linux-2.6.18-194.26.1.el5.028stab079.1-owl/security/Kconfig
--- linux-2.6.18-194.26.1.el5.028stab079.1/security/Kconfig	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/security/Kconfig	2010-12-08 05:54:43 +0000
@@ -41,6 +41,18 @@ config KEYS_DEBUG_PROC_KEYS
 
 	  If you are unsure as to whether this is required, answer N.
 
+config SECURITY_DMESG_RESTRICT
+	bool "Restrict unprivileged access to the kernel syslog"
+	default n
+	help
+	  This enforces restrictions on unprivileged users reading the kernel
+	  syslog via dmesg(8).
+
+	  If this option is not selected, no restrictions will be enforced
+	  unless the dmesg_restrict sysctl is explicitly set to (1).
+
+	  If you are unsure how to answer this question, answer N.
+
 config SECURITY
 	bool "Enable different security models"
 	depends on SYSFS && !VE
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/security/commoncap.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/security/commoncap.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/security/commoncap.c	2010-11-30 12:26:53 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/security/commoncap.c	2010-12-08 05:58:07 +0000
@@ -315,6 +315,9 @@ void cap_task_reparent_to_init (struct t
 
 int cap_syslog (int type)
 {
+	if (dmesg_restrict && !capable(CAP_VE_SYS_ADMIN))
+		return -EPERM;
+
 	if ((type != 3 && type != 10) && !capable(CAP_VE_SYS_ADMIN))
 		return -EPERM;
 	return 0;
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/sound/core/control.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/sound/core/control.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/sound/core/control.c	2010-11-30 12:26:38 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/sound/core/control.c	2010-12-08 06:14:00 +0000
@@ -33,6 +33,7 @@
 
 /* max number of user-defined controls */
 #define MAX_USER_CONTROLS	32
+#define MAX_CONTROL_COUNT	1028
 
 struct snd_kctl_ioctl {
 	struct list_head list;		/* list of all ioctls */
@@ -190,6 +191,10 @@ static struct snd_kcontrol *snd_ctl_new(
 	
 	snd_assert(control != NULL, return NULL);
 	snd_assert(control->count > 0, return NULL);
+
+	if (control->count > MAX_CONTROL_COUNT)
+		return NULL;
+
 	kctl = kzalloc(sizeof(*kctl) + sizeof(struct snd_kcontrol_volatile) * control->count, GFP_KERNEL);
 	if (kctl == NULL) {
 		snd_printk(KERN_ERR "Cannot allocate control instance\n");
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/sound/pci/rme9652/hdsp.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/sound/pci/rme9652/hdsp.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/sound/pci/rme9652/hdsp.c	2010-11-30 12:25:56 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/sound/pci/rme9652/hdsp.c	2010-12-08 06:14:04 +0000
@@ -4519,6 +4519,7 @@ static int snd_hdsp_hwdep_ioctl(struct s
 			snd_printk(KERN_ERR "Hammerfall-DSP: Firmware needs to be uploaded to the card.\n");	
 			return -EINVAL;
 		}
+		memset(&info, 0, sizeof(info));
 		spin_lock_irqsave(&hdsp->lock, flags);
 		info.pref_sync_ref = (unsigned char)hdsp_pref_sync_ref(hdsp);
 		info.wordclock_sync_check = (unsigned char)hdsp_wc_sync_check(hdsp);
diff -urp linux-2.6.18-194.26.1.el5.028stab079.1/sound/pci/rme9652/hdspm.c linux-2.6.18-194.26.1.el5.028stab079.1-owl/sound/pci/rme9652/hdspm.c
--- linux-2.6.18-194.26.1.el5.028stab079.1/sound/pci/rme9652/hdspm.c	2010-11-30 12:25:56 +0000
+++ linux-2.6.18-194.26.1.el5.028stab079.1-owl/sound/pci/rme9652/hdspm.c	2010-12-08 06:14:04 +0000
@@ -4082,6 +4082,7 @@ static int snd_hdspm_hwdep_ioctl(struct 
 
 	case SNDRV_HDSPM_IOCTL_GET_CONFIG_INFO:
 
+		memset(&info, 0, sizeof(info));
 		spin_lock_irq(&hdspm->lock);
 		info.pref_sync_ref =
 		    (unsigned char) hdspm_pref_sync_ref(hdspm);

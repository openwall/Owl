diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/Makefile.am gettext.hacked/Makefile.am
--- gettext.initial/Makefile.am	Mon Feb 22 13:40:47 1999
+++ gettext.hacked/Makefile.am	Mon Feb 22 14:10:19 1999
@@ -19,7 +19,7 @@
 
 AUTOMAKE_OPTIONS = 1.3 gnits
 MAINT_CHARSET = latin1
-ACLOCAL_AMFLAGS = -I m4
+ACLOCAL_AMFLAGS = --acdir=m4 --acdir=$(shell aclocal --print-ac-dir)
 
 gettextsrcdir = $(datadir)/gettext
 gettextsrc_DATA = ABOUT-NLS
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/configure.in gettext.hacked/configure.in
--- gettext.initial/configure.in	Mon Feb 22 13:40:47 1999
+++ gettext.hacked/configure.in	Mon Feb 22 14:10:20 1999
@@ -12,7 +12,7 @@
 AM_PROG_LIBTOOL
 AC_PROG_CC
 AC_ISC_POSIX
-AM_PROG_INSTALL
+AC_PROG_INSTALL
 AC_PROG_YACC
 
 dnl Checks for libraries.
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/doc/gettext.info gettext.hacked/doc/gettext.info
--- gettext.initial/doc/gettext.info	Mon Feb 22 13:40:47 1999
+++ gettext.hacked/doc/gettext.info	Mon Apr 19 18:54:47 1999
@@ -1,5 +1,5 @@
-This is Info file gettext.info, produced by Makeinfo version 1.68 from
-the input file gettext.texi.
+This is gettext.info, produced by Makeinfo version 3.12f from
+gettext.texi.
 
 INFO-DIR-SECTION GNU Gettext Utilities
 START-INFO-DIR-ENTRY
@@ -31,95 +31,95 @@
 
 
 Indirect:
-gettext.info-1: 1425
-gettext.info-2: 48171
-gettext.info-3: 95467
-gettext.info-4: 143902
-gettext.info-5: 193500
+gettext.info-1: 1401
+gettext.info-2: 48150
+gettext.info-3: 95446
+gettext.info-4: 143882
+gettext.info-5: 193483
 
 Tag Table:
 (Indirect)
-Node: Top1425
-Node: Introduction6602
-Node: Why8466
-Node: Concepts11521
-Node: Aspects14934
-Node: Files20982
-Node: Overview23250
-Node: Basics33886
-Node: Installation34716
-Node: PO Files36454
-Node: Main PO Commands43213
-Node: Entry Positioning48171
-Node: Normalizing53435
-Node: Sources57891
-Node: Triggering59162
-Node: Mark Keywords61518
-Node: Marking65068
-Node: c-format72713
-Node: Special cases76460
-Node: Initial79323
-Node: xgettext Invocation79645
-Node: C Sources Context82872
-Node: Compendium87849
-Node: Updating88552
-Node: msgmerge Invocation89074
-Node: Translated Entries89248
-Node: Fuzzy Entries90540
-Node: Untranslated Entries93628
-Node: Obsolete Entries95467
-Node: Modifying Translations98595
-Node: Modifying Comments108783
-Node: Auxiliary113094
-Node: Binaries116175
-Node: msgfmt Invocation116439
-Node: MO Files119066
-Node: Users126478
-Node: Matrix127959
-Node: Installers129162
-Node: End Users130350
-Node: Programmers130979
-Node: catgets132153
-Node: Interface to catgets133558
-Node: Problems with catgets135559
-Node: gettext136457
-Node: Interface to gettext137694
-Node: Ambiguities140036
-Node: Locating Catalogs142593
-Node: Optimized gettext143902
-Node: Comparison147490
-Node: Using libintl.a153203
-Node: gettext grok153974
-Node: Temp Programmers156833
-Node: Temp Implementations157273
-Node: Temp catgets158639
-Node: Temp WSI160326
-Node: Temp Notes162314
-Node: Translators162803
-Node: Trans Intro 0163182
-Node: Trans Intro 1165821
-Node: Discussions167666
-Node: Organization170821
-Node: Central Coordination172802
-Node: National Teams173930
-Node: Sub-Cultures176442
-Node: Organizational Ideas177361
-Node: Mailing Lists178363
-Node: Information Flow180166
-Node: Maintainers182299
-Node: Flat and Non-Flat184059
-Node: Prerequisites185820
-Node: gettextize Invocation189928
-Node: Adjusting Files193500
-Node: po/POTFILES.in194723
-Node: configure.in195664
-Node: aclocal197791
-Node: acconfig198970
-Node: Makefile199584
-Node: src/Makefile201772
-Node: Conclusion204169
-Node: History204658
-Node: References208118
-Node: Country Codes209673
+Node: Top1401
+Node: Introduction6580
+Node: Why8444
+Node: Concepts11499
+Node: Aspects14912
+Node: Files20961
+Node: Overview23229
+Node: Basics33865
+Node: Installation34695
+Node: PO Files36433
+Node: Main PO Commands43192
+Node: Entry Positioning48150
+Node: Normalizing53413
+Node: Sources57869
+Node: Triggering59140
+Node: Mark Keywords61496
+Node: Marking65046
+Node: c-format72691
+Node: Special cases76439
+Node: Initial79302
+Node: xgettext Invocation79624
+Node: C Sources Context82851
+Node: Compendium87828
+Node: Updating88531
+Node: msgmerge Invocation89053
+Node: Translated Entries89227
+Node: Fuzzy Entries90519
+Node: Untranslated Entries93607
+Node: Obsolete Entries95446
+Node: Modifying Translations98574
+Node: Modifying Comments108762
+Node: Auxiliary113073
+Node: Binaries116154
+Node: msgfmt Invocation116418
+Node: MO Files119045
+Node: Users126457
+Node: Matrix127938
+Node: Installers129141
+Node: End Users130329
+Node: Programmers130958
+Node: catgets132132
+Node: Interface to catgets133537
+Node: Problems with catgets135538
+Node: gettext136436
+Node: Interface to gettext137674
+Node: Ambiguities140016
+Node: Locating Catalogs142573
+Node: Optimized gettext143882
+Node: Comparison147470
+Node: Using libintl.a153182
+Node: gettext grok153953
+Node: Temp Programmers156813
+Node: Temp Implementations157253
+Node: Temp catgets158619
+Node: Temp WSI160306
+Node: Temp Notes162294
+Node: Translators162783
+Node: Trans Intro 0163162
+Node: Trans Intro 1165801
+Node: Discussions167646
+Node: Organization170802
+Node: Central Coordination172783
+Node: National Teams173911
+Node: Sub-Cultures176423
+Node: Organizational Ideas177342
+Node: Mailing Lists178345
+Node: Information Flow180148
+Node: Maintainers182281
+Node: Flat and Non-Flat184041
+Node: Prerequisites185802
+Node: gettextize Invocation189911
+Node: Adjusting Files193483
+Node: po/POTFILES.in194706
+Node: configure.in195647
+Node: aclocal197774
+Node: acconfig198953
+Node: Makefile199567
+Node: src/Makefile201755
+Node: Conclusion204152
+Node: History204641
+Node: References208101
+Node: Country Codes209656
 
 End Tag Table
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/doc/gettext.info-1 gettext.hacked/doc/gettext.info-1
--- gettext.initial/doc/gettext.info-1	Mon Feb 22 13:40:47 1999
+++ gettext.hacked/doc/gettext.info-1	Mon Apr 19 18:54:47 1999
@@ -1,5 +1,5 @@
-This is Info file gettext.info, produced by Makeinfo version 1.68 from
-the input file gettext.texi.
+This is gettext.info, produced by Makeinfo version 3.12f from
+gettext.texi.
 
 INFO-DIR-SECTION GNU Gettext Utilities
 START-INFO-DIR-ENTRY
@@ -51,7 +51,7 @@
 
 * Country Codes::               ISO 639 country codes
 
- -- The Detailed Node Listing --
+ --- The Detailed Node Listing ---
 
 Introduction
 
@@ -179,16 +179,16 @@
 Introduction
 ************
 
-     This manual is still in *DRAFT* state.  Some sections are still
+     This manual is still in _DRAFT_ state.  Some sections are still
      empty, or almost.  We keep merging material from other sources
      (essentially e-mail folders) while the proper integration of this
      material is delayed.
 
-   In this manual, we use *he* when speaking of the programmer or
-maintainer, *she* when speaking of the translator, and *they* when
+   In this manual, we use _he_ when speaking of the programmer or
+maintainer, _she_ when speaking of the translator, and _they_ when
 speaking of the installers or end users of the translated program.
 This is only a convenience for clarifying the documentation.  It is
-*absolutely* not meant to imply that some roles are more appropriate to
+_absolutely_ not meant to imply that some roles are more appropriate to
 males or females.  Besides, as you might guess, GNU `gettext' is meant
 to be useful for people using computers, whatever their sex, race,
 religion or nationality!
@@ -231,7 +231,7 @@
 between developers, maintainers and users from all countries.  On the
 other hand, most people are less comfortable with English than with
 their own native language, and would prefer to use their mother tongue
-for day to day's work, as far as possible.  Many would simply *love* to
+for day to day's work, as far as possible.  Many would simply _love_ to
 see their computer screen showing a lot less of English, and far more
 of their own language.
 
@@ -272,7 +272,7 @@
 this supplemental documentation might also help programmers, and even
 curious users, in understanding how GNU `gettext' is related to the
 remainder of the Translation Project, and consequently, have a glimpse
-at the *big picture*.
+at the _big picture_.
 
 
 File: gettext.info,  Node: Concepts,  Next: Aspects,  Prev: Why,  Up: Introduction
@@ -283,7 +283,7 @@
    Two long words appear all the time when we discuss support of native
 language in programs, and these words have a precise meaning, worth
 being explained here, once and for all in this document.  The words are
-*internationalization* and *localization*.  Many people, tired of
+_internationalization_ and _localization_.  Many people, tired of
 writing these long words over and over again, took the habit of writing
 "i18n" and "l10n" instead, quoting the first and last letter of each
 word, and replacing the run of intermediate letters by a number merely
@@ -387,6 +387,7 @@
      Translating a manual, with the intent of later keeping up with
      updates, is a major undertaking in itself, generally.
 
+
    As we already stressed, translation is only one aspect of locales.
 Other internationalization aspects are not currently handled by GNU
 `gettext', but perhaps may be handled in future versions.  There are
@@ -403,7 +404,7 @@
 related to locales, and also presents some other areas which GNU
 `gettext' might eventually tackle, maybe, one of these days.
 
-*Characters and Codesets*
+_Characters and Codesets_
      The codeset most commonly used through out the USA and most English
      speaking parts of the world is the ASCII codeset.  However, there
      are many characters needed by various locales that are not found
@@ -414,12 +415,12 @@
      they need to use and will need to have the appropriate character
      handling routines to cope with the codeset.
 
-*Currency*
+_Currency_
      The symbols used vary from country to country as does the position
      used by the symbol.  Software needs to be able to transparently
      display currency figures in the native mode for each locale.
 
-*Dates*
+_Dates_
      The format of date varies between locales.  For example, Christmas
      day in 1994 is written as 12/25/94 in the USA and as 25/12/94 in
      Australia.  Other countries might use ISO 8061 dates, etc.
@@ -429,7 +430,7 @@
      as AM or PM.  Further, the nature and yearly extent of the
      Daylight Saving correction vary widely between countries.
 
-*Numbers*
+_Numbers_
      Numbers can be represented differently in different locales.  For
      example, the following numbers are all written correctly for their
      respective locales:
@@ -442,7 +443,7 @@
      English units or Metric units, or even take into account variants
      about how numbers are spelled in full.
 
-*Messages*
+_Messages_
      The most obvious area is the language support within a locale.
      This is where GNU `gettext' provides the means for developers and
      users to easily change the language that the software uses to
@@ -576,7 +577,7 @@
 letter `t' in `.pot' marks this as a Template PO file, not yet oriented
 towards any particular language.  *Note xgettext Invocation::, for more
 details about how one calls the `xgettext' program.  If you are
-*really* lazy, you might be interested at working a lot more right
+_really_ lazy, you might be interested at working a lot more right
 away, and preparing the whole distribution setup (*note
 Maintainers::.).  By doing so, you spare yourself typing the `xgettext'
 command, as `make' should now generate the proper things automatically
@@ -734,7 +735,7 @@
    Later, whenever you edit some `.po', `.pot' or `.pox' file, or any
 file having the string `.po.' within its name, Emacs loads
 `po-mode.elc' (or `po-mode.el') as needed, and automatically activates
-PO mode commands for the associated buffer.  The string *PO* appears in
+PO mode commands for the associated buffer.  The string _PO_ appears in
 the mode line for any buffer for which PO mode is active.  Many PO
 files may be active at once in a single Emacs session.
 
@@ -864,11 +865,11 @@
 `Here' was promoted on the first line, right after `msgid'.(1) It was
 not really necessary either to switch between the two last quoted
 strings immediately after the newline `\n', the switch could have
-occurred after *any* other character, we just did it this way because
+occurred after _any_ other character, we just did it this way because
 it is neater.
 
    One should carefully distinguish between end of lines marked as `\n'
-*inside* quotes, which are part of the represented string, and end of
+_inside_ quotes, which are part of the represented string, and end of
 lines in the PO file itself, outside string quotes, which have no
 incidence on the represented string.
 
@@ -936,7 +937,7 @@
 `V'
      Batch validate the format of the whole PO file.
 
-   The command `U' (`po-undo') interfaces to the GNU Emacs *undo*
+   The command `U' (`po-undo') interfaces to the GNU Emacs _undo_
 facility.  *Note Undoing Changes: (emacs)Undo.  Each time `U' is typed,
 modifications which the translator did to the PO file are undone a
 little more.  For the purpose of undoing, each PO mode command is
@@ -962,7 +963,7 @@
 discover some apparent bug in the program source that needs correction.
 This command allows the translator to change sex, become a programmer,
 and have the cursor right into the window containing the program she
-(or rather *he*) wants to modify.  By later getting the cursor back in
+(or rather _he_) wants to modify.  By later getting the cursor back in
 the PO file window, or by asking Emacs to edit this file once again, PO
 mode is then recovered.
 
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/doc/gettext.info-2 gettext.hacked/doc/gettext.info-2
--- gettext.initial/doc/gettext.info-2	Mon Feb 22 13:40:47 1999
+++ gettext.hacked/doc/gettext.info-2	Mon Apr 19 18:54:47 1999
@@ -1,5 +1,5 @@
-This is Info file gettext.info, produced by Makeinfo version 1.68 from
-the input file gettext.texi.
+This is gettext.info, produced by Makeinfo version 3.12f from
+gettext.texi.
 
 INFO-DIR-SECTION GNU Gettext Utilities
 START-INFO-DIR-ENTRY
@@ -78,7 +78,7 @@
 characters, lines, paragraphs, screens or pages, and search commands.
 However, there is a kind of standard way to display the current entry
 in PO mode, which usual GNU Emacs commands moving the cursor do not
-especially try to enforce.  The command `.'  (`po-current-entry') has
+especially try to enforce.  The command `.' (`po-current-entry') has
 the sole purpose of redisplaying the current entry properly, after the
 current entry has been changed by means external to PO mode, or the
 Emacs screen otherwise altered.
@@ -94,7 +94,7 @@
 it, we should drop this whole idea.  The incentive for doing it should
 come from translators rather than programmers, as opinions from an
 experienced translator are surely more worth to me than opinions from
-programmers *thinking* about how *others* should do translation.
+programmers _thinking_ about how _others_ should do translation.
 
    The commands `n' (`po-next-entry') and `p' (`po-previous-entry')
 move the cursor the entry following, or preceding, the current one.  If
@@ -206,7 +206,7 @@
 files in nice ways.
 
    Right now, in PO mode, strings are single line or multi-line.  A
-string goes multi-line if and only if it has *embedded* newlines, that
+string goes multi-line if and only if it has _embedded_ newlines, that
 is, if it matches `[^\n]\n+[^\n]'.  So, we would have:
 
      msgstr "\n\nHello, world!\n\n\n"
@@ -365,7 +365,7 @@
    The canonical keyword for marking translatable strings is `gettext',
 it gave its name to the whole GNU `gettext' package.  For packages
 making only light use of the `gettext' keyword, macro or function, it
-is easily used *as is*.  However, for packages using the `gettext'
+is easily used _as is_.  However, for packages using the `gettext'
 interface more heavily, it is usually more convenient to give the main
 keyword a shorter, less obtrusive name.  Indeed, the keyword might
 appear on a lot of strings all over the package, and programmers
@@ -395,7 +395,7 @@
 you add or modify a string, you will have to ask yourself if the new or
 altered string requires translation, and include it within `_()' if you
 think it should be translated.  `"%s: %d"' is an example of string
-*not* requiring translation!
+_not_ requiring translation!
 
 
 File: gettext.info,  Node: Marking,  Next: c-format,  Prev: Mark Keywords,  Up: Sources
@@ -490,7 +490,7 @@
 tags commands.  For example, regular `tags-search' or
 `tags-query-replace' commands may be used without disrupting the
 independent `,' search sequence.  However, as implemented, the
-*initial* `,' command (or the `,' command is used with a prefix) might
+_initial_ `,' command (or the `,' command is used with a prefix) might
 also reinitialize the regular Emacs tags searching to the first tags
 file, this reinitialization might be considered spurious.
 
@@ -512,11 +512,11 @@
 
    The `M-.' command has a few built-in speedups, so you do not have to
 explicitly type all keywords all the time.  The first such speedup is
-that you are presented with a *preferred* keyword, which you may accept
+that you are presented with a _preferred_ keyword, which you may accept
 by merely typing `<RET>' at the prompt.  The second speedup is that you
 may type any non-ambiguous prefix of the keyword you really mean, and
 the command will complete it automatically for you.  This also means
-that PO mode has to *know* all your possible keywords, and that it will
+that PO mode has to _know_ all your possible keywords, and that it will
 not accept mistyped keywords.
 
    If you reply `?' to the keyword request, the command gives a list of
@@ -525,9 +525,9 @@
 source or PO file buffer, and does some simple keyword management
 instead.  In this case, the command asks for a keyword, written in
 full, which becomes a new allowed keyword for later `M-.' commands.
-Moreover, this new keyword automatically becomes the *preferred*
+Moreover, this new keyword automatically becomes the _preferred_
 keyword for later commands.  By typing an already known keyword in
-response to `C-u M-.', one merely changes the *preferred* keyword and
+response to `C-u M-.', one merely changes the _preferred_ keyword and
 does nothing more.
 
    All keywords known for `M-.' are recognized by the `,' command when
@@ -615,7 +615,7 @@
 
    If a string is marked with `c-format' and this is not correct the
 user can find out who is responsible for the decision.  *Note xgettext
-Invocation:: to see how the `--debug' option can be used for solving
+Invocation::, to see how the `--debug' option can be used for solving
 this problem.
 
 
@@ -858,7 +858,7 @@
 to be.  Most of times, when problems arise, the only way left to make
 her judgment is looking at the true program sources from where this
 string originated, searching for surrounding comments the programmer
-might have put in there, and looking around for helping clues of *any*
+might have put in there, and looking around for helping clues of _any_
 kind.
 
    Surely, when looking at program sources, the translator will receive
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/doc/gettext.info-3 gettext.hacked/doc/gettext.info-3
--- gettext.initial/doc/gettext.info-3	Mon Feb 22 13:40:47 1999
+++ gettext.hacked/doc/gettext.info-3	Mon Apr 19 18:54:47 1999
@@ -1,5 +1,5 @@
-This is Info file gettext.info, produced by Makeinfo version 1.68 from
-the input file gettext.texi.
+This is gettext.info, produced by Makeinfo version 3.12f from
+gettext.texi.
 
 INFO-DIR-SECTION GNU Gettext Utilities
 START-INFO-DIR-ENTRY
@@ -139,7 +139,7 @@
 entry, all ready for edition, fully modifiable and with the complete
 extent of GNU Emacs modifying commands.  The string is presented to the
 translator expunged of all quoting marks, and she will modify the
-*unquoted* string in this window to heart's content.  Once done, the
+_unquoted_ string in this window to heart's content.  Once done, the
 regular Emacs command `M-C-c' (`exit-recursive-edit') may be used to
 return the edited translation into the PO file, replacing the original
 translation.  The keys `C-c C-c' are bound so they have the same effect
@@ -170,7 +170,7 @@
 added after it.  If the translator adds characters after the
 terminating `<', it looses its delimiting property and integrally
 becomes part of the string.  If she removes the delimiting `<', then
-the edited string is taken *as is*, with all trailing newlines, even if
+the edited string is taken _as is_, with all trailing newlines, even if
 invisible.  Also, if the translated string ought to end itself with a
 genuine `<', then the delimiting `<' may not be removed; so the string
 should appear, in the editing window, as ending with two `<' in a row.
@@ -212,7 +212,7 @@
 so, its previous contents is put apart in a special place, known as the
 kill ring.  The command `w' (`po-kill-ring-save-msgstr') has also the
 effect of taking a copy of the translation onto the kill ring, but it
-otherwise leaves the entry alone, and does *not* remove the translation
+otherwise leaves the entry alone, and does _not_ remove the translation
 from the entry.  Both commands use exactly the Emacs kill ring, which
 is shared between buffers, and which is well known already to GNU Emacs
 lovers.
@@ -273,9 +273,9 @@
 mark the current entry location, then starts chasing obsolete entries
 with `o', hoping to find some translation corresponding to the
 unmodified string.  Once found, she uses the `DEL' command for deleting
-the obsolete entry, knowing that `DEL' also *kills* the translation,
+the obsolete entry, knowing that `DEL' also _kills_ the translation,
 that is, pushes the translation on the kill ring.  Then, `r' returns to
-the initial untranslated entry, `y' then *yanks* the saved translation
+the initial untranslated entry, `y' then _yanks_ the saved translation
 right into the `msgstr' field.  The translator is then free to use
 `<RET>' for fine tuning the translation contents, and maybe to later
 use `u', then `m' again, for going on with the next untranslated string.
@@ -299,7 +299,7 @@
 when she returns to this PO file after a while.
 
    Comments not having whitespace after the initial `#', for example,
-those beginning with `#.' or `#:', are *not* translator comments, they
+those beginning with `#.' or `#:', are _not_ translator comments, they
 are exclusively created by other `gettext' tools.  So, the commands
 below will never alter such system added comments, they are not meant
 for the translator to modify.  *Note PO Files::.
@@ -352,7 +352,7 @@
 are withdrawn, and replaced by other strings taken along the kill ring.
 
    On the kill ring, all strings have the same nature.  There is no
-distinction between *translation* strings and *translator comments*
+distinction between _translation_ strings and _translator comments_
 strings.  So, for example, let's presume the translator has just
 finished editing a translation, and wants to create a new translator
 comment to document why the previous translation was not good, just to
@@ -425,7 +425,7 @@
 of the selected file is left undisturbed.
 
    For all this to work fully, auxiliary PO files will have to be
-normalized, in that way that `msgid' fields should be written *exactly*
+normalized, in that way that `msgid' fields should be written _exactly_
 the same way.  It is possible to write `msgid' fields in various ways
 for representing the same string, different writing would break the
 proper behaviour of the auxiliary file commands of PO mode.  This is not
@@ -481,7 +481,7 @@
      already present.
 
      We find this behaviour of Sun's implementation rather silly and so
-     by default this mode is *not* selected.
+     by default this mode is _not_ selected.
 
 `-v'
 `--verbose'
@@ -561,7 +561,7 @@
 search, for when the MO file does not contain an hashing table, or for
 when it is not practical to use the hashing table provided in the MO
 file.  This also has another advantage, as the empty string in a PO
-file GNU `gettext' is usually *translated* into some system information
+file GNU `gettext' is usually _translated_ into some system information
 attached to that particular MO file, and the empty string necessarily
 becomes the first in both the original and translated tables, making
 the system information very easy to find.
@@ -569,7 +569,7 @@
    The size S of the hash table can be zero.  In this case, the hash
 table itself is not contained in the MO file.  Some people might prefer
 this because a precomputed hashing table takes disk space, and does not
-win *that* much speed.  The hash table contains indices to the sorted
+win _that_ much speed.  The hash table contains indices to the sorted
 array of strings in the MO file.  Conflict resolution is done by double
 hashing.  The precise hashing algorithm used is fairly dependent of GNU
 `gettext' code, and is not documented here.
@@ -656,7 +656,7 @@
 strange kind of magic that just makes their own native language appear
 everywhere on their screens.  As for naive users, they would ideally
 have no special pleasure about it, merely taking their own language for
-*granted*, and becoming rather unhappy otherwise.
+_granted_, and becoming rather unhappy otherwise.
 
    So, let's try to describe here how we would like the magic to
 operate, as we want the users' view to be the simplest, among all ways
@@ -711,7 +711,7 @@
 
    By default, packages fully using GNU `gettext', internally, are
 installed in such a way that they to allow translation of messages.  At
-*configuration* time, those packages should automatically detect
+_configuration_ time, those packages should automatically detect
 whether the underlying host system provides usable `catgets' or
 `gettext' functions.  If neither is present, the GNU `gettext' library
 should be automatically prepared and used.  Installers may use special
@@ -734,7 +734,7 @@
 ===================
 
    We consider here those packages using GNU `gettext' internally, and
-for which the installers did not disable translation at *configure*
+for which the installers did not disable translation at _configure_
 time.  Then, users only have to set the `LANG' environment variable to
 the appropriate `LL' prior to using the programs in the package.  *Note
 Matrix::.  For example, let's presume a German site.  At the shell
@@ -793,7 +793,7 @@
 very same who published this specifications.  This leads me to making
 the prediction that this interface will be in future Unix standards
 (e.g. Spec1170) and therefore part of all Unix implementation
-(implementations, which are *allowed* to wear this name).
+(implementations, which are _allowed_ to wear this name).
 
 * Menu:
 
@@ -840,7 +840,7 @@
    The fourth argument is not used to address the translation.  It is
 given as a default value in case when one of the addressing stages
 fail.  One important thing to remember is that although the return type
-of catgets is `char *' the resulting string *must not* be changed.  It
+of catgets is `char *' the resulting string _must not_ be changed.  It
 should better `const char *', but the standard is published in 1988,
 one year before ANSI C.
 
@@ -883,7 +883,7 @@
 method of normal file handling (open-use-close) and that it does not
 burden the programmer so many task, especially the unique key handling.
 Of course here is also a unique key needed, but this key is the message
-itself (how long or short it is).  *Note Comparison:: for a more
+itself (how long or short it is).  *Note Comparison::. for a more
 detailed comparison of the two methods.
 
    The following section contains a rather detailed description of the
@@ -920,7 +920,7 @@
 argument is a null-terminated string, whose characters must be legal in
 the use in filenames.  If the DOMAIN_NAME argument is `NULL', the
 function return the current value.  If no value has been set before,
-the name of the default domain is returned: *messages*.  Please note
+the name of the default domain is returned: _messages_.  Please note
 that although the return value of `textdomain' is of type `char *' no
 changing is allowed.  It is also important to know that no checks of
 the availability are made.  If the name is not available you will see
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/doc/gettext.info-4 gettext.hacked/doc/gettext.info-4
--- gettext.initial/doc/gettext.info-4	Mon Feb 22 13:40:47 1999
+++ gettext.hacked/doc/gettext.info-4	Mon Apr 19 18:54:47 1999
@@ -1,5 +1,5 @@
-This is Info file gettext.info, produced by Makeinfo version 1.68 from
-the input file gettext.texi.
+This is gettext.info, produced by Makeinfo version 3.12f from
+gettext.texi.
 
 INFO-DIR-SECTION GNU Gettext Utilities
 START-INFO-DIR-ENTRY
@@ -102,7 +102,7 @@
 `dcgettext__' is called, the real implementation of the `dcgettext'
 function.
 
-   If the string argument *is* constant we can reuse the once gained
+   If the string argument _is_ constant we can reuse the once gained
 translation when the locale selection has not changed.  This is exactly
 what is done here.  The `_nl_msg_cat_cntr' variable is defined in the
 `loadmsgcat.c' which is available in `libintl.a' and is changed
@@ -130,9 +130,9 @@
    Even this definition can be avoided when the system supports the
 `gettext' function in its C library.  When we compile this code the
 result is the same as if no NLS code is used.  When  you take a look at
-the GNU `gettext' code you will see that we use `_("...")'  instead of
+the GNU `gettext' code you will see that we use `_("...")' instead of
 `gettext("...")'.  This reduces the number of additional characters per
-translatable string to *3* (in words: three).
+translatable string to _3_ (in words: three).
 
    When now a production version of the program is needed we simply
 replace the definition
@@ -327,6 +327,7 @@
      to select the language at runtime.  Non-interactive programs (like
      all these little Unix tools) should never need this.
 
+
 
 File: gettext.info,  Node: Temp Programmers,  Prev: gettext grok,  Up: Programmers
 
@@ -478,7 +479,7 @@
 maintainers, translators and users all together, so GNU will gradually
 become able to speak many native languages.
 
-   The GNU `gettext' tool set contains *everything* maintainers need
+   The GNU `gettext' tool set contains _everything_ maintainers need
 for internationalizing their packages for messages.  It also contains
 quite useful tools for helping translators at localizing messages to
 their native language, once a package has already been
@@ -487,13 +488,13 @@
    To achieve the Translation Project, we need many interested people
 who like their own language and write it well, and who are also able to
 synergize with other translators speaking the same language.  If you'd
-like to volunteer to *work* at translating messages, please send mail
+like to volunteer to _work_ at translating messages, please send mail
 to your translating team.
 
    Each team has its own mailing list, courtesy of Linux International.
 You may reach your translating team at the address `LL@li.org',
 replacing LL by the two-letter ISO 639 code for your language.
-Language codes are *not* the same as country codes given in ISO 3166.
+Language codes are _not_ the same as country codes given in ISO 3166.
 The following translating teams exist:
 
      Chinese `zh', Czech `cs', Danish `da', Dutch `nl', Esperanto `eo',
@@ -510,7 +511,7 @@
 
      subscribe
 
-   Keep in mind that team members should be interested in *working* at
+   Keep in mind that team members should be interested in _working_ at
 translations, or at solving translational difficulties, rather than
 merely lurking around.  If your team does not exist yet and you want to
 start one, please write to `gnu-translation@prep.ai.mit.edu'; you will
@@ -578,7 +579,7 @@
      Some languages are not spoken by a very large number of people, so
      people speaking them sometimes consider that there may not be all
      that much demand such versions of free software packages.
-     Moreover, many people being *into computers*, in some countries,
+     Moreover, many people being _into computers_, in some countries,
      generally seem to prefer English versions of their software.
 
      On the other end, people might enjoy their own language a lot, and
@@ -632,6 +633,7 @@
      assembling a package prepared for localization, but not providing
      the localization routines themselves.
 
+
 
 File: gettext.info,  Node: Organization,  Next: Information Flow,  Prev: Discussions,  Up: Translators
 
@@ -769,7 +771,7 @@
 internationalized programs is achieved is a difficult (and delicate)
 job.  Knowing the latin character of French people (:-), if we take this
 the wrong way, we could end up nowhere, or spoil a lot of energies.
-Maybe we should begin to address this problem seriously *before* GNU
+Maybe we should begin to address this problem seriously _before_ GNU
 `gettext' become officially published.  And I suspect that this means
 soon!
 
@@ -798,6 +800,7 @@
      this group consists solely by me but I ask some others
      occasionally; this also seems to work).
 
+
 
 File: gettext.info,  Node: Mailing Lists,  Prev: National Teams,  Up: Organization
 
@@ -822,7 +825,7 @@
 were politely invited to organize it anywhere else, and so did we.  For
 communicating with my pretesters, I later made a handful of mailing
 lists located at iro.umontreal.ca and administrated by `majordomo'.
-These lists have been *very* dependable so far...
+These lists have been _very_ dependable so far...
 
    I suspect that the German team will organize itself a mailing list
 located in Germany, and so forth for other countries.  But before they
@@ -832,7 +835,7 @@
 
    We should create temporary mailing lists, one per country, to help
 people organize.  Temporary, because once regrouped and structured, it
-would be fair the volunteers from country bring back *their* list in
+would be fair the volunteers from country bring back _their_ list in
 there and manage it as they want.  My feeling is that, in the long run,
 each team should run its own list, from within their country.  There
 also should be some central list to which all teams could subscribe as
@@ -852,8 +855,8 @@
 
    If I put one of my things to pretest, Ulrich receives the
 announcement and passes it on to the German team, who make last minute
-revisions.  Then he submits the translation files to me *as the
-maintainer*.  For free packages I do not maintain, I would not even
+revisions.  Then he submits the translation files to me _as the
+maintainer_.  For free packages I do not maintain, I would not even
 hear about it.  This scheme could be made to work for the whole
 Translation Project, I think.  For security reasons, maybe Ulrich
 (national coordinators, in fact) should update central registry kept at
@@ -966,7 +969,7 @@
      GNU `gettext' are already installed at your site, and if not,
      proceed to do this first.  If you got to install these things,
      beware that GNU `m4' must be fully installed before GNU Autoconf
-     is even *configured*.
+     is even _configured_.
 
      To further ease the task of a package maintainer the `automake'
      package was designed and implemented.  GNU `gettext' now uses this
@@ -999,6 +1002,7 @@
      absolutely no PO files, and wait until various translator teams
      get interested in your package, and submit PO files.
 
+
    It is worth adding here a few words about how the maintainer should
 ideally behave with PO files submissions.  As a maintainer, your role is
 to authentify the origin of the submission as being the representative
@@ -1013,19 +1017,19 @@
 complete, and should avoid diving into linguistic matters.  Translation
 teams drive themselves and are fully responsible of their linguistic
 choices for the Translation Project.  Keep in mind that translator
-teams are *not* driven by maintainers.  You can help by carefully
+teams are _not_ driven by maintainers.  You can help by carefully
 redirecting all communications and reports from users about linguistic
 matters to the appropriate translation team, or explain users how to
 reach or join their team.  The simplest might be to send them the
 `ABOUT-NLS' file.
 
-   Maintainers should *never ever* apply PO file bug reports
+   Maintainers should _never ever_ apply PO file bug reports
 themselves, short-cutting translation teams.  If some translator has
 difficulty to get some of her points through her team, it should not be
 an issue for her to directly negotiate translations with maintainers.
 Teams ought to settle their problems themselves, if any.  If you, as a
 maintainer, ever think there is a real problem with a team, please
-never try to *solve* a team's problem on your own.
+never try to _solve_ a team's problem on your own.
 
 
 File: gettext.info,  Node: gettextize Invocation,  Next: Adjusting Files,  Prev: Prerequisites,  Up: Maintainers
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/doc/gettext.info-5 gettext.hacked/doc/gettext.info-5
--- gettext.initial/doc/gettext.info-5	Mon Feb 22 13:40:47 1999
+++ gettext.hacked/doc/gettext.info-5	Mon Apr 19 18:54:47 1999
@@ -1,5 +1,5 @@
-This is Info file gettext.info, produced by Makeinfo version 1.68 from
-the input file gettext.texi.
+This is gettext.info, produced by Makeinfo version 3.12f from
+gettext.texi.
 
 INFO-DIR-SECTION GNU Gettext Utilities
 START-INFO-DIR-ENTRY
@@ -162,7 +162,7 @@
    If you already have an `aclocal.m4' file, then you will have to
 merge the said macros into your `aclocal.m4'.  Note that if you are
 upgrading from a previous release of GNU `gettext', you should most
-probably *replace* the said macros, as they usually change a little
+probably _replace_ the said macros, as they usually change a little
 from one release of GNU `gettext' to the next.  Their contents may vary
 as we get more experience with strange systems out there.
 
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/doc/gettext.texi gettext.hacked/doc/gettext.texi
--- gettext.initial/doc/gettext.texi	Mon Feb 22 13:40:47 1999
+++ gettext.hacked/doc/gettext.texi	Sun Mar 21 17:07:26 1999
@@ -1679,7 +1679,7 @@
 
 If a string is marked with @kbd{c-format} and this is not correct the
 user can find out who is responsible for the decision.  @xref{xgettext
-Invocation} to see how the @kbd{--debug} option can be used for solving
+Invocation}, to see how the @kbd{--debug} option can be used for solving
 this problem.
 
 @node Special cases,  , c-format, Sources
@@ -3078,7 +3078,7 @@
 method of normal file handling (open-use-close) and that it does not
 burden the programmer so many task, especially the unique key handling.
 Of course here is also a unique key needed, but this key is the
-message itself (how long or short it is).  @xref{Comparison} for a
+message itself (how long or short it is).  @xref{Comparison}. for a
 more detailed comparison of the two methods.
 
 The following section contains a rather detailed description of the
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/doc/stamp-vti gettext.hacked/doc/stamp-vti
--- gettext.initial/doc/stamp-vti	Mon Feb 22 13:40:47 1999
+++ gettext.hacked/doc/stamp-vti	Mon Apr 19 18:54:47 1999
@@ -1,3 +1,3 @@
-@set UPDATED 30 April 1998
+@set UPDATED 21 March 1999
 @set EDITION 0.10.35
 @set VERSION 0.10.35
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/doc/version.texi gettext.hacked/doc/version.texi
--- gettext.initial/doc/version.texi	Mon Feb 22 13:40:47 1999
+++ gettext.hacked/doc/version.texi	Mon Apr 19 18:54:47 1999
@@ -1,3 +1,3 @@
-@set UPDATED 30 April 1998
+@set UPDATED 21 March 1999
 @set EDITION 0.10.35
 @set VERSION 0.10.35
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/po/gettext.pot gettext.hacked/po/gettext.pot
--- gettext.initial/po/gettext.pot	Mon Feb 22 13:40:48 1999
+++ gettext.hacked/po/gettext.pot	Thu May  6 17:32:13 1999
@@ -6,7 +6,7 @@
 msgid ""
 msgstr ""
 "Project-Id-Version: PACKAGE VERSION\n"
-"POT-Creation-Date: 1998-04-30 22:50-0700\n"
+"POT-Creation-Date: 1999-05-05 18:24-0400\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
@@ -143,23 +143,23 @@
 msgid "Report bugs to <bug-gnu-utils@gnu.org>.\n"
 msgstr ""
 
-#: src/message.c:784
+#: src/message.c:787
 #, c-format
 msgid ""
 "internationalized messages should not contain the `\\%c' escape sequence"
 msgstr ""
 
-#: src/message.c:1115
+#: src/message.c:1268 src/message.c:1586
 #, c-format
 msgid "cannot create output file \"%s\""
 msgstr ""
 
-#: src/message.c:1122
+#: src/message.c:1275 src/message.c:1591
 #, no-c-format
 msgid "standard output"
 msgstr ""
 
-#: src/message.c:1182
+#: src/message.c:1335 src/message.c:1633
 #, c-format
 msgid "error while writing \"%s\" file"
 msgstr ""
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/src/Makefile.am gettext.hacked/src/Makefile.am
--- gettext.initial/src/Makefile.am	Mon Feb 22 13:40:48 1999
+++ gettext.hacked/src/Makefile.am	Mon Feb 22 18:43:39 1999
@@ -19,7 +19,7 @@
 
 AUTOMAKE_OPTIONS = 1.2 gnits
 
-bin_PROGRAMS = gettext msgcmp msgfmt msgmerge msgunfmt xgettext msgcomm
+bin_PROGRAMS = gettext msgcmp msgfmt msgmerge msgunfmt xgettext msgcomm msghack
 
 noinst_HEADERS = domain.h message.h po-gram.h po-hash.h po-lex.h po.h \
 str-list.h xget-lex.h po-gram.gen.h po-hash.gen.h dir-list.h
@@ -52,7 +52,8 @@
 po.c str-list.c xget-lex.c xgettext.c dir-list.c
 msgcomm_SOURCES = msgcomm.c message.c po-gram.gen.c po-hash.gen.c po-lex.c \
 open-po.c po.c str-list.c dir-list.c
-
+msghack_SOURCES = msghack.c open-po.c dir-list.c message.c str-list.c \
+po-gram.gen.c po-hash.gen.c po-lex.c po.c
 MAINTAINERCLEANFILES = po-gram.gen.c po-gram.gen.h po-hash.gen.c po-hash.gen.h
 
 # Some rules for yacc handling.
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/src/message.c gettext.hacked/src/message.c
--- gettext.initial/src/message.c	Mon Feb 22 13:40:48 1999
+++ gettext.hacked/src/message.c	Mon Apr 19 05:21:23 1999
@@ -68,6 +68,9 @@
 static void message_print PARAMS ((const message_ty *__mp, FILE *__fp,
 				   const char *__domain, int blank_line,
 				   int __debug));
+static void master_message_print PARAMS ((const message_ty *__mp,
+					  FILE *__fp,
+					  int blank_line));
 static void message_print_obsolete PARAMS ((const message_ty *__mp, FILE *__fp,
 					    const char *__domain,
 					    int blank_line));
@@ -990,6 +993,156 @@
 
 
 static void
+master_message_print (mp, fp, blank_line)
+     const message_ty *mp;
+     FILE *fp;
+     int blank_line;
+{
+    size_t j;
+
+    /* Separate messages with a blank line.  Uniforum doesn't like blank
+       lines, so use an empty comment (unless there already is one).  */
+    if (blank_line && (!uniforum
+		       || mp->comment == NULL
+		       || mp->comment->nitems == 0
+		       || mp->comment->item[0][0] != '\0'))
+	print_blank_line (fp);
+
+    if (mp->comment != NULL)
+	for (j = 0; j < mp->comment->nitems; ++j) {
+	    const unsigned char *s = mp->comment->item[j];
+	    do {
+		const unsigned char *e;
+		putc ('#', fp);
+		/* FIXME This is the wrong locale.  While
+		   message_list_print set the "C" locale for LC_CTYPE,
+		   the need to use the correct locale for the file's
+		   contents.  */
+		if (*s != '\0' && !isspace (*s))
+		    putc (' ', fp);
+		e = strchr (s, '\n');
+		if (e == NULL) {
+		    fputs (s, fp);
+		    s = NULL;
+		} else {
+		    fwrite (s, 1, e - s, fp);
+		    s = e + 1;
+		}
+		putc ('\n', fp);
+	    } while (s != NULL);
+	}
+
+    if (mp->comment_dot != NULL)
+	for (j = 0; j < mp->comment_dot->nitems; ++j) {
+	    const unsigned char *s = mp->comment_dot->item[j];
+	    putc ('#', fp);
+	    putc ('.', fp);
+	    /* FIXME This is the wrong locale.  While
+	       message_list_print set the "C" locale for LC_CTYPE, the
+	       need to use the correct locale for the file's contents.  */
+	    if (*s && !isspace (*s))
+		putc (' ', fp);
+	    fputs (s, fp);
+	    putc ('\n', fp);
+	}
+
+
+    /* Print the file position comments for every domain.  This will
+       help a human who is trying to navigate the sources.  There is no
+       problem of getting repeat positions, because duplicates are
+       checked for.  */
+    if (mp->filepos_count != 0) {
+	if (uniforum)
+	    for (j = 0; j < mp->filepos_count; ++j) {
+		lex_pos_ty *pp = &mp->filepos[j];
+		char *cp = pp->file_name;
+		while (cp[0] == '.' && cp[1] == '/')
+		    cp += 2;
+		/* There are two Sun formats to choose from: SunOS and
+		   Solaris.  Use the Solaris form here.  */
+		fprintf (fp, "# File: %s, line: %ld\n",
+			 cp, (long) pp->line_number);
+	    } else {
+		size_t column;
+
+		fputs ("#:", fp);
+		column = 2;
+		for (j = 0; j < mp->filepos_count; ++j) {
+		    lex_pos_ty *pp;
+		    char buffer[20];
+		    char *cp;
+		    size_t len;
+
+		    pp = &mp->filepos[j];
+		    cp = pp->file_name;
+		    while (cp[0] == '.' && cp[1] == '/')
+			cp += 2;
+		    snprintf (buffer, sizeof(buffer), "%ld", (long) pp->line_number);
+		    len = strlen (cp) + strlen (buffer) + 2;
+		    if (column > 2 && column + len >= page_width)
+			{
+			    fputs ("\n#:", fp);
+			    column = 2;
+			}
+		    fprintf (fp, " %s:%s", cp, buffer);
+		    column += len;
+		}
+		putc ('\n', fp);
+	    }
+    }
+
+    /* Print flag information in special comment.  */
+    if (mp->is_fuzzy || significant_c_format_p (mp->is_c_format) || mp->do_wrap == no) {
+	int first_flag = 1;
+
+	putc ('#', fp);
+	putc (',', fp);
+
+	/* We don't print the fuzzy flag if the msgstr is empty.  This
+	   might be introduced by the user but we want to normalize the
+	   output.  */
+	if (mp->is_fuzzy) {
+	    fputs (" fuzzy", fp);
+	    first_flag = 0;
+	}
+
+	if (significant_c_format_p (mp->is_c_format)) {
+	    if (!first_flag)
+		putc (',', fp);
+
+	    fputs (make_c_format_description_string (mp->is_c_format, 0),
+		   fp);
+	    first_flag = 0;
+	}
+
+	if (mp->do_wrap == no) {
+	    if (!first_flag)
+		putc (',', fp);
+
+	    fputs (make_c_width_description_string (mp->do_wrap), fp);
+	    first_flag = 0;
+	}
+
+	putc ('\n', fp);
+    }
+
+    /* Print each of the message components.  Wrap them nicely so they
+       are as readable as possible.  If there is no recorded msgstr for
+       this domain, emit an empty string.  */
+    wrap (fp, NULL, "msgid", mp->msgid, mp->do_wrap);
+    for (j = 0; j < mp->variant_count; ++j) {
+	char *msgstr; size_t msgstr_size;
+
+	msgstr = malloc(msgstr_size = (strlen(mp->variant[j].domain) + 10));
+	snprintf(msgstr, msgstr_size, "msgstr(%s)", mp->variant[j].domain);
+
+	wrap (fp, NULL, msgstr, mp->variant[j].msgstr, mp->do_wrap);
+    }
+
+}
+
+
+static void
 message_print_obsolete (mp, fp, domain, blank_line)
      const message_ty *mp;
      FILE *fp;
@@ -1402,3 +1555,83 @@
 
   page_width = n;
 }
+
+
+/*
+ * HACKS... This prints a mesage list, but it uses the
+ * msgstr(somain) syntax instead
+ */
+ void
+master_list_print (mlp, filename)
+     message_list_ty *mlp;
+     const char *filename;
+{
+    FILE *fp;
+    size_t j;
+    int blank_line;
+#ifdef HAVE_SETLOCALE
+    char *old_locale;
+#endif
+
+    /* We will not write anything if we have no message or only the
+       header entry.  */
+    if (mlp->nitems == 0 || (mlp->nitems == 1 && *mlp->item[0]->msgid == '\0'))
+	return;
+
+    /* Open the output file.  */
+    if (filename != NULL && strcmp (filename, "-") != 0
+	&& strcmp (filename, "/dev/stdout") != 0) {
+	fp = fopen (filename, "w");
+	if (fp == NULL)
+	    error (EXIT_FAILURE, errno, _("cannot create output file \"%s\""),
+		   filename);
+    } else {
+	fp = stdout;
+	/* xgettext:no-c-format */
+	filename = _("standard output");
+    }
+
+#ifdef HAVE_SETLOCALE
+    /* FIXME This is the wrong locale.  The program is currently set for
+       the user's native language locale, for the error messages.  This
+       code sets it to the "C" locale, but that isn't right either.  The
+       need is to use the correct locale for the file's contents.  */
+    old_locale = setlocale (LC_CTYPE, "C");
+    if (old_locale)
+	old_locale = xstrdup (old_locale);
+#endif
+
+    /* Write out each of the messages for this domain.  */
+    for (j = 0; j < mlp->nitems; ++j)
+	if (mlp->item[j]->obsolete == 0) {
+	    master_message_print (mlp->item[j], fp, blank_line);
+	    blank_line = 1;
+	}
+
+#if 0 /* screw the obsoletes */
+    /* Write out each of the obsolete messages for this domain.  */
+    for (j = 0; j < mlp->nitems; ++j)
+	if (mlp->item[j]->obsolete != 0) {
+	    message_print_obsolete (mlp->item[j], fp, dl->item[k], blank_line);
+	    blank_line = 1;
+	}
+#endif
+
+    /* Restore the old locale.  Do this before emitting error messages,
+       so that the correct locale is used for the error.  (Ideally,
+       error should ensure this before calling gettext for the format
+       string.)  */
+#ifdef HAVE_SETLOCALE
+    if (old_locale) {
+	setlocale (LC_CTYPE, old_locale);
+	free (old_locale);
+    }
+#endif
+
+    /* Make sure nothing went wrong.  */
+    if (fflush (fp))
+	error (EXIT_FAILURE, errno, _("error while writing \"%s\" file"),
+	       filename);
+    fclose (fp);
+}
+
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/src/message.h gettext.hacked/src/message.h
--- gettext.initial/src/message.h	Mon Feb 22 13:40:48 1999
+++ gettext.hacked/src/message.h	Mon Apr 19 05:21:23 1999
@@ -126,4 +126,7 @@
 int possible_c_format_p PARAMS ((enum is_c_format));
 void message_page_width_set PARAMS ((size_t width));
 
+/* Hacks go at the end */
+void master_list_print PARAMS ((message_list_ty *__mlp, const char *__filename));
+
 #endif /* message.h */
diff -urN --exclude Makefile.in --exclude ltconfig --exclude ltmain.sh --exclude configure --exclude build --exclude CVS --exclude config.* --exclude genpatch --exclude .cvsignore --exclude aclocal.m4 --exclude *.po --exclude *.gmo --exclude gettext-0.10.35-hacks.patch gettext.initial/src/msghack.c gettext.hacked/src/msghack.c
--- gettext.initial/src/msghack.c	Wed Dec 31 19:00:00 1969
+++ gettext.hacked/src/msghack.c	Sun Feb 27 13:30:00 2000
@@ -0,0 +1,1606 @@
+/* GNU gettext - internationalization aids
+   Copyright (C) 1995, 1996, 1997, 1998, 1999  Free Software Foundation, Inc.
+   This file was written by Cristian Gafton <gafton@redhat.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <getopt.h>
+#include <limits.h>
+#include <stdio.h>
+
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+#endif
+
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
+#if HAVE_LOCALE_H
+# include <locale.h>
+#endif
+
+#include <time.h>
+#include <errno.h>
+
+#include "dir-list.h"
+#include "error.h"
+#include "message.h"
+#include <system.h>
+#include <libintl.h>
+#include "po.h"
+
+#define _(str) gettext (str)
+
+
+/* This structure defines a derived class of the po_ty class.  (See
+   po.h for an explanation.)  */
+typedef struct merge_class_ty merge_class_ty;
+struct merge_class_ty
+{
+  /* inherited instance variables, etc */
+  PO_BASE_TY
+
+  /* Name of domain we are currently examining.  */
+  char *domain;
+
+  /* List of domains already appeared in the current file.  */
+  string_list_ty *domain_list;
+
+  /* List of messages already appeared in the current file.  */
+  message_list_ty *mlp;
+
+  /* Accumulate comments for next message directive */
+  string_list_ty *comment;
+  string_list_ty *comment_dot;
+
+  /* Flags transported in special comments.  */
+  int is_fuzzy;
+  enum is_c_format is_c_format;
+  enum is_c_format do_wrap;
+
+  /* Accumulate filepos comments for the next message directive.  */
+  size_t filepos_count;
+  lex_pos_ty *filepos;
+};
+
+
+/* String containing name the program is called with.  */
+const char *program_name;
+
+/* Verbosity level.  */
+static int verbosity_level;
+
+/* If nonzero, remember comments for file name and line number for each
+   msgid, if present in the reference input.  Defaults to true.  */
+static int line_comment = 1;
+
+/* Force output of PO file even if empty.  */
+static int force_po;
+
+/* should  we merge in the fuzzy messages ? */
+static int fuzzy = 0;
+
+/* Do we want to generate useless merges? */
+static int useless = 0;
+
+/* Possible split operations */
+#define SPLIT_MSGID	1
+#define SPLIT_MSGSTR	2
+static int split_flag = 0;
+
+/* Possible explode operations */
+#define	EXPLODE_MSGID	4
+#define	EXPLODE_MSGSTR	8
+static int explode_flag = 0;
+
+/* Sort orders */
+#define SORT_BY_FILEPOS		1
+#define SORT_BY_MSGID		2
+static int sort_order = 0;
+
+/* Other flags */
+static int comments = 0;
+
+/* Prototypes for local functions.  */
+static void usage PARAMS ((int __status));
+static void error_print PARAMS ((void));
+static void merge_constructor PARAMS ((po_ty *__that));
+static void merge_destructor PARAMS ((po_ty *__that));
+static void merge_directive_domain PARAMS ((po_ty *__that, char *__name));
+static void merge_directive_message PARAMS ((po_ty *__that, char *__msgid,
+					     lex_pos_ty *__msgid_pos,
+					     char *__msgstr, lex_pos_ty *__msgstr_pos));
+static void merge_parse_brief PARAMS ((po_ty *__that));
+static void merge_parse_debrief PARAMS ((po_ty *__that));
+static void merge_comment PARAMS ((po_ty *__that, const char *__s));
+static void merge_comment_dot PARAMS ((po_ty *__that, const char *__s));
+static void merge_comment_special PARAMS ((po_ty *__that, const char *__s));
+static void merge_comment_filepos PARAMS ((po_ty *__that, const char *__name,
+					   int __line));
+static message_list_ty *grammar PARAMS ((const char *__filename));
+static message_list_ty *append PARAMS ((const char *__fn1, const char *__fn2, int diff_only));
+static message_list_ty *merge PARAMS ((const char *__fn1, const char *__fn2));
+static message_list_ty *invert PARAMS ((const char *__fn));
+static message_list_ty *missing PARAMS ((const char *__fn));
+static message_list_ty *un_duplicate PARAMS ((message_list_ty *dup_list));
+static message_list_ty *empty PARAMS ((const char *__fn));
+static message_list_ty *dummy PARAMS ((const char *__fn));
+static message_list_ty *split PARAMS ((const char *__fn, int __flag));
+static message_list_ty *explode PARAMS ((const char *__fn, int __flag));
+static message_list_ty *master PARAMS ((message_list_ty **prev, const char *__fn,
+					const char *__master_id));
+static message_ty *message_join PARAMS ((message_ty *def, message_ty *ref));
+static struct message_ty *new_header PARAMS((void));
+
+/* What kind of actions we can make */
+#define ACTION_DO_SPLIT		1
+#define ACTION_DO_INVERT	2
+#define ACTION_DO_MERGE		3
+#define ACTION_DO_EMPTY		4
+#define ACTION_DO_EXPLODE	5
+#define ACTION_DO_MASTER	6
+#define ACTION_DO_SORT		7
+#define ACTION_DO_APPEND	8
+#define ACTION_DO_UNDUP		9
+#define ACTION_DO_MISSING      10
+#define ACTION_DO_DUMMY	       11
+#define ACTION_DO_DIFF	       12
+
+int main (argc, argv)
+     int argc;
+     char **argv;
+{
+    int opt;
+    int do_action = 0;
+    char *output_file;
+    message_list_ty *result;
+
+    /* Long options.  */
+    const struct option long_options[] =
+    {
+	/* command pairs */
+	{ "split-id",  no_argument, &split_flag, SPLIT_MSGID },
+	{ "split-str", no_argument, &split_flag, SPLIT_MSGSTR },
+
+	{ "explode-id",  required_argument, &explode_flag, EXPLODE_MSGID },
+	{ "explode-str", required_argument, &explode_flag, EXPLODE_MSGSTR },
+
+	{ "sort-by-file", no_argument, &sort_order, SORT_BY_FILEPOS },
+	{ "sort-by-id",   no_argument, &sort_order, SORT_BY_MSGID }, 
+
+	/* flags */
+	{ "fuzzy", 	 no_argument, 		&fuzzy,   1 },
+	{ "force-po", 	 no_argument, 		&force_po, 1 },
+	{ "width", 	 required_argument, 	NULL,    'w', },
+	{ "output-file", required_argument, 	NULL,    'o' },
+	{ "useless",     no_argument, 		&useless, 1 }, 
+
+	/*
+	 *  ACTIONS
+	 */
+	/* switch the msgid and the msgstr strings in a PO file */
+	{ "invert",      no_argument, &do_action, ACTION_DO_INVERT },
+
+	/* fill the msgstr with the contents of msgid */
+	{ "dummy", 	 no_argument, &do_action, ACTION_DO_DUMMY },
+	
+	/* merge two files based on commin msgid. The msgid is stored as a comment */
+	{ "merge",       no_argument, &do_action, ACTION_DO_MERGE }, 
+
+	/* strip out the msgstr creating a POT form a PO file */
+	{ "empty",       no_argument, &do_action, ACTION_DO_EMPTY }, 
+
+	/* combine sevaral PO files into a "master" catalog */
+	{ "master",      no_argument, &do_action, ACTION_DO_MASTER },
+
+	/* append entries from ref POT that do not exist in file PO */
+	{ "append",      no_argument, &do_action, ACTION_DO_APPEND },
+
+	/* show only stuff from ref POT that does not exist in file PO */
+	{ "diff",        no_argument, &do_action, ACTION_DO_DIFF },
+
+	/* ommit comments for the 'append' and 'diff' */
+	{ "comments",    no_argument, 	&comments, 1 }, 
+
+	/* remove duplicates */
+	{ "unduplicate", no_argument, &do_action, ACTION_DO_UNDUP },
+
+	/* output strings that need translation (fuzzies and untranslated */
+	{ "missing", 	 no_argument, &do_action, ACTION_DO_MISSING },
+
+	/* output strings that need translation (fuzzies and untranslated */
+	{ "missing", 	 no_argument, &do_action, ACTION_DO_MISSING },
+	
+	/* INFO */
+	{ "help", no_argument, NULL, 'h' },
+	{ "version", no_argument, NULL, 'V' },
+
+	{ NULL, 0, NULL, 0 }
+    };
+
+
+    /* Set program name for messages.  */
+    program_name = argv[0];
+    verbosity_level = 0;
+    error_print_progname = error_print;
+    gram_max_allowed_errors = INT_MAX;
+
+#ifdef HAVE_SETLOCALE
+    /* Set locale via LC_ALL.  */
+    setlocale (LC_ALL, "");
+#endif
+
+    /* Set the text message domain.  */
+    bindtextdomain (PACKAGE, LOCALEDIR);
+    textdomain (PACKAGE);
+
+    /* Set default values for variables.  */
+    output_file = NULL;
+
+    while ((opt
+	    = getopt_long (argc, argv, "ho:Vw:v", long_options, NULL))
+	   != EOF)
+	switch (opt) {
+	    case '\0':		/* Long option.  */
+		break;
+
+	    case 'h':
+		/* Help is requested.  */
+		usage (EXIT_SUCCESS);
+		break;
+
+	    case 'o':
+		output_file = optarg;
+		break;
+
+	    case 'v':
+		++verbosity_level;
+		break;
+
+	    case 'V':
+		/* Version information is requested.  */
+		printf ("%s (GNU %s) %s\n", basename (program_name), PACKAGE, VERSION);
+		/* xgettext: no-wrap */
+		printf (_("Copyright (C) %s Free Software Foundation, Inc.\n\
+This is free software; see the source for copying conditions.  There is NO\n\
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\
+"), "1995, 1996, 1997, 1998");
+		printf (_("Written by %s.\n"), "Cristian Gafton");
+		exit (EXIT_SUCCESS);
+		break;
+
+	    case 'w':
+		{
+		    int value;
+		    char *endp;
+		    value = strtol (optarg, &endp, 10);
+		    if (endp != optarg)
+			message_page_width_set (value);
+		}
+		break;
+
+	    default:
+		usage (EXIT_FAILURE);
+		break;
+	}
+
+    /* Test whether we have an .po file name as argument.  */
+    if (optind >= argc) {
+	error (EXIT_SUCCESS, 0, _("no input files given"));
+	usage (EXIT_FAILURE);
+    }
+
+    /* transform one of the pair command into a real action */
+    if (do_action == 0 && split_flag > 0)
+	do_action = ACTION_DO_SPLIT;
+    if (do_action == 0 && explode_flag > 0)
+	do_action = ACTION_DO_EXPLODE;
+    if (do_action == 0 && sort_order != 0)
+	do_action = ACTION_DO_SORT;
+
+    /* okay, we have our file in argv[optind]*/
+    /* what should we do */
+    switch (do_action) {
+	case ACTION_DO_INVERT:
+	    /* we are asked to invert the msgid and msgstr strings in a .po file */
+	    result = invert (argv[optind]);
+	    break;
+	case ACTION_DO_EMPTY:
+	    /* we are asked to delete the msgstr text in a .po file */
+	    result = empty (argv[optind]);
+	    break;
+	case ACTION_DO_DUMMY:
+	    /* dummy out a POT file in a PO file (msgstr = msgid) */
+	    result = dummy (argv[optind]);
+	    break;
+	case ACTION_DO_SPLIT:
+	    /* we are asked to split the file into corresponding meta po files */
+	    result = split(argv[optind], split_flag);
+	    /* Whatever we are asked to split out */
+	    break;
+	case ACTION_DO_EXPLODE:
+	    /* we are asked to generate a single meta entry for each xref */
+	    result = explode(argv[optind], explode_flag);
+	    break;
+	case ACTION_DO_MERGE:
+	    /* we gave to merge (id1,str1) and (id2,str2) into (str1,str2) */
+	    if (optind + 2 != argc) {
+		error (EXIT_SUCCESS, 0, _("exactly 2 input files required for merge"));
+		usage (EXIT_FAILURE);
+	    }      
+	    result = merge (argv[optind], argv[optind+1]);
+	    break;
+	case ACTION_DO_DIFF:
+	case ACTION_DO_APPEND:
+	    /* append all (id2,str2) entries from second file to the first one
+	    * provided that a id2 msgid is not already present there */
+	    if (optind + 2 != argc) {
+		error (EXIT_SUCCESS, 0, _("exactly 2 input files required for append"));
+		usage (EXIT_FAILURE);
+	    }      
+	    result = append (argv[optind], argv[optind+1], do_action == ACTION_DO_DIFF);
+	    break;
+	case ACTION_DO_UNDUP:
+	    /* read in the message catalog and try to colapse
+	       the duplicate messageids together */
+	    /* Read in the file */
+	    result = grammar (argv[optind]);
+	    result = un_duplicate(result);
+	    break;
+	case ACTION_DO_MASTER:	    
+	    /* This is a little bit funkier:
+	     * Suppose in A.po we have:
+	     *	msgid  "id"
+	     *	msgstr "str1"
+	     * And in B.po we have:
+	     *	msgid  "id"
+	     *	msgstr "str2"
+	     * then the result will look like:
+	     *	msgid 	  "id"
+	     *	msgstr(A) "str1"
+	     *	msgstr(B) "str2"
+	     */
+	    result = NULL; /* Start from scratch */
+	    for (opt = optind ; opt < argc ; opt++) {
+		char *file_name, *master_id;
+		char *tmp;
+		/* get the file name and the master id */
+		file_name = strdup(argv[opt]);
+		master_id = strdup(basename(argv[opt]));
+		tmp = rindex(master_id, '.');
+		if (tmp == NULL) {
+		    error (EXIT_SUCCESS, 0,
+			   _("Message catalog %s does not have a valid name"), argv[opt]);
+		    usage (EXIT_FAILURE);
+		}			
+		*tmp = '\0';	
+		result = master(&result, file_name, master_id);
+	    }
+	    master_list_print(result, output_file);
+	    return EXIT_SUCCESS;
+	    break;
+	case ACTION_DO_SORT:
+	    /* we'll just read in the file and let the sort
+	     * statements later deal with it */
+	    result = grammar (argv[optind]);
+	    break;
+	case ACTION_DO_MISSING:
+	    /* generate a new po file of only the missing and non-translated strings */
+	    result = missing (argv[optind]);
+	    break;
+	default:
+	    error (EXIT_SUCCESS, 0, _("Unknown Action"));
+	    exit(EXIT_FAILURE);
+    }
+
+    /* Sort the results.  */
+    switch (sort_order) {
+	case SORT_BY_FILEPOS:
+	    message_list_sort_by_filepos (result);
+	    break;
+	case SORT_BY_MSGID:
+	    message_list_sort_by_msgid (result);
+	    break;
+    }   
+
+    /* Write the merged message list out.  */
+    message_list_print (result, output_file, force_po, 0);
+
+    exit (EXIT_SUCCESS);
+}
+
+
+/* Display usage information and exit.  */
+static void
+usage (status)
+    int status;
+{
+    if (status != EXIT_SUCCESS)
+	fprintf (stderr, _("Try `%s --help' for more information.\n"),
+		 program_name);
+    else {
+	/* xgettext: no-wrap */
+	printf (_("\
+Usage: %s [OPTION] file.po [ref.po]\n\
+Mandatory arguments to long options are mandatory for short options too.\n\
+  -h, --help                  display this help and exit\n\
+      --invert                invert a po file by switching msgid and msgstr\n\
+  -o, --output-file=FILE      result will be written to FILE\n\
+  -v, --verbose               increase verbosity level\n\
+  -V, --version               output version information and exit\n\
+  -w, --width=NUMBER          set output page width\n\
+      --sort-by-file	      sort by file in which the msgs appear\n\
+      --sort-by-id	      sort by message ids\n\
+      --split-id	      split msgid from message catalg into meta catalog\n\
+      --split-str	      split msgstr from message catalg into meta catalog\n\
+      --merge		      merge file.po and ref.po based on the common msgid\n\
+      + --useless             also generate entries for unmatched pairs.\n\
+      --master		      join any number of files in a master-formatted catalog\n\
+      + --fuzzy               use the fuzzy entries when merging in PO files.\n\
+      --empty		      empty the contents of the .po file, creating a .pot\n\
+      --dummy		      create a .po file from a .pot by doing msgstr = msgid\n\
+      --append		      append entries from ref.po that don't exist in file.po\n\
+      --diff                  show what entries from ref.po don't exist in file.po\n\
+      + --comments            add comments from ref.po for existing entries. in file.po.\n\
+      --explode-id	      generate a single meta msgid entry for each xref in file.po\n\
+      --explode-str	      generate a single meta msgstr entry for each xref in file.po\n\
+      --unduplicate	      colapse together duplicate message ids. (not working currently)\n\
+      --missing		      output only the fuzzy and empty message strings\n\
+\n\
+This program can be used to alter .po files in ways no sane mind would think about.\n\
+Report problems to <gafton@redhat.com>\n\
+"), program_name);
+    }
+    exit (status);
+}
+
+
+/* The address of this function will be assigned to the hook in the
+   error functions.  */
+static void error_print ()
+{
+  /* We don't want the program name to be printed in messages.  Emacs'
+     compile.el does not like this.  */
+
+  /* FIXME Why must this program toady to Emacs?  Why can't compile.el
+     be enhanced to cope with a leading program name?  --PMiller */
+}
+
+
+static void
+merge_constructor (that)
+     po_ty *that;
+{
+  merge_class_ty *this = (merge_class_ty *) that;
+
+  this->mlp = message_list_alloc ();
+  this->domain = MESSAGE_DOMAIN_DEFAULT;
+  this->domain_list = string_list_alloc ();
+  this->comment = NULL;
+  this->comment_dot = NULL;
+  this->filepos_count = 0;
+  this->filepos = NULL;
+  this->is_fuzzy = 0;
+  this->is_c_format = undecided;
+  this->do_wrap = undecided;
+}
+
+
+static void
+merge_destructor (that)
+     po_ty *that;
+{
+  merge_class_ty *this = (merge_class_ty *) that;
+  size_t j;
+
+  string_list_free (this->domain_list);
+  /* Do not free this->mlp.  */
+  if (this->comment != NULL)
+    string_list_free (this->comment);
+  if (this->comment_dot != NULL)
+    string_list_free (this->comment_dot);
+  for (j = 0; j < this->filepos_count; ++j)
+    free (this->filepos[j].file_name);
+  if (this->filepos != NULL)
+    free (this->filepos);
+}
+
+
+static void
+merge_directive_domain (that, name)
+     po_ty *that;
+     char *name;
+{
+  size_t j;
+
+  merge_class_ty *this = (merge_class_ty *) that;
+  /* Override current domain name.  Don't free memory.  */
+  this->domain = name;
+
+  /* If there are accumulated comments, throw them away, they are
+     probably part of the file header, or about the domain directive,
+     and will be unrelated to the next message.  */
+  if (this->comment != NULL)
+    {
+      string_list_free (this->comment);
+      this->comment = NULL;
+    }
+  if (this->comment_dot != NULL)
+    {
+      string_list_free (this->comment_dot);
+      this->comment_dot = NULL;
+    }
+  for (j = 0; j < this->filepos_count; ++j)
+    free (this->filepos[j].file_name);
+  if (this->filepos != NULL)
+    free (this->filepos);
+  this->filepos_count = 0;
+  this->filepos = NULL;
+}
+
+
+static void
+merge_directive_message (that, msgid, msgid_pos, msgstr, msgstr_pos)
+     po_ty *that;
+     char *msgid;
+     lex_pos_ty *msgid_pos;
+     char *msgstr;
+     lex_pos_ty *msgstr_pos;
+{
+  merge_class_ty *this = (merge_class_ty *) that;
+  message_ty *mp;
+  message_variant_ty *mvp;
+  size_t j;
+
+  /* Remember the domain names for later.  */
+  string_list_append_unique (this->domain_list, this->domain);
+
+  /* See if this message ID has been seen before.  */
+  mp = message_list_search (this->mlp, msgid);
+  if (mp)
+    free (msgid);
+  else
+    {
+      mp = message_alloc (msgid);
+      message_list_append (this->mlp, mp);
+    }
+
+  /* Add the accumulated comments to the message.  Clear the
+     accumulation in preparation for the next message.  */
+  if (this->comment != NULL)
+    {
+      for (j = 0; j < this->comment->nitems; ++j)
+	message_comment_append (mp, this->comment->item[j]);
+      string_list_free (this->comment);
+      this->comment = NULL;
+    }
+  if (this->comment_dot != NULL)
+    {
+      for (j = 0; j < this->comment_dot->nitems; ++j)
+	message_comment_dot_append (mp, this->comment_dot->item[j]);
+      string_list_free (this->comment_dot);
+      this->comment_dot = NULL;
+    }
+  for (j = 0; j < this->filepos_count; ++j)
+    {
+      lex_pos_ty *pp;
+
+      pp = &this->filepos[j];
+      message_comment_filepos (mp, pp->file_name, pp->line_number);
+      free (pp->file_name);
+    }
+  mp->is_fuzzy = this->is_fuzzy;
+  mp->is_c_format = this->is_c_format;
+  mp->do_wrap = this->do_wrap;
+
+  if (this->filepos != NULL)
+    free (this->filepos);
+  this->filepos_count = 0;
+  this->filepos = NULL;
+  this->is_fuzzy = 0;
+  this->is_c_format = undecided;
+  this->do_wrap = undecided;
+
+  /* See if this domain has been seen for this message ID.  */
+  mvp = message_variant_search (mp, this->domain);
+  if (mvp)
+    {
+      gram_error_at_line (msgid_pos, _("duplicate message definition"));
+      gram_error_at_line (&mvp->pos, _("\
+...this is the location of the first definition"));
+      free (msgstr);
+    }
+  else
+    message_variant_append (mp, this->domain, msgstr, msgstr_pos);
+}
+
+
+static void
+merge_parse_brief (that)
+     po_ty *that;
+{
+  po_lex_pass_comments (1);
+}
+
+
+static void
+merge_parse_debrief (that)
+     po_ty *that;
+{
+  merge_class_ty *this = (merge_class_ty *) that;
+  message_list_ty *mlp = this->mlp;
+  size_t j;
+
+  /* For each domain in the used-domain-list, make sure each message
+     defines a msgstr in that domain.  */
+  for (j = 0; j < this->domain_list->nitems; ++j)
+    {
+      const char *domain_name;
+      size_t k;
+
+      domain_name = this->domain_list->item[j];
+      for (k = 0; k < mlp->nitems; ++k)
+	{
+	  const message_ty *mp;
+	  size_t m;
+
+	  mp = mlp->item[k];
+	  for (m = 0; m < mp->variant_count; ++m)
+	    {
+	      message_variant_ty *mvp;
+
+	      mvp = &mp->variant[m];
+	      if (strcmp (domain_name, mvp->domain) == 0)
+		break;
+	    }
+	  if (m >= mp->variant_count)
+	    gram_error_at_line (&mp->variant[0].pos, _("\
+this message has no definition in the \"%s\" domain"), domain_name);
+	}
+    }
+}
+
+
+static void
+merge_comment (that, s)
+     po_ty *that;
+     const char *s;
+{
+  merge_class_ty *this = (merge_class_ty *) that;
+
+  if (this->comment == NULL)
+    this->comment = string_list_alloc ();
+  string_list_append (this->comment, s);
+}
+
+
+static void
+merge_comment_dot (that, s)
+     po_ty *that;
+     const char *s;
+{
+  merge_class_ty *this = (merge_class_ty *) that;
+
+  if (this->comment_dot == NULL)
+    this->comment_dot = string_list_alloc ();
+  string_list_append (this->comment_dot, s);
+}
+
+
+static void
+merge_comment_special (that, s)
+     po_ty *that;
+     const char *s;
+{
+  merge_class_ty *this = (merge_class_ty *) that;
+
+  if (strstr (s, "fuzzy") != NULL)
+    this->is_fuzzy = 1;
+
+  this->is_c_format = parse_c_format_description_string (s);
+  this->do_wrap = parse_c_width_description_string (s);
+}
+
+
+static void
+merge_comment_filepos (that, name, line)
+     po_ty *that;
+     const char *name;
+     int line;
+{
+  merge_class_ty *this = (merge_class_ty *) that;
+  size_t nbytes;
+  lex_pos_ty *pp;
+
+  if (!line_comment)
+    return;
+  nbytes = (this->filepos_count + 1) * sizeof (this->filepos[0]);
+  this->filepos = xrealloc (this->filepos, nbytes);
+  pp = &this->filepos[this->filepos_count++];
+  pp->file_name = xstrdup (name);
+  pp->line_number = line;
+}
+
+
+/* So that the one parser can be used for multiple programs, and also
+   use good data hiding and encapsulation practices, an object
+   oriented approach has been taken.  An object instance is allocated,
+   and all actions resulting from the parse will be through
+   invokations of method functions of that object.  */
+
+static po_method_ty merge_methods =
+{
+  sizeof (merge_class_ty),
+  merge_constructor,
+  merge_destructor,
+  merge_directive_domain,
+  merge_directive_message,
+  merge_parse_brief,
+  merge_parse_debrief,
+  merge_comment,
+  merge_comment_dot,
+  merge_comment_filepos,
+  merge_comment_special
+};
+
+
+static message_list_ty *
+grammar (filename)
+     const char *filename;
+{
+  po_ty *pop;
+  message_list_ty *mlp;
+
+  pop = po_alloc (&merge_methods);
+  po_lex_pass_obsolete_entries (1);
+  po_scan (pop, filename);
+  mlp = ((merge_class_ty *) pop)->mlp;
+  po_free (pop);
+  return mlp;
+}
+
+
+#define DOT_FREQUENCE 10
+
+/*
+ * Given two meta files (m,X) and (m,N) generate a po file (N,X)
+ * preserving the meta information in special comments
+ */
+static message_list_ty *
+merge (fn1, fn2)
+     const char *fn1;			/* definitions */
+     const char *fn2;			/* references */
+{
+    message_list_ty *def;
+    message_list_ty *ref;
+    message_ty *defmsg;
+    size_t j, k;
+    size_t merged, fuzzied, missing, obsolete;
+    message_list_ty *result;
+
+    /* This is the definitions file, created by a human.  */
+    def = grammar (fn1);
+
+    /* This is the references file, created by groping the sources with
+     * the xgettext program. */
+    ref = grammar (fn2);
+
+    result = message_list_alloc ();
+
+    /* Every reference must be matched with its definition. */
+    for (j = 0; j < ref->nitems; ++j) {
+	message_ty *refmsg;
+
+	/* Because merging can take a while we print something to signal
+	 * we are not dead. */
+	if (verbosity_level >= 1 && j % DOT_FREQUENCE == 0)
+	    fputc ('.', stderr);
+
+	refmsg = ref->item[j];
+
+	/* See if it is in the other file.  */
+	defmsg = message_list_search (def, refmsg->msgid);
+	if (defmsg) {
+	    /* Merge the reference with the definition: take the #. and
+	       #: comments from the reference, take the # comments from
+	       the definition, take the msgstr from the definition.  Add
+	       this merged entry to the output message list.  */
+	    message_ty *mp = message_join (defmsg, refmsg);
+
+	    if (mp != NULL)
+		message_list_append (result, mp);
+
+	    /* Remember that this message has been used, when we scan
+	       later to see if anything was omitted.  */
+	    defmsg->used = 1;
+	    ++merged;
+	    continue;
+	} else if (useless) {
+	    message_ty *mp;
+	    const char *tmp;
+	    if (verbosity_level > 1)
+		gram_error_at_line (&refmsg->variant[0].pos,
+				    _("this message is used but not defined in %s"),
+				    fn1);
+
+	    /* Insert the blank record */
+	    mp = message_copy (refmsg);
+	    tmp = mp->msgid;
+	    mp->msgid = mp->variant[0].msgstr;
+	    mp->variant[0].msgstr = "";
+	    message_list_append (result, mp);
+	    ++missing;
+	}
+    }
+
+    /* Look for messages in the definition file, which are not present
+       in the reference file, indicating messages which defined but not
+       used in the program.  */
+    if (useless)
+	for (k = 0; k < def->nitems; ++k) {
+	    defmsg = def->item[k];
+	    if (defmsg->used)
+		continue;
+
+	    /* Remember the old translation although it is not used anymore.
+	       But we mark it as obsolete.  */
+	    defmsg->obsolete = 1;
+
+	    message_list_append (result, defmsg);
+	    ++obsolete;
+	}
+
+    /* Report some statistics.  */
+    if (verbosity_level > 0)
+	fprintf (stderr,
+		 _("%sRead %d old + %d reference, merged %d, fuzzied %d, missing %d, obsolete %d.\n"),
+		 verbosity_level >= 1 ? "\n" : "",
+		 def->nitems, ref->nitems, merged, fuzzied, missing, obsolete);
+    else if (verbosity_level > 0)
+	fputs (_(" done.\n"), stderr);
+
+    /* get rid of the duplicate message ids */
+    return un_duplicate(result);
+}
+
+/*
+ * Given two meta files f1 and f2 append to f1 the entries from f2 that
+ * are not found in f1. First f1 is read in, the for each entry in f2 we
+ * try to locate it in f1; if it is not there already we add it.
+ */
+static message_list_ty *
+append (fn1, fn2, diff_only)
+     const char *fn1;			/* base file */
+     const char *fn2;			/* more stuff found in here */
+     int diff_only;			/* do we want only the diffs? */
+{
+    message_list_ty *ml1;
+    message_list_ty *ml2;
+    message_list_ty *result;
+    size_t j;
+    size_t added = 0;
+    int initial;
+	
+    /* This is the definitions file, created by a human.  */
+    ml1 = grammar (fn1);
+    initial = ml1->nitems;
+    
+    /* This is the references file, created by groping the sources with
+     * the xgettext program. */
+    ml2 = grammar (fn2);
+
+    result = message_list_alloc();
+    
+    /* Every reference must be matched with its definition. */
+    for (j = 0; j < ml2->nitems; ++j) {
+	message_ty *oldmsg;
+	message_ty *newmsg;
+	int i;
+	
+	/* Because merging can take a while we print something to signal
+	 * we are not dead. */
+	if (verbosity_level >= 1 && j % DOT_FREQUENCE == 0)
+	    fputc ('.', stderr);
+
+	/* this is the message we want to add */
+	newmsg = ml2->item[j];
+
+	/* See if it is in the other file.  */
+	oldmsg = message_list_search (ml1, newmsg->msgid);
+	if (oldmsg == NULL) { /* not found, stick it in */
+	    message_list_append (result, newmsg);
+	    newmsg->used = 1;
+	    ++added;
+	    continue;
+	} 	
+
+	/* else, if it is found, add the coments from it if we want them */
+	if (comments != 0) {
+	    if (newmsg->comment)
+		for (i = 0; i < newmsg->comment->nitems; ++i)
+		    message_comment_append (oldmsg, newmsg->comment->item[i]);
+	
+	    if (newmsg->comment_dot)
+		for (i = 0; i < newmsg->comment_dot->nitems; ++i)
+		    message_comment_dot_append (oldmsg, newmsg->comment_dot->item[i]);
+	
+	    /* file position comments */
+	    for (i = 0; i < newmsg->filepos_count; ++i) {
+		lex_pos_ty *pp = &newmsg->filepos[i];
+		message_comment_filepos (oldmsg, pp->file_name, pp->line_number);
+	    }
+	}
+	newmsg->used++;
+    }
+
+    /* Report some statistics.  */
+    if (verbosity_level > 0)
+	fprintf (stderr,
+		 _("%sRead %d file1 + %d file2, added %d\n"),
+		 verbosity_level >= 1 ? "\n" : "",
+		 initial, ml2->nitems, added);
+    else if (verbosity_level > 0)
+	fputs (_(" done.\n"), stderr);
+
+    /* do we want only the diffs? */
+    if (diff_only) {
+	return result;
+    }
+    
+    /* append the result to ml1 */
+    for (j = 0; j < result->nitems; ++j)
+	message_list_append(ml1, result->item[j]);
+
+    /* No need to free the result since message_list_alloc copies only the
+       references over */
+    return ml1;
+}
+
+static message_list_ty *
+master (prev, fn, master_id)
+    message_list_ty **prev; 	/* The result of what we had before */
+    const char *fn; 		/* file name */
+    const char *master_id; 	/* what to put as msgstr(master_id) */
+{
+    message_list_ty *list;
+    message_list_ty *result;
+    int j;
+    
+    /* Read in the file */
+    list = grammar (fn);
+
+    if (*prev == NULL)
+	*prev = message_list_alloc ();
+
+    result = *prev; /* Work with that */
+    
+    /* Every reference must be matched with its definition. */
+    for (j = 0; j < list->nitems; ++j) {
+	message_ty *crtmsg, *merge_msg;
+	
+	/* check for  empty message ids == headers */
+	if (list->item[j]->msgid[0] == '\0') {
+	    continue;
+	}
+	
+	if ((list->item[j])->is_fuzzy && (fuzzy == 0)) {
+	    /* we don't want fuzzies */
+	    continue;
+	}
+	
+	crtmsg = message_copy (list->item[j]);
+
+	/* First, search its pair in the result list ... */
+	merge_msg = message_list_search (result, crtmsg->msgid);
+
+	/* Now here is something broken: we get only the msgstr
+	 * from the variant[0] and override its domain with our master_id
+	 */
+	crtmsg->variant_count = 1;
+	crtmsg->variant[0].domain = master_id;
+	
+	if (merge_msg != NULL) {
+	    int variants;
+	    void *temp;
+	    
+	    /* Ah! we have to do a nasty merge */   
+	    variants = ++merge_msg->variant_count;
+	    temp = realloc (merge_msg->variant, variants * sizeof(crtmsg->variant[0]));
+	    if (temp != NULL) {
+		merge_msg->variant = temp;
+	    } else {
+		error (EXIT_FAILURE, 0, "OUT of memory in %s", __FUNCTION__);
+		exit(-1);
+	    }
+	    merge_msg->variant[variants-1] = crtmsg->variant[0];
+	    /* that should be it */
+	} else {
+	    /* this is really simple - just add it */
+	    message_list_append (result, crtmsg);
+	}
+
+	/* Remember that this message has been used, when we scan
+	   later to see if anything was omitted.  */
+	crtmsg->used = 1;
+    }
+
+    return result ; 
+}
+
+static message_list_ty *
+invert (fn)
+    const char *fn; /* file name */
+{
+    message_list_ty *list;
+    size_t j;
+    size_t inverted = 0;
+    message_list_ty *result;
+
+    /* Read in the file */
+    list = grammar (fn);
+
+    result = message_list_alloc ();
+
+    /* Every reference must be matched with its definition. */
+    for (j = 0; j < list->nitems; ++j) {
+	message_ty *crtmsg;
+	int k;
+	
+	/* check for  empty message ids == headers */
+	if (list->item[j]->msgid[0] == '\0') {
+	    message_list_append (result, list->item[j]);
+	    continue;
+	}
+	
+	crtmsg = message_copy (list->item[j]);
+
+	/*
+	 * Now invert it. For each domain found in the file we create a record
+	 * containing the inverted pair
+	 */
+	for (k = 0; k < crtmsg->variant_count; k++) {
+	    message_ty *mp;
+	    const char *tmp;
+	    
+	    mp = message_copy(crtmsg);
+	    mp->variant_count = 1;
+	    tmp = mp->msgid;    
+	    mp->msgid = crtmsg->variant[k].msgstr;
+	    mp->variant[0] = crtmsg->variant[k];
+	    mp->variant[0].msgstr = tmp;
+	    message_list_append (result, mp);
+	    ++inverted;
+	}
+
+	/* Remember that this message has been used, when we scan
+	   later to see if anything was omitted.  */
+	crtmsg->used = 1;
+    }
+
+    /* get rid of the duplicate message ids */
+    return un_duplicate(result);
+}
+
+static message_list_ty *
+missing (fn)
+    const char *fn; /* file name */
+{
+    message_list_ty *list;
+    size_t j;
+    message_list_ty *result;
+
+    /* Read in the file */
+    list = grammar (fn);
+
+    result = message_list_alloc ();
+
+    /* Every reference must be matched with its definition. */
+    for (j = 0; j < list->nitems; ++j) {
+	int k;
+	
+	/* check for  empty message ids == headers */
+	if (list->item[j]->msgid[0] == '\0') {
+	    message_list_append (result, list->item[j]);
+	    continue;
+	}
+	
+	/* Fuzzies go in */
+	if (list->item[j]->is_fuzzy) {
+	    message_list_append (result, list->item[j]);
+	    continue;
+	}
+
+	/* Check for empty translations */
+	for (k = 0; k < list->item[j]->variant_count; k++) {
+	    if (strlen(list->item[j]->variant[k].msgstr) <= 1) {
+		message_list_append (result, list->item[j]);
+		break;
+	    }
+	}
+
+	/* Remember that this message has been used, when we scan
+	   later to see if anything was omitted.  */
+	list->item[j]->used = 1;
+    }
+    return result;
+}
+
+static message_list_ty *
+un_duplicate (dup_list)
+    message_list_ty *dup_list; /* list containing duplicates */
+{
+    message_list_ty *result;
+    size_t j;    
+
+    result = message_list_alloc ();
+     
+    /* First iteration, clear the used flag */
+    for (j = 0; j < dup_list->nitems; ++j)
+	dup_list->item[j]->used = 0;
+    
+    /* This is a cheesy O(n^2) dupe elimination "algorithm"
+     * One day I will replace it by a quicksort() followed by
+     * a walk through the whole list one more time and that will bring
+     * it down to O(n log(n)) */
+    for (j = 0; j < dup_list->nitems; ++j) {
+	message_ty *crtmsg;
+	size_t k;
+		
+	/* get the current message */
+	crtmsg = dup_list->item[j];
+
+	if (crtmsg->used > 0)
+	    continue;
+	
+	for (k = j + 1; k < dup_list->nitems; ++k) {
+	    message_ty *newmsg;
+	    size_t i;
+	    
+	    newmsg = dup_list->item[k];
+	
+	    if (strcmp(crtmsg->msgid, newmsg->msgid) != 0 ||
+		newmsg->used > 0)
+		continue;
+	    
+	    if (newmsg->comment)
+		for (i = 0; i < newmsg->comment->nitems; ++i)
+		    message_comment_append (crtmsg, newmsg->comment->item[i]);
+	    
+	    if (newmsg->comment_dot)
+		for (i = 0; i < newmsg->comment_dot->nitems; ++i)
+		    message_comment_dot_append (crtmsg, newmsg->comment_dot->item[i]);
+
+	    /* file position comments */
+	    for (i = 0; i < newmsg->filepos_count; ++i) {
+		lex_pos_ty *pp = &newmsg->filepos[i];
+		message_comment_filepos (crtmsg, pp->file_name, pp->line_number);
+	    }
+	
+	    fprintf(stderr, "%05d : %05d\r", j, k);
+	    /* Now mark it as used */    
+	    newmsg->used++;
+	}
+
+	/* Now put the resulting entry on the final list */
+	message_list_append (result, crtmsg);
+    }
+    
+    return result;
+    
+}
+	
+message_ty *
+message_join (def, ref)
+    message_ty *def;
+    message_ty *ref;
+{
+    message_ty *result;
+    size_t j;
+    char *meta_comment;
+    
+    /* is this the header ? */
+    if (ref->msgid[0] == '\0') {
+	result = message_copy(ref);
+	return result;
+    };
+    
+
+    /* XXX: FIX ME!!!
+     * We are not processing in any way the variant list at this time.
+     * We assume blindly that joining two pairs onn variant[0] will yield
+     * the correct result
+     */
+
+    /* here it goes: (m,X) join m(m,N) = (N,X) */
+    result = message_copy(def);
+    /* here we should be looping over all domains */
+    result->msgid = ref->variant[0].msgstr;
+    
+    if (!useless) {
+	/* Trim down on crap translations */    
+	if (result->variant[0].msgstr == NULL)
+	    return NULL;
+	if (strlen(result->variant[0].msgstr) == 0)
+	    return NULL;
+	if (strcmp(result->msgid, result->variant[0].msgstr) == 0)
+	    return NULL;
+    }
+    	    
+    /* Take the comments from the definition file.  There will be none at
+     * all in the reference file, as it was generated by xgettext.
+     */
+    /* we don't do that here because result is already initialized from def
+       --cristiang */
+    /*if (def->comment) */
+    /* 	for (j = 0; j < def->comment->nitems; ++j) */
+    /* 	    message_comment_append (result, def->comment->item[j]); */
+
+    /* now add the meta information for the common join field */
+    j = strlen(ref->msgid) + 10;
+    meta_comment = alloca(j);
+    if (meta_comment != NULL) {
+	snprintf(meta_comment, j, "meta=%s", ref->msgid); /* should be safe */
+	message_comment_append(result, meta_comment);
+    } else {
+	message_comment_append(result, "meta=ERROR!!!");
+	message_comment_append(result, ref->msgid);
+    }
+
+    /* Take the dot comments from the reference file, as they are
+       generated by xgettext.  Any in the definition file are old ones
+       collected by previous runs of xgettext and msgmerge.  */
+    if (ref->comment_dot)
+	for (j = 0; j < ref->comment_dot->nitems; ++j)
+	    message_comment_dot_append (result, ref->comment_dot->item[j]);
+
+/*     message_comment_dot_append(result, "this is my test"); */
+    /* The flags are mixed in a special way.  Some informations come
+       from the reference message (such as format/no-format), others
+       come from the definition file (fuzzy or not).  */
+    result->is_fuzzy = def->is_fuzzy;
+    result->is_c_format = ref->is_c_format;
+    result->do_wrap = ref->do_wrap;
+
+    /* Take the file position comments from the reference file, as they
+       are generated by xgettext.  Any in the definition file are old ones
+       collected by previous runs of xgettext and msgmerge.  */
+    for (j = 0; j < ref->filepos_count; ++j) {
+	lex_pos_ty *pp = &ref->filepos[j];
+	message_comment_filepos (result, pp->file_name, pp->line_number);
+    }
+
+    /* All done, return the merged message to the caller.  */
+    return result;
+}
+
+static message_list_ty *
+split (fn, flag)
+    const char *fn; /* file name */
+    int flag; 	    /* what should we be splitting out */
+{
+    message_list_ty *list;
+    size_t j;
+    message_list_ty *result;
+
+    /* Read in the file */
+    list = grammar (fn);
+
+    result = message_list_alloc ();
+
+    /* Every reference must be matched with its definition. */
+    for (j = 0; j < list->nitems; ++j) {
+	message_ty *crtmsg;
+	
+	/* get the current message */
+	crtmsg = message_copy (list->item[j]);
+
+	/* search all comments looking for our meta= */
+	if (crtmsg->comment) {
+	    int k;
+	    for (k = 0; k < crtmsg->comment->nitems; ++k) {
+		char *tmp;
+
+		tmp = strstr(crtmsg->comment->item[k], "meta=");
+		if (tmp != NULL) { /* found it */
+		    message_ty *res;
+		    int i;
+		    message_variant_ty *mvp = NULL;
+
+		    res = message_alloc(xstrdup(tmp+5));
+		    res->variant_count = 1;
+		    mvp = malloc(sizeof(struct message_variant_ty));
+		    if (mvp == NULL) {
+			error (EXIT_FAILURE, 0, _("Weird out of memory situation"));
+			usage (EXIT_FAILURE);
+		    }
+		    *mvp = crtmsg->variant[0];
+		    res->variant = mvp;
+		    switch(flag) {
+			case SPLIT_MSGID:
+			    res->variant[0].msgstr = crtmsg->msgid;
+			    /* transport over all the dot  comments */
+			    if (crtmsg->comment_dot)
+				for (i = 0; i < crtmsg->comment_dot->nitems; ++i)
+				    message_comment_dot_append(res, crtmsg->comment_dot->item[i]);
+			    break;
+			case SPLIT_MSGSTR:
+			    res->variant[0].msgstr = crtmsg->variant[0].msgstr;
+			    /* transport over the comments with the exception of
+			       the dot comments and the meta= one */
+			    for (i = 0; i < crtmsg->comment->nitems; ++i)
+				if (i != k)
+				    message_comment_append(res, crtmsg->comment->item[i]);
+			    break;
+			default:
+			    error (EXIT_SUCCESS, 0, _("Unknwon split mode"));
+			    usage (EXIT_FAILURE);
+		    }
+		    message_list_append (result, res);
+		}
+	    }
+	} else {
+	    /* we have no meta comment on this one */
+	    continue;
+	}
+    }	
+    return result;
+}
+
+static message_list_ty *
+explode (fn, flag)
+    const char *fn; /* file name */
+    int flag; 	    /* what should we be splitting out */
+{
+    message_list_ty *list;
+    size_t j;
+    message_list_ty *result;
+
+    /* Read in the file */
+    list = grammar (fn);
+
+    result = message_list_alloc ();
+
+    /* Every reference ... */
+    for (j = 0; j < list->nitems; ++j) {
+	message_ty *crtmsg;
+	int k;
+	
+	/* Get the current message */
+	crtmsg = message_copy (list->item[j]);
+
+	/* Every "conformant" cross reference ... */
+	for (k = 0; k < crtmsg->filepos_count; ++k) {
+	    lex_pos_ty *pp;
+	    char buf[1024];
+	    const char *fn, *tn;
+	    const char *f, *fe;
+	    int ln;
+	    message_ty *res;
+	    int i;
+	    message_variant_ty *mvp = NULL;
+
+	    pp = &crtmsg->filepos[k];
+	    fn = pp->file_name;
+	    ln = pp->line_number;
+
+	    switch(ln) {
+		default:
+		    tn = NULL;
+		    break;
+		case 1004:
+		    tn = "(Summary)";
+		    break;
+		case 1005:
+		    tn = "(Description)";
+		    break;
+		case 1016:
+		    tn = "(Group)";
+		    break;
+	    }
+
+	    /* ... weird tags we do not want */
+	    if (tn == NULL)
+		continue;
+
+	    /* Find the text after the name-version-release */
+	    if ((f = strrchr(fn, '-')) == NULL ||
+		(fe = strchr(f, '.')) == NULL) {
+		fprintf(stderr, _("skipping malformed xref \"%s\"\n"), fn);
+		continue;
+	    }
+	    fe = fn + strlen(fn) - sizeof(".src.rpm") + 1;
+
+	    /* ... src.rpm's we do not want */
+	    if ( !strcmp(fe, ".src.rpm") )
+		continue;
+
+	    /* Position at end of name */
+	    fe = strrchr(fn, '-') - 1;
+	    while (fe > fn && *fe != '-')
+		--fe;
+
+	    /* Construct meta tag */
+	    strncpy(buf, fn, (fe-fn) );
+	    buf[fe-fn] = '\0';
+	    strncat(buf, tn, (sizeof(buf) - strlen(buf)) );
+
+	    res = message_alloc(xstrdup(buf));
+	    res->variant_count = 1;
+	    mvp = malloc(sizeof(struct message_variant_ty));
+	    if (mvp == NULL) {
+		error (EXIT_FAILURE, 0, _("Weird out of memory situation"));
+		usage (EXIT_FAILURE);
+	    }
+	    *mvp = crtmsg->variant[0];
+	    res->variant = mvp;
+	    switch(flag) {
+		case EXPLODE_MSGID:
+		    res->variant[0].msgstr = crtmsg->msgid;
+		    /* transport over all the dot  comments */
+		    if (crtmsg->comment_dot)
+			for (i = 0; i < crtmsg->comment_dot->nitems; ++i)
+			    message_comment_dot_append(res, crtmsg->comment_dot->item[i]);
+		    break;
+		case EXPLODE_MSGSTR:
+		    res->variant[0].msgstr = crtmsg->variant[0].msgstr;
+#if 0
+		    /* transport over the comments with the exception of
+		       the dot comments */
+		    for (i = 0; i < crtmsg->comment->nitems; ++i)
+			message_comment_append(res, crtmsg->comment->item[i]);
+#endif
+		    break;
+		default:
+		    error (EXIT_SUCCESS, 0, _("Unknwon explode mode"));
+		    usage (EXIT_FAILURE);
+	    }
+	    message_list_append (result, res);
+	}
+    }	
+    return result;
+}
+
+static message_list_ty *
+empty (fn)
+    const char *fn; /* file name */
+{
+    message_list_ty *list;
+    size_t j;
+    int had_header = 0;
+    message_list_ty *result;
+
+    /* Read in the file */
+    list = grammar (fn);
+
+    result = message_list_alloc ();
+
+    /* Every reference must be matched with its definition. */
+    for (j = 0; j < list->nitems; ++j) {
+	if (list->item[j]->msgid[0] == '\0') {
+	    had_header++;
+	    break;
+	}
+    }
+
+    /* If we don't have a header, we should try to add one */
+    if (!had_header)
+	message_list_append (result, new_header());
+
+    /* time to add the rest */
+    for (j = 0; j < list->nitems; ++j) {
+	message_ty *crtmsg;
+    
+	crtmsg = list->item[j];
+	if (crtmsg->msgid[0] != '\0') {
+	    /* empty the translations */
+	    crtmsg->variant_count = 1;
+	    crtmsg->variant[0].msgstr = "";
+	}
+	crtmsg->used = 1;
+	message_list_append (result, crtmsg);
+    }
+    return result;
+}
+
+static message_list_ty *
+dummy (fn)
+    const char *fn; /* file name */
+{
+    message_list_ty *list;
+    size_t j;
+    int had_header = 0;
+    message_list_ty *result;
+
+    /* Read in the file */
+    list = grammar (fn);
+
+    result = message_list_alloc ();
+
+    /* Every reference must be matched with its definition. */
+    for (j = 0; j < list->nitems; ++j) {
+	if (list->item[j]->msgid[0] == '\0') {
+	    had_header++;
+	    break;
+	}
+    }
+
+    /* If we don't have a header, we should try to add one */
+    if (!had_header)
+	message_list_append (result, new_header());
+
+    /* time to add the rest */
+    for (j = 0; j < list->nitems; ++j) {
+	message_ty *crtmsg;
+    
+	crtmsg = list->item[j];
+	if (crtmsg->msgid[0] != '\0') {
+	    /* dummy translation */
+	    crtmsg->variant_count = 1;
+	    crtmsg->variant[0].msgstr = crtmsg->msgid;
+	}
+	crtmsg->used = 1;
+	message_list_append (result, crtmsg);
+    }
+    return result;
+}
+
+#define TM_YEAR_ORIGIN 1900
+static struct message_ty *
+new_header(void)
+{    
+	time_t now;
+	struct tm local_time;
+	message_ty *mp;
+	char *msgstr;
+	static lex_pos_ty pos = { __FILE__, __LINE__, };
+	
+	mp = message_alloc ("");
+	if (mp == NULL)
+	    return NULL;
+	
+	message_comment_append (mp, "\
+SOME DESCRIPTIVE TITLE.\n\
+FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.\n");
+
+	time (&now);
+	local_time = *localtime (&now);
+
+	asprintf (&msgstr, "\
+Project-Id-Version: PACKAGE VERSION\n\
+POT-Creation-Date: %d-%02d-%02d %02d:%02d\n\
+PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n\
+Last-Translator: FULL NAME <EMAIL@ADDRESS>\n\
+Language-Team: LANGUAGE <LL@li.org>\n\
+MIME-Version: 1.0\n\
+Content-Type: text/plain; charset=CHARSET\n\
+Content-Transfer-Encoding: ENCODING\n",
+		  local_time.tm_year + TM_YEAR_ORIGIN,
+		  local_time.tm_mon + 1,
+		  local_time.tm_mday,
+		  local_time.tm_hour,
+		  local_time.tm_min);
+
+	if (msgstr == NULL)
+	    error(EXIT_FAILURE, errno, _("while preparing output"));
+	message_variant_append (mp, MESSAGE_DOMAIN_DEFAULT, msgstr, &pos);
+	return mp;
+}

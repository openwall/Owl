--- fileutils-4.0/src/mv.c	Fri Sep 22 18:28:55 2000
+++ fileutils-4.0/src/mv.c	Sun Oct 01 19:00:13 2000
@@ -280,6 +280,8 @@
   int dest_had_trailing_slash = strip_trailing_slashes_2 (dest);
   int fail;
 
+  struct stat st_src, st_dst;
+
   /* This code was introduced to handle the ambiguity in the semantics
      of mv that is induced by the varying semantics of the rename function.
      Some systems (e.g., Linux) have a rename function that honors a
@@ -290,12 +292,34 @@
   if (remove_trailing_slashes)
     strip_trailing_slashes_2 (source);
 
+  /*
+   * first check that we are not moving something onto itself. It is
+   * easier to do it here since no matter how you do it you can not move
+   * a file onto itself --gafton
+   */
+  fail = lstat(source, &st_src);
+  if (fail != 0)
+      error(1, 0, "can't stat source %s", source);
+  fail = lstat(dest, &st_dst);
+  /*
+   * don't bail if second stat fails. We could be renaming it. --notting
+   */
+  /* Now check that we are dealing with the same thing */
+  if (fail == 0 && st_src.st_dev == st_dst.st_dev &&
+      st_src.st_ino == st_dst.st_ino) {
+      /* Damn, it's the same */
+      error(0, 0, "Can't move %s into itself", source);
+      return 1;
+  }
+
   /* In addition to when DEST is a directory, if DEST has a trailing
      slash and neither SOURCE nor DEST is a directory, presume the target
      is DEST/`basename source`.  This converts `mv x y/' to `mv x y/x'.
      This change means that the command `mv any file/' will now fail
      rather than performing the move.  The case when SOURCE is a
      directory and DEST is not is properly diagnosed by do_move.  */
+
+  /* --but this is detected earlier anyway --gafton */
 
   if (dest_is_dir || (dest_had_trailing_slash && !is_real_dir (source)))
     {

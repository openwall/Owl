diff -urNp nmap-3.48.orig/Makefile.in nmap-3.48/Makefile.in
--- nmap-3.48.orig/Makefile.in	Mon Oct  6 08:23:20 2003
+++ nmap-3.48/Makefile.in	Sun Oct 26 16:43:20 2003
@@ -40,11 +40,11 @@ TARGET = nmap
 TARGETNMAPFE=@TARGETNMAPFE@
 INSTALLNMAPFE=@INSTALLNMAPFE@
 
-SRCS = main.cc nmap.cc targets.cc tcpip.cc nmap_error.cc utils.cc idle_scan.cc osscan.cc output.cc scan_engine.cc timing.cc charpool.cc services.cc protocols.cc nmap_rpc.cc portlist.cc NmapOps.cc TargetGroup.cc Target.cc FingerPrintResults.cc service_scan.cc NmapOutputTable.cc @COMPAT_SRCS@
+SRCS = main.cc nmap.cc targets.cc tcpip.cc nmap_error.cc utils.cc idle_scan.cc osscan.cc output.cc scan_engine.cc timing.cc charpool.cc services.cc protocols.cc nmap_rpc.cc portlist.cc droppriv.cc NmapOps.cc TargetGroup.cc Target.cc FingerPrintResults.cc service_scan.cc NmapOutputTable.cc @COMPAT_SRCS@
 
-OBJS = main.o nmap.o targets.o tcpip.o nmap_error.o utils.o idle_scan.o osscan.o output.o scan_engine.o timing.o charpool.o services.o protocols.o nmap_rpc.o portlist.o NmapOps.o TargetGroup.o Target.o FingerPrintResults.o service_scan.o NmapOutputTable.o @COMPAT_OBJS@
+OBJS = main.o nmap.o targets.o tcpip.o nmap_error.o utils.o idle_scan.o osscan.o output.o scan_engine.o timing.o charpool.o services.o protocols.o nmap_rpc.o portlist.o droppriv.o NmapOps.o TargetGroup.o Target.o FingerPrintResults.o service_scan.o NmapOutputTable.o @COMPAT_OBJS@
 
-DEPS = nmap.h nmap_amigaos.h nmap_error.h targets.h idle_scan.h osscan.h output.h scan_engine.h timing.h tcpip.h utils.h global_structures.h charpool.h services.h protocols.h nmap_rpc.h portlist.h NmapOps.h TargetGroup.h Target.h FingerPrintResults.h service_scan.h NmapOutputTable.h
+DEPS = nmap.h nmap_amigaos.h nmap_error.h targets.h idle_scan.h osscan.h output.h scan_engine.h timing.h tcpip.h utils.h global_structures.h charpool.h services.h protocols.h nmap_rpc.h portlist.h droppriv.h NmapOps.h TargetGroup.h Target.h FingerPrintResults.h service_scan.h NmapOutputTable.h
 
 # %.o : %.cc -- nope this is a GNU extension
 .cc.o:
diff -urNp nmap-3.48.orig/droppriv.cc nmap-3.48/droppriv.cc
--- nmap-3.48.orig/droppriv.cc	Thu Jan  1 00:00:00 1970
+++ nmap-3.48/droppriv.cc	Sun Oct 26 16:48:46 2003
@@ -0,0 +1,73 @@
+#include <stdlib.h>
+#include <error.h>
+#include <errno.h>
+#include <unistd.h>
+#include <pwd.h>
+#include <grp.h>
+#include <sys/capability.h>
+#include <sys/prctl.h>
+
+#include "nmap.h"
+#include "droppriv.h"
+#include "NmapOps.h"
+
+#define NMAP_USER "nmap"
+#define NMAP_CHROOT_EMPTY "/var/empty"
+
+extern NmapOps o;  /* option structure */
+
+void
+drop_priv (void)
+{
+	const char *user = NMAP_USER;
+	const char *dir = NMAP_CHROOT_EMPTY;
+	struct passwd *pw;
+	cap_t   caps;
+
+	if (geteuid())
+		return;
+
+	nmap_services_init();
+	nmap_protocols_init();
+	rpc_services_init();
+	service_scan_init();
+	routethrough_init();
+
+	if (setgroups (0, NULL) < 0)
+		error (EXIT_FAILURE, errno, "setgroups failed");
+
+	if (prctl (PR_SET_KEEPCAPS, 1))
+		error (EXIT_FAILURE, errno, "prctl (PR_SET_KEEPCAPS, 1) failed");
+
+	pw = getpwnam (user);
+	if (!pw)
+		error (EXIT_FAILURE, 0,
+		       "lookup of user \"%s\" failed", user);
+	endpwent ();
+
+	if (!pw->pw_uid)
+		error (EXIT_FAILURE, 0,
+		       "user \"%s\" shouldn't be root", user);
+
+	if (o.noresolve)
+	if (chroot (dir) < 0 || chdir ("/") < 0)
+		error (EXIT_FAILURE, errno, "chroot to \"%s\" failed", dir);
+
+	if (setgid (pw->pw_gid) < 0)
+		error (EXIT_FAILURE, errno, "setgid failed");
+
+	if (seteuid (pw->pw_uid) < 0)
+		error (EXIT_FAILURE, errno, "seteuid failed");
+
+	caps = cap_from_text ("cap_net_raw=ep");
+	if (!caps)
+		error (EXIT_FAILURE, errno, "cap_from_text failed");
+
+	if (cap_set_proc (caps) < 0)
+		error (EXIT_FAILURE, errno, "cap_set_proc failed");
+
+	cap_free (caps);
+
+	if (setreuid (pw->pw_uid, pw->pw_uid) < 0)
+		error (EXIT_FAILURE, errno, "setreuid failed");
+}
diff -urNp nmap-3.48.orig/droppriv.h nmap-3.48/droppriv.h
--- nmap-3.48.orig/droppriv.h	Thu Jan  1 00:00:00 1970
+++ nmap-3.48/droppriv.h	Sun Oct 26 16:43:20 2003
@@ -0,0 +1,14 @@
+#ifndef NMAP_DROPPRIV_H__
+#define NMAP_DROPPRIV_H__
+
+class AllProbes;
+
+extern void drop_priv(void);
+extern int nmap_services_init(void);
+extern int nmap_protocols_init(void);
+extern void rpc_services_init(void);
+extern AllProbes *service_scan_init(void);
+extern void routethrough_init(void);
+
+#endif /* NMAP_DROPPRIV_H__ */
+
diff -urNp nmap-3.48.orig/nmap.cc nmap-3.48/nmap.cc
--- nmap-3.48.orig/nmap.cc	Sat Sep 20 09:03:00 2003
+++ nmap-3.48/nmap.cc	Sun Oct 26 16:43:20 2003
@@ -90,6 +90,7 @@
 #include "scan_engine.h"
 #include "idle_scan.h"
 #include "timing.h"
+#include "droppriv.h"
 #include "NmapOps.h"
 
 /* global options */
@@ -738,6 +739,8 @@ int nmap_main(int argc, char *argv[]) {
       ports = getdefaultports(o.TCPScan(), o.UDPScan());
     }
   }
+
+  drop_priv();
 
   /* By now, we've got our port lists.  Give the user a warning if no 
    * ports are specified for the type of scan being requested.  Other things
diff -urNp nmap-3.48.orig/nmap_rpc.cc nmap-3.48/nmap_rpc.cc
--- nmap-3.48.orig/nmap_rpc.cc	Sat Sep 20 09:03:00 2003
+++ nmap-3.48/nmap_rpc.cc	Sun Oct 26 16:43:20 2003
@@ -88,10 +88,10 @@
 
 
 #include "nmap_rpc.h"
+#include "droppriv.h"
 #include "NmapOps.h"
 
 extern NmapOps o;
-static int services_initialized = 0;
 static struct rpc_info ri;
 static int udp_rpc_socket = -1;
 static int tcp_rpc_socket = -1;
@@ -103,13 +103,17 @@ static unsigned long rpc_xid_base = (uns
 static size_t tcp_readlen=0; /* used in get_rpc_results but can be reset in 
 			    send_rpc_query */
 
-static void rpc_services_init() {
+void rpc_services_init() {
+  static int services_initialized = 0;
   char filename[512];
   FILE *fp;
   char *tmpptr, *p;
   char line[1024];
   int lineno = 0;
 
+  if (services_initialized)
+    return;
+
   services_initialized = 1;
   ri.num_alloc = 256;
   ri.num_used = 0;
@@ -167,9 +171,7 @@ static void rpc_services_init() {
 char *nmap_getrpcnamebynum(unsigned long num) {
   int i;
 
-  if (!services_initialized) {
-    rpc_services_init();
-  }
+  rpc_services_init();
 
   for(i=0; i < ri.num_used; i++) {
     if (ri.numbers[i] == num)
@@ -179,9 +181,7 @@ char *nmap_getrpcnamebynum(unsigned long
 }
 
 int get_rpc_procs(unsigned long **programs, unsigned long *num_programs) {
-  if (!services_initialized) {
-    rpc_services_init();
-  }
+  rpc_services_init();
   
   *programs = ri.numbers;
   *num_programs = ri.num_used;
diff -urNp nmap-3.48.orig/protocols.cc nmap-3.48/protocols.cc
--- nmap-3.48.orig/protocols.cc	Thu Sep 11 02:12:57 2003
+++ nmap-3.48/protocols.cc	Sun Oct 26 16:43:20 2003
@@ -85,14 +85,15 @@
 /* $Id: protocols.cc,v 1.8 2003/09/11 02:12:57 fyodor Exp $ */
 
 #include "protocols.h"
+#include "droppriv.h"
 #include "NmapOps.h"
 
 extern NmapOps o;
-static int protocols_initialized = 0;
 static int numipprots = 0;
 static struct protocol_list *protocol_table[PROTOCOL_TABLE_SIZE];
 
-static int nmap_protocols_init() {
+int nmap_protocols_init() {
+  static int protocols_initialized = 0;
   char filename[512];
   FILE *fp;
   char protocolname[128];
@@ -103,6 +104,9 @@ static int nmap_protocols_init() {
   struct protocol_list *current, *previous;
   int res;
 
+  if (protocols_initialized)
+      return 0;
+
   if (nmap_fetchfile(filename, sizeof(filename), "nmap-protocols") == -1) {
     error("Unable to find nmap-protocols!  Resorting to /etc/protocol");
     strcpy(filename, "/etc/protocols");
@@ -164,9 +168,8 @@ static int nmap_protocols_init() {
 struct protoent *nmap_getprotbynum(int num) {
   struct protocol_list *current;
 
-  if (!protocols_initialized)
-    if (nmap_protocols_init() == -1)
-      return NULL;
+  if (nmap_protocols_init() == -1)
+    return NULL;
 
   for(current = protocol_table[num % PROTOCOL_TABLE_SIZE];
       current; current = current->next) {
@@ -187,9 +190,8 @@ struct scan_lists *getdefaultprots(void)
   int bucket;
   int protsneeded = 256;
 
-  if (!protocols_initialized)
-    if (nmap_protocols_init() == -1)
-      fatal("getdefaultprots(): Couldn't get protocol numbers");
+  if (nmap_protocols_init() == -1)
+    fatal("getdefaultprots(): Couldn't get protocol numbers");
   
   scanlist = (struct scan_lists *) safe_zalloc(sizeof(struct scan_lists));
   scanlist->prots = (unsigned short *) safe_zalloc((protsneeded) * sizeof(unsigned short));
@@ -209,9 +211,8 @@ struct scan_lists *getfastprots(void) {
   int bucket;
   int protsneeded = 0;
 
-  if (!protocols_initialized)
-    if (nmap_protocols_init() == -1)
-      fatal("Getfastprots: Couldn't get protocol numbers");
+  if (nmap_protocols_init() == -1)
+    fatal("Getfastprots: Couldn't get protocol numbers");
   
   memset(usedprots, 0, sizeof(usedprots));
 
diff -urNp nmap-3.48.orig/service_scan.cc nmap-3.48/service_scan.cc
--- nmap-3.48.orig/service_scan.cc	Mon Oct  6 08:24:35 2003
+++ nmap-3.48/service_scan.cc	Sun Oct 26 16:43:20 2003
@@ -1021,7 +1021,7 @@ void parse_nmap_service_probe_file(AllPr
 
 // Parses the nmap-service-probes file, and adds each probe to
 // the already-created 'probes' vector.
-void parse_nmap_service_probes(AllProbes *AP) {
+static void parse_nmap_service_probes(AllProbes *AP) {
   char filename[256];
 
   if (nmap_fetchfile(filename, sizeof(filename), "nmap-service-probes") == -1){
@@ -1890,10 +1890,23 @@ int launchSomeServiceProbes(nsock_pool n
 }
 
 
+AllProbes *service_scan_init(void)
+{
+  static AllProbes *AP;
+
+  if (!AP) {
+    AP = new AllProbes();
+    parse_nmap_service_probes(AP);
+  }
+
+  return AP;
+}
+
+
 /* Execute a service fingerprinting scan against all open ports of the
    targets[] specified. */
 int service_scan(Target *targets[], int num_targets) {
-  static AllProbes *AP;
+  AllProbes *AP;
   ServiceGroup *SG;
   nsock_pool nsp;
   struct timeval now;
@@ -1909,10 +1922,7 @@ int service_scan(Target *targets[], int 
   if (targets[0]->timedout)
     return 1;
 
-  if (!AP) {
-    AP = new AllProbes();
-    parse_nmap_service_probes(AP);
-  }
+  AP = service_scan_init();
 
   // Now I convert the targets into a new ServiceGroup
   SG = new ServiceGroup(targets, num_targets, AP);
diff -urNp nmap-3.48.orig/services.cc nmap-3.48/services.cc
--- nmap-3.48.orig/services.cc	Sat Sep 13 04:19:55 2003
+++ nmap-3.48/services.cc	Sun Oct 26 16:43:20 2003
@@ -85,15 +85,16 @@
 /* $Id: services.cc,v 1.12 2003/09/13 04:19:55 fyodor Exp $ */
 
 #include "services.h"
+#include "droppriv.h"
 #include "NmapOps.h"
 
 extern NmapOps o;
-static int services_initialized = 0;
 static int numtcpports = 0;
 static int numudpports = 0;
 static struct service_list *service_table[SERVICE_TABLE_SIZE];
 
-static int nmap_services_init() {
+int nmap_services_init() {
+  static int services_initialized = 0;
   char filename[512];
   FILE *fp;
   char servicename[128], proto[16];
@@ -104,6 +105,9 @@ static int nmap_services_init() {
   struct service_list *current, *previous;
   int res;
 
+  if (services_initialized)
+    return 0;
+
   if (nmap_fetchfile(filename, sizeof(filename), "nmap-services") == -1) {
 #ifndef WIN32
     error("Unable to find nmap-services!  Resorting to /etc/services");
@@ -201,9 +205,8 @@ static int nmap_services_init() {
 struct servent *nmap_getservbyport(int port, const char *proto) {
   struct service_list *current;
 
-  if (!services_initialized)
-    if (nmap_services_init() == -1)
-      return NULL;
+  if (nmap_services_init() == -1)
+    return NULL;
 
   for(current = service_table[port % SERVICE_TABLE_SIZE];
       current; current = current->next) {
@@ -229,9 +232,8 @@ struct scan_lists *getdefaultports(int t
   int tcpportsneeded = 0;
   int udpportsneeded = 0;
 
-  if (!services_initialized)
-    if (nmap_services_init() == -1)
-      fatal("Getfastports: Couldn't get port numbers");
+  if (nmap_services_init() == -1)
+    fatal("Getfastports: Couldn't get port numbers");
   
   usedports = (u8 *) safe_zalloc(sizeof(*usedports) * 65536);
 
@@ -293,9 +295,8 @@ struct scan_lists *getfastports(int tcps
   int tcpportsneeded = 0;
   int udpportsneeded = 0;
 
-  if (!services_initialized)
-    if (nmap_services_init() == -1)
-      fatal("Getfastports: Couldn't get port numbers");
+  if (nmap_services_init() == -1)
+    fatal("Getfastports: Couldn't get port numbers");
   
   usedports = (u8 *) safe_zalloc(sizeof(*usedports) * 65536);
 
diff -urNp nmap-3.48.orig/tcpip.cc nmap-3.48/tcpip.cc
--- nmap-3.48.orig/tcpip.cc	Sat Sep 20 09:03:00 2003
+++ nmap-3.48/tcpip.cc	Sun Oct 26 16:43:20 2003
@@ -116,6 +116,7 @@ extern unsigned short flt_baseport;
 #include "mswin32/winip/winip.h"
 
 #include "pcap-int.h"
+#include "droppriv.h"
 
 void nmapwin_init();
 void nmapwin_cleanup();
@@ -1757,6 +1758,13 @@ struct interface_info *getinterfaces(int
 }
 #endif
 
+static FILE *routez;
+
+void routethrough_init(void)
+{
+    if (!routez)
+        routez = fopen("/proc/net/route", "r");
+}
 
 /* An awesome function to determine what interface a packet to a given
    destination should be routed through.  It returns NULL if no appropriate
@@ -1784,7 +1792,6 @@ char *routethrough(const struct in_addr 
   char *p, *endptr;
   char iface[64];
   static int numroutes = 0;
-  FILE *routez;
 
   if (!dest) fatal("routethrough passed a NULL dest address");
 
@@ -1795,7 +1802,7 @@ char *routethrough(const struct in_addr 
     myroutes_capacity = 64;
     myroutes = (struct myroute *) safe_malloc((sizeof(struct myroute) * myroutes_capacity));
     /* Now we must go through several techniques to determine info */
-    routez = fopen("/proc/net/route", "r");
+    routethrough_init();
 
     if (routez) {
       /* OK, linux style /proc/net/route ... we can handle this ... */

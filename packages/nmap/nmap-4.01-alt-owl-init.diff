diff -upk.orig nmap-4.01.orig/MACLookup.cc nmap-4.01/MACLookup.cc
--- nmap-4.01.orig/MACLookup.cc	2005-07-26 06:26:10 +0000
+++ nmap-4.01/MACLookup.cc	2006-03-03 00:00:01 +0000
@@ -117,8 +117,6 @@ struct MAC_hash_table {
   struct MAC_entry **table;
 } MacTable;
 
-static int initialized = 0;
-
 static inline int MacCharPrefix2Key(const u8 *prefix) {
   return (prefix[0] << 16) + (prefix[1] << 8) + prefix[2];
 }
@@ -130,7 +128,8 @@ static inline int MACTableHash(int prefi
   return prefix % table_capacity;
 }
 
-void InitializeTable() {
+void mac_prefix_init() {
+  static int initialized = 0;
   if (initialized) return;
   initialized = 1;
   char filename[256];
@@ -216,7 +215,7 @@ const char *MACPrefix2Corp(const u8 *pre
   struct MAC_entry *ent;
 
   if (!prefix) fatal("MACPrefix2Corp called with a NULL prefix");
-  if (!initialized) InitializeTable();
+  mac_prefix_init();
 
   ent = findMACEntry(MacCharPrefix2Key(prefix));
   return (ent)? ent->vendor : NULL;
@@ -231,7 +230,7 @@ const char *MACPrefix2Corp(const u8 *pre
 bool MACCorp2Prefix(const char *vendorstr, u8 *mac_data) {
   if (!vendorstr) fatal("%s: vendorstr is NULL", __FUNCTION__);
   if (!mac_data) fatal("%s: mac_data is NULL", __FUNCTION__);
-  if (!initialized) InitializeTable();
+  mac_prefix_init();
 
   for(int i = 0; i < MacTable.table_capacity; i++ ) {
     if (MacTable.table[i])
diff -upk.orig nmap-4.01.orig/charpool.cc nmap-4.01/charpool.cc
--- nmap-4.01.orig/charpool.cc	2005-04-15 01:23:33 +0000
+++ nmap-4.01/charpool.cc	2006-03-03 00:00:01 +0000
@@ -107,11 +107,13 @@ static char *charpool[16];
 static int currentcharpool;
 static int currentcharpoolsz;
 static char *nextchar;
-static int charpool_initialized = 0;
 
 #define ALIGN_ON sizeof(char *)
 
 static int cp_init(void) {
+  static int charpool_initialized = 0;
+  if (charpool_initialized) return 0;
+
   /* Create our char pool */
   currentcharpool = 0;
   currentcharpoolsz = 16384;
@@ -135,7 +137,7 @@ void *cp_alloc(int sz) {
   char *p;
   int modulus;
 
-  if (!charpool_initialized) cp_init();
+  cp_init();
 
   if ((modulus = sz % ALIGN_ON))
     sz += ALIGN_ON - modulus;
@@ -159,8 +161,7 @@ char *q;
 char *end;
 int modulus;
 
- if (!charpool_initialized) 
-   cp_init();
+ cp_init();
 
  end = charpool[currentcharpool] + currentcharpoolsz;
  q = nextchar;
diff -upk.orig nmap-4.01.orig/nmap_dns.cc nmap-4.01/nmap_dns.cc
--- nmap-4.01.orig/nmap_dns.cc	2006-02-07 07:17:22 +0000
+++ nmap-4.01/nmap_dns.cc	2006-03-03 00:03:46 +0000
@@ -275,7 +275,6 @@ static std::list<request *> cname_reqs;
 static int total_reqs;
 static nsock_pool dnspool=NULL;
 
-static int etchosts_filled=0;
 static std::list<host_elem *> etchosts[HASH_TABLE_SIZE];
 
 static int stat_actual, stat_ok, stat_nx, stat_sf, stat_trans, stat_dropped, stat_cname;
@@ -1003,6 +1002,34 @@ char *lookup_etchosts(u32 ip) {
 }
 
 
+static void etchosts_init(void) {
+  static int initialized = 0;
+  if (initialized) return;
+  initialized = 1;
+
+#ifdef WIN32
+  char windows_dir[1024];
+  char tpbuf[2048];
+  int has_backslash;
+
+  if (!GetWindowsDirectory(windows_dir, sizeof(windows_dir)))
+    fatal("Failed to determine your windows directory");
+
+  // If it has a backslash it's C:\, otherwise something like C:\WINNT
+  has_backslash = (windows_dir[strlen(windows_dir)-1] == '\\');
+
+  // Windows 95/98/Me:
+  snprintf(tpbuf, sizeof(tpbuf), "%s%shosts", windows_dir, has_backslash ? "" : "\\");
+  parse_etchosts(tpbuf);
+
+  // Windows NT/2000/XP/2K3:
+  snprintf(tpbuf, sizeof(tpbuf), "%s%ssystem32\\drivers\\etc\\hosts", windows_dir, has_backslash ? "" : "\\");
+  parse_etchosts(tpbuf);
+
+#else
+  parse_etchosts("/etc/hosts");
+#endif
+}
 
 
 //------------------- Main loops ---------------------
@@ -1066,32 +1093,7 @@ void nmap_mass_rdns_core(Target **target
 
 
   // If necessary, set up the /etc/hosts hashtable
-  if (etchosts_filled == 0) {
-    #ifdef WIN32
-    char windows_dir[1024];
-    char tpbuf[2048];
-    int has_backslash;
-
-    if (!GetWindowsDirectory(windows_dir, sizeof(windows_dir)))
-      fatal("Failed to determine your windows directory");
-
-    // If it has a backslash it's C:\, otherwise something like C:\WINNT
-    has_backslash = (windows_dir[strlen(windows_dir)-1] == '\\');
-
-    // Windows 95/98/Me:
-    snprintf(tpbuf, sizeof(tpbuf), "%s%shosts", windows_dir, has_backslash ? "" : "\\");
-    parse_etchosts(tpbuf);
-
-    // Windows NT/2000/XP/2K3:
-    snprintf(tpbuf, sizeof(tpbuf), "%s%ssystem32\\drivers\\etc\\hosts", windows_dir, has_backslash ? "" : "\\");
-    parse_etchosts(tpbuf);
-
-    #else
-    parse_etchosts("/etc/hosts");
-    #endif
-
-    etchosts_filled = 1;
-  }
+  etchosts_init();
 
 
   total_reqs = 0;
diff -upk.orig nmap-4.01.orig/nmap_rpc.cc nmap-4.01/nmap_rpc.cc
--- nmap-4.01.orig/nmap_rpc.cc	2005-10-01 23:50:38 +0000
+++ nmap-4.01/nmap_rpc.cc	2006-03-03 00:00:01 +0000
@@ -106,7 +106,6 @@
 #include "NmapOps.h"
 
 extern NmapOps o;
-static int services_initialized = 0;
 static struct rpc_info ri;
 static int udp_rpc_socket = -1;
 static int tcp_rpc_socket = -1;
@@ -119,13 +118,16 @@ static size_t tcp_readlen=0; /* used in 
 			    send_rpc_query */
 
 static void rpc_services_init() {
+  static int services_initialized = 0;
+  if (services_initialized) return;
+  services_initialized = 1;
+
   char filename[512];
   FILE *fp;
   char *tmpptr, *p;
   char line[1024];
   int lineno = 0;
 
-  services_initialized = 1;
   ri.num_alloc = 256;
   ri.num_used = 0;
   ri.names = (char **) cp_alloc(ri.num_alloc * sizeof(char *));
@@ -182,9 +184,7 @@ static void rpc_services_init() {
 char *nmap_getrpcnamebynum(unsigned long num) {
   int i;
 
-  if (!services_initialized) {
-    rpc_services_init();
-  }
+  rpc_services_init();
 
   for(i=0; i < ri.num_used; i++) {
     if (ri.numbers[i] == num)
@@ -194,9 +194,7 @@ char *nmap_getrpcnamebynum(unsigned long
 }
 
 int get_rpc_procs(unsigned long **programs, unsigned long *num_programs) {
-  if (!services_initialized) {
-    rpc_services_init();
-  }
+  rpc_services_init();
   
   *programs = ri.numbers;
   *num_programs = ri.num_used;
diff -upk.orig nmap-4.01.orig/protocols.cc nmap-4.01/protocols.cc
--- nmap-4.01.orig/protocols.cc	2005-04-15 01:23:33 +0000
+++ nmap-4.01/protocols.cc	2006-03-03 00:00:01 +0000
@@ -103,11 +103,13 @@
 #include "NmapOps.h"
 
 extern NmapOps o;
-static int protocols_initialized = 0;
 static int numipprots = 0;
 static struct protocol_list *protocol_table[PROTOCOL_TABLE_SIZE];
 
 static int nmap_protocols_init() {
+  static int protocols_initialized = 0;
+  if (protocols_initialized) return 0;
+
   char filename[512];
   FILE *fp;
   char protocolname[128];
@@ -179,9 +181,8 @@ static int nmap_protocols_init() {
 struct protoent *nmap_getprotbynum(int num) {
   struct protocol_list *current;
 
-  if (!protocols_initialized)
-    if (nmap_protocols_init() == -1)
-      return NULL;
+  if (nmap_protocols_init() == -1)
+    return NULL;
 
   for(current = protocol_table[num % PROTOCOL_TABLE_SIZE];
       current; current = current->next) {
@@ -202,9 +203,8 @@ struct scan_lists *getdefaultprots(void)
   int bucket;
   int protsneeded = 256;
 
-  if (!protocols_initialized)
-    if (nmap_protocols_init() == -1)
-      fatal("getdefaultprots(): Couldn't get protocol numbers");
+  if (nmap_protocols_init() == -1)
+    fatal("getdefaultprots(): Couldn't get protocol numbers");
   
   scanlist = (struct scan_lists *) safe_zalloc(sizeof(struct scan_lists));
   scanlist->prots = (unsigned short *) safe_zalloc((protsneeded) * sizeof(unsigned short));
@@ -224,9 +224,8 @@ struct scan_lists *getfastprots(void) {
   int bucket;
   int protsneeded = 0;
 
-  if (!protocols_initialized)
-    if (nmap_protocols_init() == -1)
-      fatal("Getfastprots: Couldn't get protocol numbers");
+  if (nmap_protocols_init() == -1)
+    fatal("Getfastprots: Couldn't get protocol numbers");
   
   memset(usedprots, 0, sizeof(usedprots));
 
diff -upk.orig nmap-4.01.orig/service_scan.cc nmap-4.01/service_scan.cc
--- nmap-4.01.orig/service_scan.cc	2006-02-10 02:04:50 +0000
+++ nmap-4.01/service_scan.cc	2006-03-03 00:00:01 +0000
@@ -1137,6 +1137,17 @@ void parse_nmap_service_probes(AllProbes
   parse_nmap_service_probe_file(AP, filename);
 }
 
+static AllProbes *service_scan_init(void)
+{
+  static AllProbes *AP;
+
+  if (AP) return AP;
+  AP = new AllProbes();
+  parse_nmap_service_probes(AP);
+
+  return AP;
+}
+
 // If the buf (of length buflen) matches one of the regexes in this
 // ServiceProbe, returns the details of the match (service name,
 // version number if applicable, and whether this is a "soft" match.
@@ -2311,7 +2322,7 @@ void remove_excluded_ports(AllProbes *AP
    Targets specified. */
 int service_scan(vector<Target *> &Targets) {
   // int service_scan(Target *targets[], int num_targets)
-  static AllProbes *AP;
+  AllProbes *AP;
   ServiceGroup *SG;
   nsock_pool nsp;
   struct timeval now;
@@ -2323,10 +2334,7 @@ int service_scan(vector<Target *> &Targe
   if (Targets.size() == 0)
     return 1;
 
-  if (!AP) {
-    AP = new AllProbes();
-    parse_nmap_service_probes(AP);
-  }
+  AP = service_scan_init();
 
 
   // Now I convert the targets into a new ServiceGroup
diff -upk.orig nmap-4.01.orig/services.cc nmap-4.01/services.cc
--- nmap-4.01.orig/services.cc	2005-04-15 01:23:33 +0000
+++ nmap-4.01/services.cc	2006-03-03 00:00:01 +0000
@@ -103,12 +103,14 @@
 #include "NmapOps.h"
 
 extern NmapOps o;
-static int services_initialized = 0;
 static int numtcpports = 0;
 static int numudpports = 0;
 static struct service_list *service_table[SERVICE_TABLE_SIZE];
 
 static int nmap_services_init() {
+  static int services_initialized = 0;
+  if (services_initialized) return 0;
+
   char filename[512];
   FILE *fp;
   char servicename[128], proto[16];
@@ -216,9 +218,8 @@ static int nmap_services_init() {
 struct servent *nmap_getservbyport(int port, const char *proto) {
   struct service_list *current;
 
-  if (!services_initialized)
-    if (nmap_services_init() == -1)
-      return NULL;
+  if (nmap_services_init() == -1)
+    return NULL;
 
   for(current = service_table[port % SERVICE_TABLE_SIZE];
       current; current = current->next) {
@@ -244,9 +245,8 @@ struct scan_lists *getdefaultports(int t
   int tcpportsneeded = 0;
   int udpportsneeded = 0;
 
-  if (!services_initialized)
-    if (nmap_services_init() == -1)
-      fatal("Getfastports: Couldn't get port numbers");
+  if (nmap_services_init() == -1)
+    fatal("Getfastports: Couldn't get port numbers");
   
   usedports = (u8 *) safe_zalloc(sizeof(*usedports) * 65536);
 
@@ -308,9 +308,8 @@ struct scan_lists *getfastports(int tcps
   int tcpportsneeded = 0;
   int udpportsneeded = 0;
 
-  if (!services_initialized)
-    if (nmap_services_init() == -1)
-      fatal("Getfastports: Couldn't get port numbers");
+  if (nmap_services_init() == -1)
+    fatal("Getfastports: Couldn't get port numbers");
   
   usedports = (u8 *) safe_zalloc(sizeof(*usedports) * 65536);
 

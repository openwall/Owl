diff -ur zlib-1.1.3.orig/infblock.c zlib-1.1.3/infblock.c
--- zlib-1.1.3.orig/infblock.c	Mon Jun  8 21:06:16 1998
+++ zlib-1.1.3/infblock.c	Sun Feb 10 23:50:07 2002
@@ -249,10 +249,12 @@
                              &s->sub.trees.tb, s->hufts, z);
       if (t != Z_OK)
       {
-        ZFREE(z, s->sub.trees.blens);
         r = t;
         if (r == Z_DATA_ERROR)
+        {
+          ZFREE(z, s->sub.trees.blens);
           s->mode = BAD;
+        }
         LEAVE
       }
       s->sub.trees.index = 0;
@@ -313,11 +315,13 @@
         t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
                                   s->sub.trees.blens, &bl, &bd, &tl, &td,
                                   s->hufts, z);
-        ZFREE(z, s->sub.trees.blens);
         if (t != Z_OK)
         {
           if (t == (uInt)Z_DATA_ERROR)
+          {
+            ZFREE(z, s->sub.trees.blens);
             s->mode = BAD;
+          }
           r = t;
           LEAVE
         }
@@ -329,6 +333,7 @@
         }
         s->sub.decode.codes = c;
       }
+      ZFREE(z, s->sub.trees.blens);
       s->mode = CODES;
     case CODES:
       UPDATE
diff -ur zlib-1.1.3.orig/inftrees.c zlib-1.1.3/inftrees.c
--- zlib-1.1.3.orig/inftrees.c	Thu Jul  9 20:06:30 1998
+++ zlib-1.1.3/inftrees.c	Sun Feb 10 23:53:36 2002
@@ -231,7 +231,7 @@
 
         /* allocate new table */
         if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */
-          return Z_MEM_ERROR;   /* not enough memory */
+          return Z_DATA_ERROR;  /* shouldn't happen on valid input */
         u[h] = q = hp + *hn;
         *hn += z;
 

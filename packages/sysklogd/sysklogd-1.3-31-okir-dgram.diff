diff -ur sysklogd-1.3-31.orig/syslog.c sysklogd-1.3-31/syslog.c
--- sysklogd-1.3-31.orig/syslog.c	Mon Oct 12 20:58:12 1998
+++ sysklogd-1.3-31/syslog.c	Tue Sep 12 20:00:35 2000
@@ -208,8 +208,7 @@
 		strncpy(SyslogAddr.sa_data, _PATH_LOGNAME,
 		    sizeof(SyslogAddr.sa_data));
 		if (LogStat & LOG_NDELAY) {
-			LogFile = socket(AF_UNIX, SOCK_STREAM, 0);
-/*			fcntl(LogFile, F_SETFD, 1); */
+			LogFile = socket(AF_UNIX, SOCK_DGRAM, 0);
 		}
 	}
 	if (LogFile != -1 && !connected &&
diff -ur sysklogd-1.3-31.orig/syslogd.c sysklogd-1.3-31/syslogd.c
--- sysklogd-1.3-31.orig/syslogd.c	Tue Jan 19 14:31:58 1999
+++ sysklogd-1.3-31/syslogd.c	Tue Sep 12 20:02:41 2000
@@ -767,14 +767,16 @@
 	 * read().  This is in contrary to readfds which is a list of
 	 * file descriptors where activity is monitored by select()
 	 * and from which one cannot read().  -Joey
+	 *
+	 * Changed: unixm is gone, since we now use datagram unix sockets.
+	 * Hence we recv() from unix sockets directly (rather than
+	 * first accept()ing connections on them), so there's no need
+	 * for separate book-keeping.  --okir
 	 */
-	fd_set unixm, readfds;
+	fd_set readfds;
 
 #ifndef TESTING
 	int	fd;
-#ifdef SYSLOG_UNIXAF
-	struct sockaddr_un fromunix;
-#endif
 #ifdef  SYSLOG_INET
 	struct sockaddr_in frominet;
 	char *from;
@@ -990,7 +992,6 @@
 #endif
 
 	/* Main loop begins here. */
-	FD_ZERO(&unixm);
 	for (;;) {
 		int nfds;
 		errno = 0;
@@ -1009,12 +1010,6 @@
 				if (funix[i]>maxfds) maxfds=funix[i];
 			}
 		}
-		/* Copy accepted connections */
-		for (nfds= 0; nfds < FD_SETSIZE; ++nfds)
-			if (FD_ISSET(nfds, &unixm)) {
-				FD_SET(nfds, &readfds);
-				if (nfds>maxfds) maxfds=nfds;
-			}
 #endif
 #endif
 #ifdef SYSLOG_INET
@@ -1077,59 +1072,21 @@
 
 #ifndef TESTING
 #ifdef SYSLOG_UNIXAF
-		if ( debugging_on )
-		{
-			dprintf("Checking UNIX connections, active: ");
-			for (nfds= 0; nfds < maxfds; ++nfds)
-				if ( FD_ISSET(nfds, &unixm) )
-					dprintf("%d ", nfds);
-			dprintf("\n");
-		}
-		for (fd= 0; fd <= maxfds; ++fd)
-		  if ( FD_ISSET(fd, &readfds) && FD_ISSET(fd, &unixm) ) {
-			dprintf("Message from UNIX socket #%d.\n", fd);
+		for (i = 0; i < nfunix; i++) {
+		    if ((fd = funix[i]) != -1 && FD_ISSET(fd, &readfds)) {
 			memset(line, '\0', sizeof(line));
-			i = read(fd, line, MAXLINE);
+			i = recv(fd, line, MAXLINE - 2, 0);
+			dprintf("Message from UNIX socket: #%d\n", fd);
 			if (i > 0) {
-				printchopped(LocalHostName, line, i, fd);
-		  	} else if (i < 0) {
-		    		if (errno != EINTR) {
-		      			logerror("recvfrom unix");
-				}
-		        } else {
-		    		dprintf("Unix socket (%d) closed.\n", fd);
-				if ( parts[fd] != (char *) 0 )
-				{
-					logerror("Printing partial message");
-					line[0] = '\0';
-					printchopped(LocalHostName, line, \
-						     strlen(parts[fd]) + 1, \
-						     fd);
-				}
-				/* reset it */
-				for (i = 1; i < nfunix; i++) {
-					if (funix[i] == fd)
-						funix[i] = -1;
-				}
-		    		close(fd);
-		    		FD_CLR(fd, &unixm);
-		  	}
-	      	}
-		/* Accept a new unix connection */
-		for (i = 0; i < nfunix; i++)
-			if (funix[i] != -1 && FD_ISSET(funix[i], &readfds)) {
-				len = sizeof(fromunix);
-				if ((fd = accept(funix[i], (struct sockaddr *) &fromunix,
-						 &len)) >= 0) {
-					FD_SET(fd, &unixm);
-					dprintf("New UNIX connect assigned to fd: " \
-						"%d.\n", fd);
-					FD_SET(fd, &readfds);
-				} else {
-					dprintf("Error accepting UNIX connection: " \
-						"%d = %s.\n", errno, strerror(errno));
-				}
+				line[i] = line[i+1] = '\0';
+				printchopped(LocalHostName, line, i + 2,  fd);
+			} else if (i < 0 && errno != EINTR) {
+				dprintf("UNIX socket error: %d = %s.\n", \
+					errno, strerror(errno));
+				logerror("recvfrom UNIX");
 			}
+		  }
+		}
 #endif
 
 #ifdef SYSLOG_INET
@@ -1158,6 +1115,8 @@
 				dprintf("INET socket error: %d = %s.\n", \
 					errno, strerror(errno));
 				logerror("recvfrom inet");
+				/* should be harmless now that we set
+				 * BSDCOMPAT on the socket */
 				sleep(10);
 			}
 		}
@@ -1205,10 +1164,10 @@
 	memset(&sunx, 0, sizeof(sunx));
 	sunx.sun_family = AF_UNIX;
 	(void) strncpy(sunx.sun_path, path, sizeof(sunx.sun_path));
-	fd = socket(AF_UNIX, SOCK_STREAM, 0);
+	fd = socket(AF_UNIX, SOCK_DGRAM, 0);
 	if (fd < 0 || bind(fd, (struct sockaddr *) &sunx,
 			   sizeof(sunx.sun_family)+strlen(sunx.sun_path)) < 0 ||
-	    chmod(path, 0666) < 0 || listen(fd, 5) < 0) {
+	    chmod(path, 0666) < 0) {
 		(void) snprintf(line, sizeof(line), "cannot create %s", path);
 		logerror(line);
 		dprintf("cannot create %s (%d).\n", path, errno);
@@ -1238,7 +1197,16 @@
 	sin.sin_port = LogPort;
 	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, \
 		       (char *) &on, sizeof(on)) < 0 ) {
-		logerror("setsockopt, suspending inet");
+		logerror("setsockopt(REUSEADDR), suspending inet");
+		close(fd);
+		return -1;
+	}
+	/* We need to enable BSD compatibility. Otherwise an attacker
+	 * could flood our log files by sending us tons of ICMP errors.
+	 */
+	if (setsockopt(fd, SOL_SOCKET, SO_BSDCOMPAT, \
+			(char *) &on, sizeof(on)) < 0) {
+		logerror("setsockopt(BSDCOMPAT), suspending inet");
 		close(fd);
 		return -1;
 	}
@@ -2331,7 +2299,7 @@
 #ifdef SYSLOG_UNIXAF
 	for (i = 0; i < nfunix; i++) {
 		if (funix[i] != -1)
-			close(funix[i]);
+			continue;
 		if ((funix[i] = create_unix_socket(funixn[i])) != -1)
 			dprintf("Opened UNIX socket `%s'.\n", funixn[i]);
 	}

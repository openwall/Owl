diff -uNrp lilo-23.1.orig/src/boot.c lilo-23.1/src/boot.c
--- lilo-23.1.orig/src/boot.c	2011-01-18 14:52:19 +0000
+++ lilo-23.1/src/boot.c	2011-01-18 14:52:35 +0000
@@ -85,7 +85,7 @@ void boot_image(char *spec,IMAGE_DESCR *
 		check_size(spec,setup,sectors);
 	else {
 		if (hdr.start % PAGE_SIZE)
-			die("Can't load kernel at mis-aligned address 0x%08lx\n",hdr.start);
+			die("Can't load kernel at mis-aligned address 0x%08x\n",hdr.start);
 		descr->flags |= FLAG_LOADHI;	/* load kernel high */
 		hi_sectors = sectors - setup;	/* number of sectors loaded high */
 		hi_sectors *= 6;            	/* account for decompression */
diff -uNrp lilo-23.1.orig/src/cfg.c lilo-23.1/src/cfg.c
--- lilo-23.1.orig/src/cfg.c	2011-01-18 14:52:19 +0000
+++ lilo-23.1/src/cfg.c	2011-01-18 14:52:35 +0000
@@ -264,7 +264,7 @@ int cfg_open(char *name)
 }
 
 
-void cfg_error(char *msg,...)
+void __attribute__ ((format (printf, 1, 2))) cfg_error(char *msg,...)
 {
     va_list ap;
 
diff -uNrp lilo-23.1.orig/src/cfg.h lilo-23.1/src/cfg.h
--- lilo-23.1.orig/src/cfg.h	2011-01-18 14:52:19 +0000
+++ lilo-23.1/src/cfg.h	2011-01-18 14:52:35 +0000
@@ -37,7 +37,7 @@ int cfg_open(char *name);
 /* Opens the configuration file. Returns the file descriptor of the open
    file. */
 
-void cfg_error(char *msg,...);
+void cfg_error(char *msg,...) __attribute__ ((format (printf, 1, 2)));
 
 /* Signals an error while parsing the configuration file and terminates the
    program. */
diff -uNrp lilo-23.1.orig/src/common.c lilo-23.1/src/common.c
--- lilo-23.1.orig/src/common.c	2011-01-18 14:52:19 +0000
+++ lilo-23.1/src/common.c	2011-01-18 14:52:35 +0000
@@ -39,7 +39,7 @@ unsigned int prt_map[PRTMAP_SIZE+1];
 int curr_prt_map;
 #endif /* !__MSDOS__ */
 
-/*volatile*/ void pdie(char *msg)
+/*volatile*/ void pdie(const char *msg)
 {
     fflush(stdout);
 #if !__MSDOS__
@@ -51,7 +51,7 @@ int curr_prt_map;
 }
 
 
-/*volatile*/ void die(char *fmt,...)
+/*volatile*/ void __attribute__ ((format (printf, 1, 2))) die(const char *fmt,...)
 {
     va_list ap;
 
diff -uNrp lilo-23.1.orig/src/common.h lilo-23.1/src/common.h
--- lilo-23.1.orig/src/common.h	2011-01-18 14:52:19 +0000
+++ lilo-23.1/src/common.h	2011-01-18 14:52:35 +0000
@@ -396,11 +396,12 @@ extern int dm_major_nr;
 #define comma (cc(First)|cc(Second)|cc(Third)|cc(Bitmap)|cc(Chain)|cc(Mbr)|cc(Mbr2))
 
 
-/*volatile*/ void pdie(char *msg);
+/*volatile*/ void pdie(const char *msg) __attribute__ ((noreturn));
 /* Do a perror and then exit. */
 
 
-/*volatile*/ void die(char *fmt,...);
+/*volatile*/ void __attribute__ ((format (printf, 1, 2)))
+ __attribute__ ((noreturn)) die(const char *fmt,...);
 /* fprintf an error message and then exit. */
 
 
diff -uNrp lilo-23.1.orig/src/device.c lilo-23.1/src/device.c
--- lilo-23.1.orig/src/device.c	2011-01-18 14:52:19 +0000
+++ lilo-23.1/src/device.c	2011-01-18 14:52:35 +0000
@@ -639,7 +639,7 @@ unsigned int register_bios(int bios, int
 
 		*(int*)&buff.sector[PART_TABLE_OFFSET-6] = serial;
 		if (*(short*)&buff.sector[PART_TABLE_OFFSET - 2] == 0)
-		    *(short*)&buff.sector[PART_TABLE_OFFSET - 2] = MAGIC_SERIAL;
+		    *(unsigned short*)&buff.sector[PART_TABLE_OFFSET - 2] = MAGIC_SERIAL;
 		if (verbose)
 		    printf("Assigning new Volume ID to (%04X) '%s'  ID = %08X\n",
 		    			device, dev.name, (int)serial);
@@ -655,7 +655,7 @@ unsigned int register_bios(int bios, int
 		if (device_code[i]==device)
 		    die("register_bios: device code duplicated: %04X", device);
 		if (serial_no[i]==serial)
-		    die("register_bios: volume ID serial no. duplicated: %08lX", serial);
+		    die("register_bios: volume ID serial no. duplicated: %08X", serial);
 	    }
 	    device_code[bios] = device;
 	    serial_no[bios] = serial;
diff -uNrp lilo-23.1.orig/src/edit.c lilo-23.1/src/edit.c
--- lilo-23.1.orig/src/edit.c	2011-01-18 14:52:19 +0000
+++ lilo-23.1/src/edit.c	2011-01-18 14:52:35 +0000
@@ -97,7 +97,7 @@ int get_std_headers(int fd,
     if (fh->magic != 0x4D42 /* "BM" */)  return 1;
     if (read(fd, &size, sizeof(size)) != sizeof(size))   return -1;
     if (size==sizeof(BITMAPHEADER2)) { /* an OS/2 bitmap */
-	if (read(fd, (void*)&bmh2+sizeof(size), sizeof(BITMAPHEADER2)-sizeof(size))
+	if (read(fd, (char*)&bmh2+sizeof(size), sizeof(BITMAPHEADER2)-sizeof(size))
 		!= sizeof(BITMAPHEADER2)-sizeof(size) )   return -1;
 	memset(bmh, 0, sizeof(BITMAPHEADER));
 	bmh->width = bmh2.width;
@@ -110,7 +110,7 @@ int get_std_headers(int fd,
 	n = sizeof(RGB2);
     }
     else if (size==sizeof(BITMAPHEADER)) {
-	if (read(fd, (void*)bmh+sizeof(size), sizeof(BITMAPHEADER)-sizeof(size))
+	if (read(fd, (char*)bmh+sizeof(size), sizeof(BITMAPHEADER)-sizeof(size))
 		!= sizeof(BITMAPHEADER)-sizeof(size) )   return -1;
 	bmh->size = size;
 	n = sizeof(RGB);
@@ -131,7 +131,7 @@ int get_std_headers(int fd,
       /* get probable BITMAPLILOHEADER */
 	if (read(fd, &size, sizeof(size)) != sizeof(size))  return -1;
 	if (size != sizeof(BITMAPLILOHEADER))   return 4;
-	if (read(fd, (void*)lh+sizeof(size), sizeof(*lh)-sizeof(size)) !=
+	if (read(fd, (char*)lh+sizeof(size), sizeof(*lh)-sizeof(size)) !=
 		sizeof(*lh)-sizeof(size))  return -1;
 	*(int*)(lh->size) = size;
 	if (strncmp(lh->magic, "LILO", 4) != 0)   return 5;
@@ -192,8 +192,8 @@ static	union {
 	   BITMAPLILOHEADER bmlh;
 	} tm;
 static	MENUTABLE *menu = &tm.mt;
-static	BITMAPLILOHEADER *lh = (void*)tm.buffer + 
-    			((long)&tm.mt.row - (long)&tm.bmlh.row);
+static	BITMAPLILOHEADER *lh = (void*)(tm.buffer +
+    			((long)&tm.mt.row - (long)&tm.bmlh.row));
 
 /* a convenience definition */
 #define mn tm.mt
diff -uNrp lilo-23.1.orig/src/geometry.c lilo-23.1/src/geometry.c
--- lilo-23.1.orig/src/geometry.c	2011-01-18 14:52:19 +0000
+++ lilo-23.1/src/geometry.c	2011-01-18 14:53:37 +0000
@@ -172,7 +172,7 @@ void geo_init(char *name)
 	    if (strspn(line," \t") != strlen(line)) {
 		entry = alloc_t(DT_ENTRY);
 		items = sscanf(line,"0x%x 0x%x %d %d %d %d",&entry->device,
-		  &entry->bios,&entry->sectors,&entry->heads,&entry->cylinders,
+		  (unsigned int*)&entry->bios,&entry->sectors,&entry->heads,&entry->cylinders,
 		  &entry->start);
 		if (items == 5) entry->start = -1;
 		if (items < 5)
@@ -400,7 +400,7 @@ void do_disk(void)
 	if (i!=7 && i!=15 && i!=31 && i!=63) die("disk=%s:  illegal value for max-partitions(%d)", disk, i);
       }
       else {
-        die("Implementation restriction: max-partitions on major device > %d", nelem(max_partno)-1);
+        die("Implementation restriction: max-partitions on major device > %d", (int)nelem(max_partno)-1);
       }
     }
     entry->bios = bios ? to_number(bios) : -1;
@@ -499,14 +499,14 @@ static int last_dev(int major,int increm
  * only used to count IDE drives anyway, we try now only the first two devices
  * and forget about scan_last_dev.
  */
+    DEVICE dev;
+    int devs;
     static int cached_major=-1, cached_increment=-1, cached_result=-1;
     if(major == cached_major && increment == cached_increment)
         return cached_result;
     cached_major = major;
     cached_increment = increment;
 
-    DEVICE dev;
-    int devs;
 
     for (devs = 0;
 	devs < 2 && dev_open(&dev,MKDEV(major,increment*devs),O_BYPASS);
@@ -547,7 +547,7 @@ void lvm_bmap(struct lv_bmap *lbm)
 
 	lvmfd = dev_open(&dev, lbm->lv_dev, O_RDONLY);
 	if (lvmfd < 0)
-	    die("can't open LVM block device %#x\n", lbm->lv_dev);
+	    die("can't open LVM block device %#x\n", (int)lbm->lv_dev);
 	last_dev = lbm->lv_dev;
     }
     if (ioctl(lvmfd, LV_BMAP, lbm) < 0) {
@@ -785,9 +785,9 @@ void geo_query_dev(GEOMETRY *geo,int dev
 	    
 	    if ((MAJOR(device)>=120 && MAJOR(device)<=127)  ||
 	        (MAJOR(device)>=240 && MAJOR(device)<=254) )
-		die("Linux experimental device 0x04x needs to be defined.\n"
+		die("Linux experimental device %#04x needs to be defined.\n"
 		    "Check 'man lilo.conf' under 'disk=' and 'max-partitions='", device);
-	    else die("Sorry, don't know how to handle device 0x%04x",device);
+	    else die("Sorry, don't know how to handle device %#04x",device);
     }
     if (get_all) dev_close(&dev);
     if (verbose>=5) printf("exit geo_query_dev\n");
@@ -1282,7 +1282,7 @@ int pass;
 } /* end of geo_get */
 
 
-int geo_open(GEOMETRY *geo,char *name,int flags)
+int geo_open(GEOMETRY *geo,const char *name,int flags)
 {
     char *here;
     int user_dev,block_size;
diff -uNrp lilo-23.1.orig/src/geometry.h lilo-23.1/src/geometry.h
--- lilo-23.1.orig/src/geometry.h	2011-01-18 14:52:19 +0000
+++ lilo-23.1/src/geometry.h	2011-01-18 14:52:35 +0000
@@ -131,7 +131,7 @@ void geo_get(GEOMETRY *geo,int device,in
    is retrieved and the other geometry information is undefined. */
 
 
-int geo_open(GEOMETRY *geo,char *name,int flags);
+int geo_open(GEOMETRY *geo,const char *name,int flags);
 /* Opens the specified file or block device, obtains the necessary geometry
    information and returns the file descriptor. If the name contains a BIOS
    device specification (xxx:yyy), it is removed and stored in the geometry
diff -uNrp lilo-23.1.orig/src/partition.c lilo-23.1/src/partition.c
--- lilo-23.1.orig/src/partition.c	2011-01-18 14:52:19 +0000
+++ lilo-23.1/src/partition.c	2011-01-18 14:52:35 +0000
@@ -56,10 +56,10 @@ source directory.
 #endif
 
 static
-int anywhere(void *buf, char *str)
+int anywhere(unsigned char *buf, char *str)
 {
     int k, n;
-    void *s;
+    char *s;
     
     k = strlen(str);
     n = SECTOR_SIZE-k;
@@ -67,7 +67,7 @@ int anywhere(void *buf, char *str)
     while(s) {
 	if (!strncmp(s, str, k)) return 1;
 	s++;
-	n = SECTOR_SIZE - k - (int)(s-buf);
+	n = SECTOR_SIZE - k - (int)(s-(char*)buf);
 	s = memchr(s, *str, n);
     }
     return 0;
@@ -381,7 +381,7 @@ static void add_rule(unsigned char bios,
     int i;
 
     if (curr_prt_map == PRTMAP_SIZE)
-	cfg_error("Too many change rules (more than %s)",PRTMAP_SIZE);
+	cfg_error("Too many change rules (more than %d)",PRTMAP_SIZE);
     if (verbose >= 3)
 	printf("  Adding rule: disk 0x%02x, offset 0x%x, 0x%02x -> 0x%02x\n",
 	    bios,PART_TABLE_OFFSET+offset,expect,set);
diff -uNrp lilo-23.1.orig/src/probe.c lilo-23.1/src/probe.c
--- lilo-23.1.orig/src/probe.c	2011-01-18 14:52:19 +0000
+++ lilo-23.1/src/probe.c	2011-01-18 14:52:35 +0000
@@ -204,10 +204,10 @@ int fetch(void)
 	eq = (void*)&buf.b[buf.s5.equipment];
 	v1 = (void*)&buf.b[buf.s5.video];
 	if (buf.s5.vid > 1) {
-	    v2 = (void*)v1 + sizeof(*v1);
-	    v25 = (void*)v2 + sizeof(*v2);
+	    v2 = (void*)(v1 + 1);
+	    v25 = (void*)(v2 + 1);
 	}
-	if (buf.s5.vid > 2) v3 = (void*)v25 + sizeof(*v25);
+	if (buf.s5.vid > 2) v3 = (void*)(v25 + 1);
     }
 #if BETA_TEST
 	if (verbose>=5) printf("fetch: good return\n");
@@ -354,7 +354,7 @@ static int get_geom(unsigned int drive, 
 
 
     if (drive >= 0x80)
-        hdp[drive-0x80 + 1] = (void*)hd + sizeof(hard_t);		/* simplest increment, but may be wrong */
+        hdp[drive-0x80 + 1] = hd + 1;		/* simplest increment, but may be wrong */
     
     /* regs.eax = 0x1500;           check drive type */
     /* regs.edx = drive;			*/
@@ -405,7 +405,7 @@ static int get_geom(unsigned int drive, 
 #if 0
    				geom->pt = &pt_base[(drive&15)*4];
 #else
-	void *p = (void*)pt_base;
+	char *p = (char*)pt_base;
 	int i = buf.s5.version >= 4 ? 8 : 0;
 	
 	p += (drive & 15) * (PART_TABLE_SIZE + i) + i;
@@ -439,7 +439,7 @@ static int get_geom(unsigned int drive, 
 	fflush(stdout);
 #endif
     /* update the pointer to the next drive */
-      hdp[drive-0x80 + 1] = (void*)dp + sizeof(edd_t);
+      hdp[drive-0x80 + 1] = (void*)(dp + 1);
 
       /* regs.eax = 0x4800;		*/
       /* regs.edx = drive;		*/

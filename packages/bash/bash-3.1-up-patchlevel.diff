			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-001

Bug-Reported-by: Mike Frysinger <vapier@gentoo.org>
Bug-Reference-ID: <20051212015924.GA820@toucan.gentoo.org> <20051214034438.GK1863@toucan.gentoo.org>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2005-12/msg00030.html http://lists.gnu.org/archive/html/bug-bash/2005-12/msg00041.html

Bug-Description:

There are parsing problems with compound assignments in several contexts,
including as arguments to builtins like `local', `eval', and `let', and
as multiple assignments in a single command.

Patch:

*** ../bash-3.1/parse.y	Fri Nov 11 23:14:18 2005
--- parse.y	Fri Dec 16 20:43:07 2005
***************
*** 3696,3700 ****
        b = builtin_address_internal (token, 0);
        if (b && (b->flags & ASSIGNMENT_BUILTIN))
!         parser_state |= PST_ASSIGNOK;
      }
  
--- 3696,3702 ----
        b = builtin_address_internal (token, 0);
        if (b && (b->flags & ASSIGNMENT_BUILTIN))
! 	parser_state |= PST_ASSIGNOK;
!       else if (STREQ (token, "eval") || STREQ (token, "let"))
! 	parser_state |= PST_ASSIGNOK;
      }
  
***************
*** 4687,4691 ****
  {
    WORD_LIST *wl, *rl;
!   int tok, orig_line_number, orig_token_size;
    char *saved_token, *ret;
  
--- 4689,4693 ----
  {
    WORD_LIST *wl, *rl;
!   int tok, orig_line_number, orig_token_size, orig_last_token, assignok;
    char *saved_token, *ret;
  
***************
*** 4693,4696 ****
--- 4695,4699 ----
    orig_token_size = token_buffer_size;
    orig_line_number = line_number;
+   orig_last_token = last_read_token;
  
    last_read_token = WORD;	/* WORD to allow reserved words here */
***************
*** 4699,4702 ****
--- 4702,4707 ----
    token_buffer_size = 0;
  
+   assignok = parser_state&PST_ASSIGNOK;		/* XXX */
+ 
    wl = (WORD_LIST *)NULL;	/* ( */
    parser_state |= PST_COMPASSIGN;
***************
*** 4741,4745 ****
      }
  
!   last_read_token = WORD;
    if (wl)
      {
--- 4746,4750 ----
      }
  
!   last_read_token = orig_last_token;		/* XXX - was WORD? */
    if (wl)
      {
***************
*** 4753,4756 ****
--- 4758,4765 ----
    if (retlenp)
      *retlenp = (ret && *ret) ? strlen (ret) : 0;
+ 
+   if (assignok)
+     parser_state |= PST_ASSIGNOK;
+ 
    return ret;
  }
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 0
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-002

Bug-Reported-by: vapier@gentoo.org
Bug-Reference-ID: <20051210223218.GD3324@toucan.gentoo.org>
Bug-Reference-URL:http://lists.gnu.org/archive/html/bug-bash/2005-12/msg00021.html

Bug-Description:

This corrects several omissions in the bash documentation:  It adds the new
options to `ulimit', the exact expansions for `case' patterns, clarification
of the language concerning the return value of `[[', and updated version
information.

Patch:

*** ../bash-3.1/doc/bash.1	Wed Oct 12 11:40:52 2005
--- doc/bash.1	Wed Dec 28 19:58:54 2005
***************
*** 7,16 ****
  .\"	chet@po.cwru.edu
  .\"
! .\"	Last Change: Sat Aug 27 13:28:44 EDT 2005
  .\"
  .\" bash_builtins, strip all but Built-Ins section
  .if \n(zZ=1 .ig zZ
  .if \n(zY=1 .ig zY
! .TH BASH 1 "2005 Aug 27" "GNU Bash-3.1-beta1"
  .\"
  .\" There's some problem with having a `@'
--- 7,16 ----
  .\"	chet@po.cwru.edu
  .\"
! .\"	Last Change: Wed Dec 28 19:58:45 EST 2005
  .\"
  .\" bash_builtins, strip all but Built-Ins section
  .if \n(zZ=1 .ig zZ
  .if \n(zY=1 .ig zY
! .TH BASH 1 "2005 Dec 28" "GNU Bash-3.1"
  .\"
  .\" There's some problem with having a `@'
***************
*** 678,683 ****
  is enabled, the match is performed without regard to the case
  of alphabetic characters.
! The return value is 0 if the string matches or does not match
! the pattern, respectively, and 1 otherwise.
  Any part of the pattern may be quoted to force it to be matched as a
  string.
--- 678,683 ----
  is enabled, the match is performed without regard to the case
  of alphabetic characters.
! The return value is 0 if the string matches (\fB==\fP) or does not match
! (\fB!=\fP) the pattern, and 1 otherwise.
  Any part of the pattern may be quoted to force it to be matched as a
  string.
***************
*** 808,811 ****
--- 808,817 ----
  .B Pathname Expansion
  below).
+ The \fIword\fP is expanded using tilde
+ expansion, parameter and variable expansion, arithmetic substituion,
+ command substitution, process substitution and quote removal.
+ Each \fIpattern\fP examined is expanded using tilde
+ expansion, parameter and variable expansion, arithmetic substituion,
+ command substitution, and process substitution.
  If the shell option
  .B nocasematch
***************
*** 8485,8489 ****
  none are found.
  .TP
! \fBulimit\fP [\fB\-SHacdflmnpstuv\fP [\fIlimit\fP]]
  Provides control over the resources available to the shell and to
  processes started by it, on systems that allow such control.
--- 8485,8489 ----
  none are found.
  .TP
! \fBulimit\fP [\fB\-SHacdfilmnpqstuvx\fP [\fIlimit\fP]]
  Provides control over the resources available to the shell and to
  processes started by it, on systems that allow such control.
***************
*** 8524,8527 ****
--- 8524,8530 ----
  The maximum size of files created by the shell
  .TP
+ .B \-i
+ The maximum number of pending signals
+ .TP
  .B \-l
  The maximum size that may be locked into memory
***************
*** 8537,8540 ****
--- 8540,8546 ----
  The pipe size in 512-byte blocks (this may not be set)
  .TP
+ .B \-q
+ The maximum number of bytes in POSIX message queues
+ .TP
  .B \-s
  The maximum stack size
***************
*** 8548,8551 ****
--- 8554,8560 ----
  .B \-v
  The maximum amount of virtual memory available to the shell
+ .TP
+ .B \-x
+ The maximum number of file locks
  .PD
  .PP
*** ../bash-3.1/doc/bashref.texi	Mon Oct  3 15:07:21 2005
--- doc/bashref.texi	Fri Dec 30 10:50:39 2005
***************
*** 962,967 ****
  is enabled, the match is performed without regard to the case
  of alphabetic characters.
! The return value is 0 if the string matches or does not match
! the pattern, respectively, and 1 otherwise.
  Any part of the pattern may be quoted to force it to be matched as a
  string.
--- 962,967 ----
  is enabled, the match is performed without regard to the case
  of alphabetic characters.
! The return value is 0 if the string matches (@samp{==}) or does not
! match (@samp{!=})the pattern, and 1 otherwise.
  Any part of the pattern may be quoted to force it to be matched as a
  string.
***************
*** 2599,2603 ****
  or inconvenient to obtain with separate utilities.
  
! This section briefly the builtins which Bash inherits from
  the Bourne Shell, as well as the builtin commands which are unique
  to or have been extended in Bash.
--- 2597,2601 ----
  or inconvenient to obtain with separate utilities.
  
! This section briefly describes the builtins which Bash inherits from
  the Bourne Shell, as well as the builtin commands which are unique
  to or have been extended in Bash.
***************
*** 3834,3838 ****
  @btindex ulimit
  @example
! ulimit [-acdflmnpstuvSH] [@var{limit}]
  @end example
  @code{ulimit} provides control over the resources available to processes
--- 3834,3838 ----
  @btindex ulimit
  @example
! ulimit [-acdfilmnpqstuvxSH] [@var{limit}]
  @end example
  @code{ulimit} provides control over the resources available to processes
***************
*** 3858,3861 ****
--- 3858,3864 ----
  The maximum size of files created by the shell.
  
+ @item -i
+ The maximum number of pending signals.
+ 
  @item -l
  The maximum size that may be locked into memory.
***************
*** 3870,3873 ****
--- 3873,3879 ----
  The pipe buffer size.
  
+ @item -q
+ The maximum number of bytes in POSIX message queues.
+ 
  @item -s
  The maximum stack size.
***************
*** 3882,3885 ****
--- 3888,3894 ----
  The maximum amount of virtual memory available to the process.
  
+ @item -x
+ The maximum number of file locks.
+ 
  @end table
  
***************
*** 4090,4095 ****
  
  @item -x
! Print a trace of simple commands, \fBfor\fP commands, \fBcase\fP
! commands, \fBselect\fP commands, and arithmetic \fBfor\fP commands
  and their arguments or associated word lists after they are
  expanded and before they are executed.  The value of the @env{PS4}
--- 4103,4108 ----
  
  @item -x
! Print a trace of simple commands, @code{for} commands, @code{case}
! commands, @code{select} commands, and arithmetic @code{for} commands
  and their arguments or associated word lists after they are
  expanded and before they are executed.  The value of the @env{PS4}
*** ../bash-3.1/doc/version.texi	Tue Sep 20 14:52:56 2005
--- doc/version.texi	Fri Dec 30 10:50:58 2005
***************
*** 3,10 ****
  @end ignore
  
! @set LASTCHANGE Mon Sep  5 11:47:04 EDT 2005
  
! @set EDITION 3.1-beta1
! @set VERSION 3.1-beta1
! @set UPDATED 5 September 2005
! @set UPDATED-MONTH September 2005
--- 3,10 ----
  @end ignore
  
! @set LASTCHANGE Fri Dec 30 10:50:51 EST 2005
  
! @set EDITION 3.1
! @set VERSION 3.1
! @set UPDATED 30 December 2005
! @set UPDATED-MONTH December 2005
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-003

Bug-Reported-by: Adam Buraczewski <adamb@nor.pl>
Bug-Reference-ID: <200512210950.jBL9o4C2008608@localhost.localdomain>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2005-12/msg00055.html

Bug-Description:

A missing #define guard causes bash to not compile when readline is not
configured in, either as the result of explicit disabling or when the
`--enable-minimal-config' option is given to configure.

Patch:

*** ../bash-3.1/variables.c	Sat Nov 12 21:22:37 2005
--- variables.c	Mon Dec 26 13:34:03 2005
***************
*** 861,867 ****
--- 863,871 ----
    char val[INT_STRLEN_BOUND(int) + 1], *v;
  
+ #if defined (READLINE)
    /* If we are currently assigning to LINES or COLUMNS, don't do anything. */
    if (winsize_assignment)
      return;
+ #endif
  
    v = inttostr (lines, val, sizeof (val));
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-004

Bug-Reported-by: Mike Frysinger <vapier@gentoo.org>
Bug-Reference-ID: <20051223172359.GF14579@toucan.gentoo.org>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2005-12/msg00062.html

Bug-Description:

A local array variable declared at function scope that shadows a variable
of the same name declared in a previous scope did not create a separate
variable instance, but used the previous one.

Patch:

*** ../bash-3.1/subst.c	Mon Oct 24 09:51:13 2005
--- subst.c	Fri Dec 30 12:11:53 2005
***************
*** 2188,2192 ****
      {
        v = find_variable (name);
!       if (v == 0 || array_p (v) == 0)
          v = make_local_array_variable (name);
        v = assign_array_var_from_string (v, value, flags);
--- 2188,2192 ----
      {
        v = find_variable (name);
!       if (v == 0 || array_p (v) == 0 || v->context != variable_context)
          v = make_local_array_variable (name);
        v = assign_array_var_from_string (v, value, flags);
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-005

Bug-Reported-by:
Bug-Reference-ID:
Bug-Reference-URL:

Bug-Description:

When tilde expansion fails, POSIX leaves it unspecified whether or not the
word undergoes the additional word expansions.  Bash-3.1 as distributed
skipped the rest of the expansions; this patch restores the bash-3.0 behavior.

This means that something like
	USER=ratbert
	echo ~$USER

will echo `~ratbert' rather than `~$USER'.

Patch:

*** ../bash-3.1/subst.c	Mon Oct 24 09:51:13 2005
--- subst.c	Fri Dec 30 12:11:53 2005
***************
*** 6796,6799 ****
--- 6823,6832 ----
  	    {
  	      temp1 = bash_tilde_expand (temp, tflag);
+ 	      if  (temp1 && *temp1 == '~' && STREQ (temp, temp1))
+ 		{
+ 		  FREE (temp);
+ 		  FREE (temp1);
+ 		  goto add_character;		/* tilde expansion failed */
+ 		}
  	      free (temp);
  	      temp = temp1;
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-006

Bug-Reported-by: Mike Frysinger <vapier@gentoo.org>
Bug-Reference-ID: <200601120613.11907.vapier@gentoo.org>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2006-01/msg00045.html

Bug-Description:

Under some circumstances, Bash can use an incorrect setting for the flag
that indicates whether or not the terminal can auto-wrap, resulting in line-
wrapping errors.

Patch:

*** ../bash-3.1/lib/readline/terminal.c	Sat Nov 12 20:46:54 2005
--- lib/readline/terminal.c	Tue Jan 31 10:57:54 2006
***************
*** 123,127 ****
  
  /* Non-zero means the terminal can auto-wrap lines. */
! int _rl_term_autowrap;
  
  /* Non-zero means that this terminal has a meta key. */
--- 126,130 ----
  
  /* Non-zero means the terminal can auto-wrap lines. */
! int _rl_term_autowrap = -1;
  
  /* Non-zero means that this terminal has a meta key. */
***************
*** 275,278 ****
--- 278,284 ----
       int rows, cols;
  {
+   if (_rl_term_autowrap == -1)
+     _rl_init_terminal_io (rl_terminal_name);
+ 
    if (rows > 0)
      _rl_screenheight = rows;
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 6
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-007

Bug-Reported-by: Tim Waugh <twaugh@redhat.com>, Laird Breyer <laird@lbreyer.com>
Bug-Reference-ID: <20060105174434.GY16000@redhat.com>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2006-01/msg00009.html
		   http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=347695

Bug-Description:

When the number of saved jobs exceeds the initial size of the jobs array
(4096 slots), the array must be compacted and reallocated.  An error in
the code to do that could cause a segmentation fault.

Patch:

*** ../bash-3.1/jobs.c	Fri Nov 11 23:13:27 2005
--- jobs.c	Wed Feb  1 13:55:38 2006
***************
*** 845,851 ****
  {
    sigset_t set, oset;
!   int nsize, i, j;
    JOB **nlist;
  
    nsize = ((js.j_njobs + JOB_SLOTS - 1) / JOB_SLOTS);
    nsize *= JOB_SLOTS;
--- 888,895 ----
  {
    sigset_t set, oset;
!   int nsize, i, j, ncur, nprev;
    JOB **nlist;
  
+   ncur = nprev = NO_JOB;
    nsize = ((js.j_njobs + JOB_SLOTS - 1) / JOB_SLOTS);
    nsize *= JOB_SLOTS;
***************
*** 855,869 ****
  
    BLOCK_CHILD (set, oset);
!   nlist = (JOB **) xmalloc (nsize * sizeof (JOB *));
    for (i = j = 0; i < js.j_jobslots; i++)
      if (jobs[i])
!       nlist[j++] = jobs[i];
  
    js.j_firstj = 0;
!   js.j_lastj = (j > 0) ? j - 1: 0;
    js.j_jobslots = nsize;
  
!   free (jobs);
!   jobs = nlist;
  
    UNBLOCK_CHILD (oset);
--- 899,947 ----
  
    BLOCK_CHILD (set, oset);
!   nlist = (js.j_jobslots == nsize) ? jobs : (JOB **) xmalloc (nsize * sizeof (JOB *));
! 
    for (i = j = 0; i < js.j_jobslots; i++)
      if (jobs[i])
!       {
! 	if (i == js.j_current)
! 	  ncur = j;
! 	if (i == js.j_previous)
! 	  nprev = j;
! 	nlist[j++] = jobs[i];
!       }
! 
! #if defined (DEBUG)
!   itrace ("realloc_jobs_list: resize jobs list from %d to %d", js.j_jobslots, nsize);
!   itrace ("realloc_jobs_list: j_lastj changed from %d to %d", js.j_lastj, (j > 0) ? j - 1 : 0);
!   itrace ("realloc_jobs_list: j_njobs changed from %d to %d", js.j_njobs, (j > 0) ? j - 1 : 0);
! #endif
  
    js.j_firstj = 0;
!   js.j_lastj = (j > 0) ? j - 1 : 0;
!   js.j_njobs = j;
    js.j_jobslots = nsize;
  
!   /* Zero out remaining slots in new jobs list */
!   for ( ; j < nsize; j++)
!     nlist[j] = (JOB *)NULL;
! 
!   if (jobs != nlist)
!     {
!       free (jobs);
!       jobs = nlist;
!     }
! 
!   if (ncur != NO_JOB)
!     js.j_current = ncur;
!   if (nprev != NO_JOB)
!     js.j_previous = nprev;
! 
!   /* Need to reset these */
!   if (js.j_current == NO_JOB || js.j_previous == NO_JOB || js.j_current > js.j_lastj || js.j_previous > js.j_lastj)
!     reset_current ();
! 
! #ifdef DEBUG
!   itrace ("realloc_jobs_list: reset js.j_current (%d) and js.j_previous (%d)", js.j_current, js.j_previous);
! #endif
  
    UNBLOCK_CHILD (oset);
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 6
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 7
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-008

Bug-Reported-by: Ingemar Nilsson <init@kth.se>
Bug-Reference-ID: <43C38D35.7020404@kth.se>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2006-01/msg00044.html

Bug-Description:

In some cases, bash inappropriately allows SIGINT from the terminal to
reach background processes.

Patch:

*** ../bash-3.1/jobs.c	Fri Nov 11 23:13:27 2005
--- jobs.c	Wed Feb  1 13:55:38 2006
***************
*** 2199,2203 ****
    wait_sigint_received = 0;
    if (job_control == 0)
!     old_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);
  
    termination_state = last_command_exit_value;
--- 2298,2306 ----
    wait_sigint_received = 0;
    if (job_control == 0)
!     {
!       old_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);
!       if (old_sigint_handler == SIG_IGN)
! 	set_signal_handler (SIGINT, old_sigint_handler);
!     }
  
    termination_state = last_command_exit_value;
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 7
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 8
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-009

Bug-Reported-by: Joshua Neuheisel <jneuheisel@gmail.com>
Bug-Reference-ID: <25d873330601140820v4ad8efd2t8bf683b073c138b3@mail.gmail.com>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2006-01/msg00062.html

Bug-Description:

Under some circumstances, background (asynchronous) jobs can set the terminal
process group incorrectly.  This can cause a foreground process (including
the foreground shell) to get read errors and exit.

Patch:

*** ../bash-3.1/jobs.c	Fri Nov 11 23:13:27 2005
--- jobs.c	Wed Feb  1 13:55:38 2006
***************
*** 620,625 ****
  	   * the parent gives it away.
  	   *
  	   */
! 	  if (job_control && newjob->pgrp)
  	    give_terminal_to (newjob->pgrp, 0);
  	}
--- 634,642 ----
  	   * the parent gives it away.
  	   *
+ 	   * Don't give the terminal away if this shell is an asynchronous
+ 	   * subshell.
+ 	   *
  	   */
! 	  if (job_control && newjob->pgrp && (subshell_environment&SUBSHELL_ASYNC) == 0)
  	    give_terminal_to (newjob->pgrp, 0);
  	}
***************
*** 1656,1660 ****
  	     shell's process group (we could be in the middle of a
  	     pipeline, for example). */
! 	  if (async_p == 0 && pipeline_pgrp != shell_pgrp)
  	    give_terminal_to (pipeline_pgrp, 0);
  
--- 1743,1747 ----
  	     shell's process group (we could be in the middle of a
  	     pipeline, for example). */
! 	  if (async_p == 0 && pipeline_pgrp != shell_pgrp && ((subshell_environment&SUBSHELL_ASYNC) == 0))
  	    give_terminal_to (pipeline_pgrp, 0);
  
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 8
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 9
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-010

Bug-Reported-by: vw@vonwolff.de
Bug-Reference-ID: <20060123135234.1AC2F1D596@wst07.vonwolff.de>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2006-01/msg00090.html

Bug-Description:

There is a difference in behavior between bash-3.0 and bash-3.1 involving
parsing of single- and double-quoted strings occurring in old-style
command substitution.  The difference has to do with how backslashes are
processed.  This patch restores a measure of backwards compatibility while
the question of POSIX conformance and ultimately correct behavior is discussed.

THIS IS AN UPDATED PATCH.  USE THIS COMMAND TO REVERSE THE EFFECTS OF
THE ORIGINAL PATCH.  THE CURRENT DIRECTORY MUST BE THE BASH-3.1 SOURCE
DIRECTORY.

patch -p0 -R < bash31-010.orig

Then apply this patch as usual.

Patch:

*** ../bash-3.1/parse.y	Fri Nov 11 23:14:18 2005
--- parse.y	Thu Feb 23 08:21:12 2006
***************
*** 2716,2721 ****
--- 2723,2729 ----
  #define P_ALLOWESC	0x02
  #define P_DQUOTE	0x04
  #define P_COMMAND	0x08	/* parsing a command, so look for comments */
+ #define P_BACKQUOTE	0x10	/* parsing a backquoted command substitution */
  
  static char matched_pair_error;
  static char *
***************
*** 2725,2736 ****
       int *lenp, flags;
  {
    int count, ch, was_dollar, in_comment, check_comment;
!   int pass_next_character, nestlen, ttranslen, start_lineno;
    char *ret, *nestret, *ttrans;
    int retind, retsize, rflags;
  
    count = 1;
!   pass_next_character = was_dollar = in_comment = 0;
    check_comment = (flags & P_COMMAND) && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0;
  
    /* RFLAGS is the set of flags we want to pass to recursive calls. */
--- 2733,2744 ----
       int *lenp, flags;
  {
    int count, ch, was_dollar, in_comment, check_comment;
!   int pass_next_character, backq_backslash, nestlen, ttranslen, start_lineno;
    char *ret, *nestret, *ttrans;
    int retind, retsize, rflags;
  
    count = 1;
!   pass_next_character = backq_backslash = was_dollar = in_comment = 0;
    check_comment = (flags & P_COMMAND) && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0;
  
    /* RFLAGS is the set of flags we want to pass to recursive calls. */
***************
*** 2742,2752 ****
    start_lineno = line_number;
    while (count)
      {
! #if 0
!       ch = shell_getc ((qc != '\'' || (flags & P_ALLOWESC)) && pass_next_character == 0);
! #else
!       ch = shell_getc (qc != '\'' && pass_next_character == 0);
! #endif
        if (ch == EOF)
  	{
  	  free (ret);
--- 2750,2757 ----
    start_lineno = line_number;
    while (count)
      {
!       ch = shell_getc (qc != '\'' && pass_next_character == 0 && backq_backslash == 0);
! 
        if (ch == EOF)
  	{
  	  free (ret);
***************
*** 2771,2779 ****
  	  continue;
  	}
        /* Not exactly right yet */
!       else if (check_comment && in_comment == 0 && ch == '#' && (retind == 0 || ret[retind-1] == '\n' || whitespace (ret[retind -1])))
  	in_comment = 1;
  
        if (pass_next_character)		/* last char was backslash */
  	{
  	  pass_next_character = 0;
--- 2776,2791 ----
  	  continue;
  	}
        /* Not exactly right yet */
!       else if MBTEST(check_comment && in_comment == 0 && ch == '#' && (retind == 0 || ret[retind-1] == '\n' || whitespace (ret[retind - 1])))
  	in_comment = 1;
  
+       /* last char was backslash inside backquoted command substitution */
+       if (backq_backslash)
+ 	{
+ 	  backq_backslash = 0;
+ 	  /* Placeholder for adding special characters */
+ 	}
+ 
        if (pass_next_character)		/* last char was backslash */
  	{
  	  pass_next_character = 0;
***************
*** 2814,2819 ****
--- 2824,2831 ----
  	{
  	  if MBTEST((flags & P_ALLOWESC) && ch == '\\')
  	    pass_next_character++;
+ 	  else if MBTEST((flags & P_BACKQUOTE) && ch == '\\')
+ 	    backq_backslash++;
  	  continue;
  	}
  
***************
*** 2898,2904 ****
  	}
        else if MBTEST(qc == '`' && (ch == '"' || ch == '\'') && in_comment == 0)
  	{
! 	  nestret = parse_matched_pair (0, ch, ch, &nestlen, rflags);
  	  goto add_nestret;
  	}
        else if MBTEST(was_dollar && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
--- 2910,2920 ----
  	}
        else if MBTEST(qc == '`' && (ch == '"' || ch == '\'') && in_comment == 0)
  	{
! 	  /* Add P_BACKQUOTE so backslash quotes the next character and
! 	     shell_getc does the right thing with \<newline>.  We do this for
! 	     a measure  of backwards compatibility -- it's not strictly the
! 	     right POSIX thing. */
! 	  nestret = parse_matched_pair (0, ch, ch, &nestlen, rflags|P_BACKQUOTE);
  	  goto add_nestret;
  	}
        else if MBTEST(was_dollar && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 9
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 10
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-011

Bug-Reported-by: Mike Stroyan <mike.stroyan@hp.com>
Bug-Reference-ID: <E1EvwxP-0004LD-GC@localhost.localdomain>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2006-01/msg00033.html

Bug-Description:

A change in bash-3.1 caused the single quotes to be stripped from ANSI-C
quoting inside double-quoted command substitutions.

Patch:

*** ../bash-3.1/parse.y	Fri Nov 11 23:14:18 2005
--- parse.y	Wed Jan 25 14:55:18 2006
***************
*** 2908,2912 ****
  	    count--;
  	  if (ch == '(')		/* ) */
! 	    nestret = parse_matched_pair (0, '(', ')', &nestlen, rflags);
  	  else if (ch == '{')		/* } */
  	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|rflags);
--- 2914,2918 ----
  	    count--;
  	  if (ch == '(')		/* ) */
! 	    nestret = parse_matched_pair (0, '(', ')', &nestlen, rflags & ~P_DQUOTE);
  	  else if (ch == '{')		/* } */
  	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|rflags);
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 10
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 11
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-012

Bug-Reported-by: Alexander Kshevetskiy <alex@dgap.mipt.ru>
Bug-Reference-ID: <308374997.20060124175849@dgap.mipt.ru>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2006-01/msg00097.html

Bug-Description:

There is a parsing problem involving parentheses in assignment statements
that causes words to be terminated prematurely.

Patch:

*** ../bash-3.1/parse.y	Fri Nov 11 23:14:18 2005
--- parse.y	Wed Jan 25 14:55:18 2006
***************
*** 3579,3583 ****
  	      all_digit_token = 0;
  	      compound_assignment = 1;
! #if 0
  	      goto next_character;
  #else
--- 3584,3588 ----
  	      all_digit_token = 0;
  	      compound_assignment = 1;
! #if 1
  	      goto next_character;
  #else
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 11
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 12
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-013

Bug-Reported-by: Bob Rossi <bob@brasko.net>
Bug-Reference-ID: <43F60606.80708@case.edu>
Bug-Reference-URL:

Bug-Description:

In some cases, readline will reference freed memory when attempting to
display a portion of the prompt.

Patch:

*** ../bash-3.1-patched/lib/readline/readline.c	Mon Jul  4 22:29:35 2005
--- lib/readline/readline.c	Fri Feb 17 22:54:22 2006
***************
*** 282,287 ****
--- 282,288 ----
  {
    FREE (rl_prompt);
    rl_prompt = prompt ? savestring (prompt) : (char *)NULL;
+   rl_display_prompt = rl_prompt ? rl_prompt : "";
  
    rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
    return 0;
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 12
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 13
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-014

Bug-Reported-by: Mike Stroyan <mike.stroyan@hp.com>
Bug-Reference-ID: <20060203191607.GC27614@localhost>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2006-02/msg00004.html

Bug-Description:

The displayed search prompt is corrupted when using non-incremental
searches in vi and emacs mode if the prompt contains non-printing
characters or spans multiple lines.  The prompt is expanded more than
once; the second time without the escape sequences that protect non-
printing characters from the length calculations.

Patch:

*** ../bash-3.1-patched/lib/readline/display.c	Wed Nov 30 14:05:02 2005
--- lib/readline/display.c	Sat Feb 18 12:14:58 2006
***************
*** 1983,1993 ****
       int pchar;
  {
    int len;
!   char *pmt;
  
    rl_save_prompt ();
  
!   if (saved_local_prompt == 0)
      {
        len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
        pmt = (char *)xmalloc (len + 2);
--- 1998,2012 ----
       int pchar;
  {
    int len;
!   char *pmt, *p;
  
    rl_save_prompt ();
  
!   /* We've saved the prompt, and can do anything with the various prompt
!      strings we need before they're restored.  We want the unexpanded
!      portion of the prompt string after any final newline. */
!   p = rl_prompt ? strrchr (rl_prompt, '\n') : 0;
!   if (p == 0)
      {
        len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
        pmt = (char *)xmalloc (len + 2);
***************
*** 1998,2016 ****
      }
    else
      {
!       len = *saved_local_prompt ? strlen (saved_local_prompt) : 0;
        pmt = (char *)xmalloc (len + 2);
        if (len)
! 	strcpy (pmt, saved_local_prompt);
        pmt[len] = pchar;
        pmt[len+1] = '\0';
!       local_prompt = savestring (pmt);
!       prompt_last_invisible = saved_last_invisible;
!       prompt_visible_length = saved_visible_length + 1;
!     }
  
    prompt_physical_chars = saved_physical_chars + 1;
- 
    return pmt;
  }
  
--- 2017,2033 ----
      }
    else
      {
!       p++;
!       len = strlen (p);
        pmt = (char *)xmalloc (len + 2);
        if (len)
! 	strcpy (pmt, p);
        pmt[len] = pchar;
        pmt[len+1] = '\0';
!     }  
  
+   /* will be overwritten by expand_prompt, called from rl_message */
    prompt_physical_chars = saved_physical_chars + 1;
    return pmt;
  }
  
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 13
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 14
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-015

Bug-Reported-by: Benoit Vila
Bug-Reference-ID: <43FCA614.1090108@free.fr>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2006-02/msg00058.html

Bug-Description:

A problem with the extended globbing code prevented dots from matching
filenames when used in some extended matching patterns.

Patch:

*** ../bash-3.1-patched/lib/glob/sm_loop.c	Sun Oct 16 21:21:04 2005
--- lib/glob/sm_loop.c	Mon Feb 27 17:18:43 2006
***************
*** 639,643 ****
    CHAR *pnext;			/* pointer to next sub-pattern */
    CHAR *srest;			/* pointer to rest of string */
!   int m1, m2;
  
  #if DEBUG_MATCHING
--- 638,642 ----
    CHAR *pnext;			/* pointer to next sub-pattern */
    CHAR *srest;			/* pointer to rest of string */
!   int m1, m2, xflags;		/* xflags = flags passed to recursive matches */
  
  #if DEBUG_MATCHING
***************
*** 645,648 ****
--- 644,648 ----
  fprintf(stderr, "extmatch: s = %s; se = %s\n", s, se);
  fprintf(stderr, "extmatch: p = %s; pe = %s\n", p, pe);
+ fprintf(stderr, "extmatch: flags = %d\n", flags);
  #endif
  
***************
*** 678,683 ****
  		 multiple matches of the pattern. */
  	      if (m1)
! 		m2 = (GMATCH (srest, se, prest, pe, flags) == 0) ||
! 		      (s != srest && GMATCH (srest, se, p - 1, pe, flags) == 0);
  	      if (m1 && m2)
  		return (0);
--- 678,687 ----
  		 multiple matches of the pattern. */
  	      if (m1)
! 		{
! 		  /* if srest > s, we are not at start of string */
! 		  xflags = (srest > s) ? (flags & ~FNM_PERIOD) : flags;
! 		  m2 = (GMATCH (srest, se, prest, pe, xflags) == 0) ||
! 			(s != srest && GMATCH (srest, se, p - 1, pe, xflags) == 0);
! 		}
  	      if (m1 && m2)
  		return (0);
***************
*** 705,710 ****
  	  for ( ; srest <= se; srest++)
  	    {
  	      if (GMATCH (s, srest, psub, pnext - 1, flags) == 0 &&
! 		  GMATCH (srest, se, prest, pe, flags) == 0)
  		return (0);
  	    }
--- 709,716 ----
  	  for ( ; srest <= se; srest++)
  	    {
+ 	      /* if srest > s, we are not at start of string */
+ 	      xflags = (srest > s) ? (flags & ~FNM_PERIOD) : flags;
  	      if (GMATCH (s, srest, psub, pnext - 1, flags) == 0 &&
! 		  GMATCH (srest, se, prest, pe, xflags) == 0)
  		return (0);
  	    }
***************
*** 727,731 ****
  		break;
  	    }
! 	  if (m1 == 0 && GMATCH (srest, se, prest, pe, flags) == 0)
  	    return (0);
  	}
--- 733,739 ----
  		break;
  	    }
! 	  /* if srest > s, we are not at start of string */
! 	  xflags = (srest > s) ? (flags & ~FNM_PERIOD) : flags;
! 	  if (m1 == 0 && GMATCH (srest, se, prest, pe, xflags) == 0)
  	    return (0);
  	}
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 14
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 15
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-016

Bug-Reported-by: Nikita Danilov <nikita@clusterfs.com>
Bug-Reference-ID: <17397.51015.769854.541057@gargle.gargle.HOWL>
Bug-Reference-URL: http://lists.gnu.org/archive/html/bug-bash/2006-02/msg00064.html

Bug-Description:

Bash will dump core when attempting to perform globbing in directories with
very large numbers of files.

Patch:

*** ../bash-3.1-patched/lib/glob/glob.c	Thu Mar 24 12:42:27 2005
--- lib/glob/glob.c	Fri Mar  3 16:54:12 2006
***************
*** 361,364 ****
--- 361,365 ----
  
    firstmalloc = 0;
+   nalloca = 0;
  
    /* If PAT is empty, skip the loop, but return one (empty) filename. */
***************
*** 547,550 ****
--- 551,556 ----
  	      tmplink = lastlink;
  	    }
+ 	  else
+ 	    tmplink = 0;
  	  free (lastlink->name);
  	  lastlink = lastlink->next;
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 15
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 16
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-017

Bug-Reported-by: syphir@syphir.sytes.net
Bug-Reference-ID: <442421F5.3010105@syphir.sytes.net>
Bug-Reference-URL: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=358831

Bug-Description:

Array expansion fails with an arithmetic syntax error when the subscript
appears within double quotes.  For example: ${a["4"]}.

Patch:

*** ../bash-3.1-patched/subst.c	Wed Apr 12 08:47:08 2006
--- subst.c	Wed Apr 12 08:49:02 2006
***************
*** 2576,2579 ****
--- 2576,2586 ----
  }
  
+ char *
+ expand_arith_string (string, quoted)
+      char *string;
+ {
+   return (expand_string_if_necessary (string, quoted, expand_string));
+ }
+ 
  #if defined (COND_COMMAND)
  /* Just remove backslashes in STRING.  Returns a new string. */
***************
*** 5249,5253 ****
      t = (char *)0;
  
!   temp1 = expand_string_if_necessary (substr, Q_DOUBLE_QUOTES, expand_string);
    *e1p = evalexp (temp1, &expok);
    free (temp1);
--- 5256,5260 ----
      t = (char *)0;
  
!   temp1 = expand_arith_string (substr, Q_DOUBLE_QUOTES);
    *e1p = evalexp (temp1, &expok);
    free (temp1);
***************
*** 5294,5298 ****
        t++;
        temp2 = savestring (t);
!       temp1 = expand_string_if_necessary (temp2, Q_DOUBLE_QUOTES, expand_string);
        free (temp2);
        t[-1] = ':';
--- 5301,5305 ----
        t++;
        temp2 = savestring (t);
!       temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES);
        free (temp2);
        t[-1] = ':';
***************
*** 6436,6440 ****
  
  	  /* Expand variables found inside the expression. */
! 	  temp1 = expand_string_if_necessary (temp2, Q_DOUBLE_QUOTES, expand_string);
  	  free (temp2);
  
--- 6443,6447 ----
  
  	  /* Expand variables found inside the expression. */
! 	  temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES);
  	  free (temp2);
  
***************
*** 6478,6482 ****
  
         /* Do initial variable expansion. */
!       temp1 = expand_string_if_necessary (temp, Q_DOUBLE_QUOTES, expand_string);
  
        goto arithsub;
--- 6485,6489 ----
  
         /* Do initial variable expansion. */
!       temp1 = expand_arith_string (temp, Q_DOUBLE_QUOTES);
  
        goto arithsub;
*** ../bash-3.1-patched/subst.h	Sun Nov  7 15:12:28 2004
--- subst.h	Mon Mar 27 09:10:38 2006
***************
*** 152,155 ****
--- 152,158 ----
  extern char *expand_assignment_string_to_string __P((char *, int));
  
+ /* Expand an arithmetic expression string */
+ extern char *expand_arith_string __P((char *, int));
+ 
  /* De-quoted quoted characters in STRING. */
  extern char *dequote_string __P((char *));
*** ../bash-3.1-patched/arrayfunc.c	Mon Jul  4 20:25:58 2005
--- arrayfunc.c	Mon Mar 27 09:10:47 2006
***************
*** 593,601 ****
    strncpy (exp, s, len - 1);
    exp[len - 1] = '\0';
! #if 0
!   t = expand_string_to_string (exp, 0);
! #else 
!   t = expand_string_to_string (exp, Q_DOUBLE_QUOTES);
! #endif
    this_command_name = (char *)NULL;
    val = evalexp (t, &expok);
--- 591,595 ----
    strncpy (exp, s, len - 1);
    exp[len - 1] = '\0';
!   t = expand_arith_string (exp, 0);
    this_command_name = (char *)NULL;
    val = evalexp (t, &expok);
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 16
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 17
  
  #endif /* _PATCHLEVEL_H_ */

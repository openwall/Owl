--- bash-2.05/builtins/mkbuiltins.c.orig	Thu Feb 15 00:06:45 2001
+++ bash-2.05/builtins/mkbuiltins.c	Tue Oct 23 01:01:33 2001
@@ -51,8 +51,13 @@
 #define whitespace(c) (((c) == ' ') || ((c) == '\t'))
 
 /* Flag values that builtins can have. */
+/*  These flags are for the C code generator, 
+    the C which is produced (./builtin.c)
+    includes the flags definitions found 
+    in ../builtins.h */
 #define BUILTIN_FLAG_SPECIAL	0x01
 #define BUILTIN_FLAG_ASSIGNMENT 0x02
+#define BUILTIN_FLAG_REQUIRES	0x04
 
 /* If this stream descriptor is non-zero, then write
    texinfo documentation to it. */
@@ -126,9 +131,17 @@
   (char *)NULL
 };
 
+/* The builtin commands that cause requirements on other files. */
+char *requires_builtins[] =
+{
+  ".", "command", "exec", "source", "inlib",
+  (char *)NULL
+};
+
 /* Forward declarations. */
 static int is_special_builtin ();
 static int is_assignment_builtin ();
+static int is_requires_builtin ();
 
 #if !defined (HAVE_RENAME)
 static int rename ();
@@ -759,6 +772,8 @@
     new->flags |= BUILTIN_FLAG_SPECIAL;
   if (is_assignment_builtin (name))
     new->flags |= BUILTIN_FLAG_ASSIGNMENT;
+  if (is_requires_builtin (name))
+    new->flags |= BUILTIN_FLAG_REQUIRES;
 
   array_add ((char *)new, defs->builtins);
   building_builtin = 1;
@@ -1164,10 +1179,11 @@
 		  else
 		    fprintf (structfile, "(Function *)0x0, ");
 
-		  fprintf (structfile, "%s%s%s, %s_doc,\n",
+		  fprintf (structfile, "%s%s%s%s, %s_doc,\n",
 		    "BUILTIN_ENABLED | STATIC_BUILTIN",
 		    (builtin->flags & BUILTIN_FLAG_SPECIAL) ? " | SPECIAL_BUILTIN" : "",
 		    (builtin->flags & BUILTIN_FLAG_ASSIGNMENT) ? " | ASSIGNMENT_BUILTIN" : "",
+		    (builtin->flags & BUILTIN_FLAG_REQUIRES) ? " | REQUIRES_BUILTIN" : "",
 		    builtin->docname ? builtin->docname : builtin->name);
 
 		  fprintf
@@ -1401,6 +1417,13 @@
      char *name;
 {
   return (_find_in_table (name, assignment_builtins));
+}
+
+static int
+is_requires_builtin (name)
+     char *name;
+{
+  return (_find_in_table (name, requires_builtins));
 }
 
 #if !defined (HAVE_RENAME)
--- bash-2.05/doc/bash.1.orig	Mon Mar  5 21:41:30 2001
+++ bash-2.05/doc/bash.1	Tue Oct 23 01:01:33 2001
@@ -200,6 +200,12 @@
 .B "RESTRICTED SHELL"
 below).
 .TP
+.B \-\-rpm-requires
+Produce the list of files that are required for the 
+shell script to run.  This implies '-n' and is subject
+to the same limitations as compile time error checking checking;
+Backticks, [] tests,  and evals are not parsed so some 
+dependencies may be missed.
 .B \-\-verbose
 Equivalent to  \fB\-v\fP.
 .TP
--- bash-2.05/doc/bashref.texi.orig	Wed Mar 28 22:49:52 2001
+++ bash-2.05/doc/bashref.texi	Tue Oct 23 01:01:34 2001
@@ -4375,6 +4375,13 @@
 @item --restricted
 Make the shell a restricted shell (@pxref{The Restricted Shell}).
 
+@item --rpm-requires
+Produce the list of files that are required for the 
+shell script to run.  This implies '-n' and is subject
+to the same limitations as compile time error checking checking;
+Backticks, [] tests,  and evals are not parsed so some 
+dependencies may be missed.
+
 @item --verbose
 Equivalent to @option{-v}.  Print shell input lines as they're read.
 
--- bash-2.05/builtins.h.orig	Thu Aug  5 14:18:12 1999
+++ bash-2.05/builtins.h	Tue Oct 23 01:01:34 2001
@@ -40,6 +40,7 @@
 #define STATIC_BUILTIN  0x4	/* This builtin is not dynamically loaded. */
 #define SPECIAL_BUILTIN 0x8	/* This is a Posix `special' builtin. */
 #define ASSIGNMENT_BUILTIN 0x10	/* This builtin takes assignment statements. */
+#define REQUIRES_BUILTIN 0x20	/* This builtin requires other files. */
 
 /* The thing that we build the array of builtins out of. */
 struct builtin {
--- bash-2.05/make_cmd.c.orig	Wed Feb 14 23:54:04 2001
+++ bash-2.05/make_cmd.c	Tue Oct 23 01:01:34 2001
@@ -42,6 +42,9 @@
 #include "subst.h"
 #include "input.h"
 #include "externs.h"
+#include "builtins.h"
+
+#include "builtins/common.h"
 
 #if defined (JOB_CONTROL)
 #include "jobs.h"
@@ -50,7 +53,10 @@
 extern int line_number, current_command_line_count;
 extern int disallow_filename_globbing;
 extern int last_command_exit_value;
+extern int rpm_requires;
 
+char *alphabet_set = "abcdefghijklmnopqrstuvwxyz"
+		     "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 
 WORD_DESC *
 make_bare_word (string)
@@ -697,6 +703,36 @@
   return (make_command (cm_subshell, (SIMPLE_COM *)temp));
 }
 
+void
+output_requirement (file)
+char *file;
+{
+  if ( (file[0] != '/') || strchr(file, '$')) {
+    /* if we are not given a full path name we require the basename
+       otherwise we require the full path.  This does not work in the
+       Win/Dos world but I don't know what to do there.*/
+    char *basename;
+    basename = strrchr(file, '/');
+    if (basename) {    
+      basename++;
+      file=basename;
+    }
+  }  
+
+    /* 
+       if the executable is called via variable substitution we can
+       not dermine what it is at compile time.  
+
+       if the executable consists only of characters not in the
+       alphabet we do not consider it a dependency just an artifact of
+       shell parsing (ex "exec < ${infile}").
+    */
+
+  if ( !strchr(file, '$') && strpbrk(file, alphabet_set) ) {
+    printf ("executable(%s)\n", file);
+  }
+}
+
 /* Reverse the word list and redirection list in the simple command
    has just been parsed.  It seems simpler to do this here the one
    time then by any other method that I can think of. */
@@ -713,6 +749,35 @@
       command->value.Simple->redirects =
 	REVERSE_LIST (command->value.Simple->redirects, REDIRECT *);
     }
+
+  if (rpm_requires && command->value.Simple->words)
+    {
+      char *cmd0;
+      char *cmd1;
+      struct builtin *b;
+
+      cmd0 = command->value.Simple->words->word->word;
+      b = builtin_address_internal (cmd0, 0);
+      cmd1 = 0;
+      if (command->value.Simple->words->next) {
+	cmd1 = command->value.Simple->words->next->word->word;
+      }
+      if (b) {
+	if ( (b->flags & REQUIRES_BUILTIN) && cmd1){
+	  output_requirement(cmd1);
+	}
+      } else {
+	if (!assignment(cmd0)) {
+	  output_requirement(cmd0);
+	} else {
+
+	  /* This will not work, the subshell that this runs in does
+             not get the "requires" commandline argument. */
+
+	  execute_command(command);
+	}
+      }
+    } /*rpm_requires*/
 
   return (command);
 }
--- bash-2.05/shell.c.orig	Tue Mar 27 17:25:51 2001
+++ bash-2.05/shell.c	Tue Oct 23 01:01:34 2001
@@ -163,6 +163,9 @@
 /* The name of the .(shell)rc file. */
 static char *bashrc_file = "~/.bashrc";
 
+/* Non-zero if we are finding the scripts requirements. */
+int rpm_requires;
+
 /* Non-zero means to act more like the Bourne shell on startup. */
 static int act_like_sh;
 
@@ -209,6 +212,7 @@
   { "norc", Int, &no_rc, (char **)0x0 },
   { "posix", Int, &posixly_correct, (char **)0x0 },
   { "rcfile", Charp, (int *)0x0, &bashrc_file },
+  { "rpm-requires", Int, &rpm_requires, (char **)0x0 },
 #if defined (RESTRICTED_SHELL)
   { "restricted", Int, &restricted, (char **)0x0 },
 #endif
@@ -397,6 +401,12 @@
 
   if (dump_translatable_strings)
     read_but_dont_execute = 1;
+
+  if (rpm_requires)
+    {
+      read_but_dont_execute = 1;
+      initialize_shell_builtins ();
+    }
 
   if (running_setuid && privileged_mode == 0)
     disable_priv_mode ();

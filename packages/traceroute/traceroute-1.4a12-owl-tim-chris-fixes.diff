diff -ur traceroute-1.4a12.orig/findsaddr-linux.c traceroute-1.4a12/findsaddr-linux.c
--- traceroute-1.4a12.orig/findsaddr-linux.c	Thu Nov 23 23:17:21 2000
+++ traceroute-1.4a12/findsaddr-linux.c	Thu Mar  8 16:46:24 2001
@@ -74,6 +74,27 @@
 
 static const char route[] = "/proc/net/route";
 
+static char errbuf[256];
+static FILE *f = NULL;
+
+const char *
+findsaddr_init(void)
+{
+	if ((f = fopen(route, "r")) == NULL) {
+		sprintf(errbuf, "fopen %s: %.128s", route, strerror(errno));
+		return (errbuf);
+	}
+
+	return NULL;
+}
+
+void findsaddr_done(void)
+{
+	if (f)
+		fclose(f);
+	f = NULL;
+}
+
 /*
  * Return the source address for the given destination address
  */
@@ -82,17 +103,13 @@
     register struct sockaddr_in *from)
 {
 	register int i, n;
-	register FILE *f;
 	register u_int32_t mask;
 	u_int32_t dest, tmask;
 	struct ifaddrlist *al;
 	char buf[256], tdevice[256], device[256];
-	static char errbuf[132];
 
-	if ((f = fopen(route, "r")) == NULL) {
-		sprintf(errbuf, "open %s: %.128s", route, strerror(errno));
-		return (errbuf);
-	}
+	if (!f)
+		return ("Not initialized");
 
 	/* Find the appropriate interface */
 	n = 0;
@@ -111,7 +128,6 @@
 			strcpy(device, tdevice);
 		}
 	}
-	fclose(f);
 
 	if (device[0] == '\0')
 		return ("Can't find interface");
diff -ur traceroute-1.4a12.orig/findsaddr.h traceroute-1.4a12/findsaddr.h
--- traceroute-1.4a12.orig/findsaddr.h	Mon Nov 20 02:13:38 2000
+++ traceroute-1.4a12/findsaddr.h	Thu Mar  8 16:46:38 2001
@@ -20,4 +20,6 @@
  *
  * @(#) $Id: findsaddr.h,v 1.1 2000/11/19 23:13:38 leres Exp $ (LBL)
  */
+const char *findsaddr_init(void);
+void findsaddr_done(void);
 const char *findsaddr(const struct sockaddr_in *, struct sockaddr_in *);
diff -ur traceroute-1.4a12.orig/traceroute.c traceroute-1.4a12/traceroute.c
--- traceroute-1.4a12.orig/traceroute.c	Thu Dec 14 11:04:50 2000
+++ traceroute-1.4a12/traceroute.c	Thu Mar  8 17:16:46 2001
@@ -254,7 +254,7 @@
 #define NGATEWAYS ((int)((MAX_IPOPTLEN - IPOPT_MINOFF - 1) / sizeof(u_int32_t)))
 
 #ifndef MAXHOSTNAMELEN
-#define MAXHOSTNAMELEN	64
+#define MAXHOSTNAMELEN	256
 #endif
 
 #define Fprintf (void)fprintf
@@ -372,6 +372,7 @@
 	register u_short off = 0;
 	struct ifaddrlist *al;
 	char errbuf[132];
+	int nullfd;
 
 	if (argv[0] == NULL)
 		prog = "traceroute";
@@ -380,6 +381,63 @@
 	else
 		prog = argv[0];
 
+	cp = "icmp";
+	if ((pe = getprotobyname(cp)) == NULL) {
+		Fprintf(stderr, "%s: unknown protocol %s\n", prog, cp);
+		exit(1);
+	}
+
+	/* Ensure the socket fds won't be 0, 1 or 2 */
+	do {
+		nullfd = open(devnull, O_RDWR);
+		if (nullfd < 0) {
+			Fprintf(stderr, "%s: open \"%s\": %s\n",
+			    prog, devnull, strerror(errno));
+			exit(1);
+		}
+	} while (nullfd < 3);
+	close (nullfd);
+
+	if ((s = socket(AF_INET, SOCK_RAW, pe->p_proto)) < 0) {
+		Fprintf(stderr, "%s: icmp socket: %s\n", prog, strerror(errno));
+		exit(1);
+	} else if (s < 2) {
+		/*
+		 * we tried to ensure this would not happen, but something
+		 * went wrong. we can't write our error message here because
+		 * stderr might be the raw socket we just opened. bail.
+		 */
+		exit(1);
+	}
+
+#ifndef __hpux
+	sndsock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
+#else
+	sndsock = socket(AF_INET, SOCK_RAW,
+	    useicmp ? IPPROTO_ICMP : IPPROTO_UDP);
+#endif
+	if (sndsock < 0) {
+		Fprintf(stderr, "%s: raw socket: %s\n", prog, strerror(errno));
+		exit(1);
+	} else if (sndsock < 2)
+		exit(1);
+
+	if ((err = findsaddr_init()) != NULL) {
+		Fprintf(stderr, "%s: findsaddr_init: %s\n",
+		    prog, err);
+		exit(1);
+	}
+
+	/* Revert to non-privileged user */
+	if (setgid(getgid())) {
+		Fprintf(stderr, "%s: setgid: %s\n", prog, strerror(errno));
+		exit(1);
+	}
+	if (setuid(getuid())) {
+		Fprintf(stderr, "%s: setuid: %s\n", prog, strerror(errno));
+		exit(1);
+	}
+
 	opterr = 0;
 	while ((op = getopt(argc, argv, "dFInrvxf:g:i:m:p:q:s:t:w:z:")) != EOF)
 		switch (op) {
@@ -429,7 +487,8 @@
 			break;
 
 		case 'q':
-			nprobes = str2val(optarg, "nprobes", 1, -1);
+			nprobes = str2val(optarg, "nprobes", 1,
+				(getuid() == 0) ? -1 : 3);
 			break;
 
 		case 'r':
@@ -584,24 +643,6 @@
 		outdata = (struct outdata *)(outudp + 1);
 	}
 
-	cp = "icmp";
-	if ((pe = getprotobyname(cp)) == NULL) {
-		Fprintf(stderr, "%s: unknown protocol %s\n", prog, cp);
-		exit(1);
-	}
-
-	/* Insure the socket fds won't be 0, 1 or 2 */
-	if (open(devnull, O_RDONLY) < 0 ||
-	    open(devnull, O_RDONLY) < 0 ||
-	    open(devnull, O_RDONLY) < 0) {
-		Fprintf(stderr, "%s: open \"%s\": %s\n",
-		    prog, devnull, strerror(errno));
-		exit(1);
-	}
-	if ((s = socket(AF_INET, SOCK_RAW, pe->p_proto)) < 0) {
-		Fprintf(stderr, "%s: icmp socket: %s\n", prog, strerror(errno));
-		exit(1);
-	}
 	if (options & SO_DEBUG)
 		(void)setsockopt(s, SOL_SOCKET, SO_DEBUG, (char *)&on,
 		    sizeof(on));
@@ -609,17 +650,6 @@
 		(void)setsockopt(s, SOL_SOCKET, SO_DONTROUTE, (char *)&on,
 		    sizeof(on));
 
-#ifndef __hpux
-	sndsock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
-#else
-	sndsock = socket(AF_INET, SOCK_RAW,
-	    useicmp ? IPPROTO_ICMP : IPPROTO_UDP);
-#endif
-	if (sndsock < 0) {
-		Fprintf(stderr, "%s: raw socket: %s\n", prog, strerror(errno));
-		exit(1);
-	}
-
 #if defined(IP_OPTIONS) && !defined(HAVE_RAW_OPTIONS)
 	if (lsrr > 0) {
 		u_char optlist[MAX_IPOPTLEN];
@@ -742,7 +772,18 @@
 			}
 			setsin(from, *ap);
 		} else {
-			setsin(from, hi->addrs[0]);
+			do {
+				for (i = 0; i < hi->n; i++)
+					if (hi->addrs[i] == al->addr)
+						break;
+				if (i < hi->n) break;
+				al++;
+			} while (--n > 0);
+			if (n <= 0) {
+				i = 0;
+				/* bind() should fail */
+			}
+			setsin(from, hi->addrs[i]);
 			if (hi->n > 1)
 				Fprintf(stderr,
 			"%s: Warning: %s has multiple addresses; using %s\n",
@@ -751,18 +792,32 @@
 		freehostinfo(hi);
 	}
 
-	/* Revert to non-privileged user after opening sockets */
-	setgid(getgid());
-	setuid(getuid());
+	findsaddr_done();
 
 	outip->ip_src = from->sin_addr;
-#ifndef IP_HDRINCL
-	if (bind(sndsock, (struct sockaddr *)from, sizeof(*from)) < 0) {
+
+	/*
+	 * This is needed even when we have IP_HDRINCL in order to ensure
+	 * that the source address actually belongs to our machine.
+	 */
+	if (bind(sndsock, (struct sockaddr *)from, sizeof(*from)) < 0
+#ifdef IP_HDRINCL
+	    && getuid() != 0) {
+#else
+	    ) {
+#endif
 		Fprintf(stderr, "%s: bind: %s\n",
 		    prog, strerror(errno));
 		exit (1);
 	}
-#endif
+
+	if (getuid() != 0 &&
+	    (ntohl(from->sin_addr.s_addr) & 0xff000000U) == 0x7f000000U &&
+	    (ntohl(to->sin_addr.s_addr) & 0xff000000U) != 0x7f000000U) {
+		Fprintf(stderr, "%s: source is on 127/8, destination isn't\n",
+		    prog);
+		exit(1);
+	}
 
 	Fprintf(stderr, "%s to %s (%s)",
 	    prog, hostname, inet_ntoa(to->sin_addr));
@@ -1259,7 +1314,7 @@
 	register char **p;
 	register u_int32_t addr, *ap;
 
-	if (strlen(hostname) > 64) {
+	if (strlen(hostname) > MAXHOSTNAMELEN) {
 		Fprintf(stderr, "%s: hostname \"%.32s...\" is too long\n",
 		    prog, hostname);
 		exit(1);
@@ -1382,7 +1437,7 @@
 	Fprintf(stderr, "Version %s\n", version);
 	Fprintf(stderr,
 	    "Usage: %s [-dFInrvx] [-g gateway] [-i iface] [-f first_ttl]\n"
-	    "\t[-m max_ttl] [ -p port] [-q nqueries] [-s src_addr] [-t tos]\n"
+	    "\t[-m max_ttl] [-p port] [-q nqueries] [-s src_addr] [-t tos]\n"
 	    "\t[-w waittime] [-z pausemsecs] host [packetlen]\n", prog);
 	exit(1);
 }

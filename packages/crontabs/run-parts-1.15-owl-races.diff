diff -ur run-parts-1.15.orig/run-parts.c run-parts-1.15/run-parts.c
--- run-parts-1.15.orig/run-parts.c	Mon Jan  8 05:57:18 2001
+++ run-parts-1.15/run-parts.c	Fri May 25 02:50:16 2001
@@ -25,6 +25,7 @@
 #include <errno.h>
 #include <ctype.h>
 #include <signal.h>
+#include <setjmp.h>
 #include <sys/time.h>
 
 #define VERSION "1.15"
@@ -139,11 +140,11 @@
   }
 }
 
+jmp_buf sigchld_jmp;
+volatile int sigchld_jmp_enable;
 
-/* We have to abort the select() call in run_part when we receive a
- * SIGCHLD signal. We can't simply ignore it, so we do nothing.
- */
 void catch_sigchld(int sig) {
+  if (sigchld_jmp_enable) longjmp(sigchld_jmp, 1);
 }
 
 
@@ -154,10 +155,29 @@
   int pid;
   int pout[2], perr[2];
 
+  (void) &pid;
+
   if (report_mode && (pipe(pout) || pipe(perr))) {
     error("pipe: %s", strerror(errno));
     exit(1);
   }
+
+  if (report_mode) {
+    pid = 0;
+    sigchld_jmp_enable = 0;
+    if (setjmp(sigchld_jmp)) {
+      if (waitpid(pid, &result, 0) > 0) {
+	if (pout[0]) close(pout[0]);
+	if (perr[0]) close(perr[0]);
+	goto out;
+      }
+      error("waitpid: %s", strerror(errno));
+      exit(1);
+    }
+
+    signal(SIGCHLD, catch_sigchld);
+  }
+
   if ((pid=fork()) < 0) {
     error("failed to fork: %s", strerror(errno));
     exit(1);
@@ -182,34 +202,34 @@
 
   if (report_mode) {
     fd_set set;
-    int max, r, w, printflag, errno_select;
+    int max, r, printflag, errno_select;
     ssize_t c;
     char buf[4096];
-    struct timeval zerotime, *timeout;
-    struct sigaction sa, sold;
-    
+
     close(pout[1]);
     close(perr[1]);
     set_fl(pout[0], O_NONBLOCK);
     set_fl(perr[0], O_NONBLOCK);
     max = pout[0] > perr[0] ? pout[0]+1 : perr[0]+1;
     printflag = 0;
-    zerotime.tv_usec = 0;
-    zerotime.tv_sec = 0;
-    timeout = NULL;
-    sigaction(SIGCHLD, NULL, &sa);
-    sa.sa_handler = catch_sigchld;
-    
+
     for (;;) {
       FD_ZERO(&set);
       if (pout[0] >= 0) FD_SET(pout[0], &set);
       if (perr[0] >= 0) FD_SET(perr[0], &set);
 
-      /* select() call may be interrupted by SIGCHLD */
-      sigaction(SIGCHLD, &sa, &sold);
-      r = select(max, &set, 0, 0, timeout);
+      sigchld_jmp_enable = 1;
+
+      if (waitpid(pid, &result, WNOHANG) > 0) {
+	if (pout[0]) close(pout[0]);
+	if (perr[0]) close(perr[0]);
+	break;
+      }
+
+      r = select(max, &set, NULL, NULL, NULL);
       errno_select = errno;
-      sigaction(SIGCHLD, &sold, NULL);
+
+      sigchld_jmp_enable = 0;
 
       if (r > 0) {
 	if (pout[0] >= 0 && FD_ISSET(pout[0], &set)) {
@@ -243,37 +263,17 @@
 	  }
 	}
       }
-      else if (r < 0) {
-	/* select() was interrupted so check if we got a SIGCHLD
-	 * probably from our child (check this later).
-	 */
-	if (errno_select != EINTR) {
-	  error("select: %s", strerror(errno_select));
-	  exit(1);
-	}
-      }
-      else if (timeout == NULL) {	/* should never happen */
-	error("internal error: select() returned 0 !");
-	exit(1);
-      }
-      if (timeout == NULL) {
-        w = waitpid(pid, &result, WNOHANG);
-        if (w > 0) {
-          /* Our child has died so prepare to flush the pipes */
-          timeout = &zerotime;
-	}  
-      }
       else {
-	if (pout[0]) close(pout[0]);
-	if (perr[0]) close(perr[0]);
-	break;
+	error("select: %s", r ? strerror(errno_select) : "returned 0");
+	exit(1);
       }
     }
   }
   else {
     waitpid(pid, &result, 0);
   }
-  
+
+out:
   if (WIFEXITED (result) && WEXITSTATUS(result)) {
     error ("%s exited with return code %d", progname, WEXITSTATUS(result));
     exitstatus = 1;

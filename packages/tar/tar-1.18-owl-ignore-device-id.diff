Add --ignore-device-id option

--- tar/doc/tar.texi
+++ tar/doc/tar.texi
@@ -2631,6 +2631,13 @@
 @item --ignore-command-error
 Ignore exit codes of subprocesses. @xref{Writing to an External Program}.
 
+@opsummary{ignore-device-id}
+@item --ignore-device-id
+
+Used with the @option{--listed-incremental} option, instructs @command{tar} to
+ignore device numbers when comparing files with members of incremental
+archives.  @xref{Incremental Dumps}, for details.
+
 @opsummary{ignore-failed-read}
 @item --ignore-failed-read
 
@@ -5418,10 +5425,19 @@
 comparing directories; this is fairly gross, but there does not seem
 to be a better way to go.
 
+@opindex ignore-device-id
 If you are using the @i{Linux} kernel, the device numbers can also
 change when upgrading to some newer versions of the kernel.  This can
 cause the next backup to be full backup on the affected filesystems.
 @xref{Fixing Snapshot Files}, for the information on how to handle this case.
+If this approach does not work for you, the @option{--ignore-device-id}
+option, used when creating incremental archives, makes tar treat any
+filesystem as an NFS device.
+
+One filesystem for which volatile device numbers when restoring from
+incremental dumps may be an issue is @acronym{simfs} used by
+@acronym{OpenVZ}, an operating system-level virtualization technology based
+on the @i{Linux} kernel. 
 
 Note that incremental archives use @command{tar} extensions and may
 not be readable by non-@acronym{GNU} versions of the @command{tar} program.
--- tar/src/common.h
+++ tar/src/common.h
@@ -195,6 +195,8 @@
 /* Specified file name for incremental list.  */
 GLOBAL const char *listed_incremental_option;
 
+GLOBAL bool ignore_device_id_option;
+
 /* Specified mode change string.  */
 GLOBAL struct mode_change *mode_option;
 
--- tar/src/incremen.c
+++ tar/src/incremen.c
@@ -61,6 +61,7 @@
 				   rescanned */
     enum children children;     /* What to save under this directory */
     unsigned flags;             /* See DIRF_ macros above */
+    bool ignore_device_id;            /* must be only passed to hash_lookup */
     struct directory *orig;     /* If the directory was renamed, points to
 				   the original directory structure */
     char name[1];		/* file name of directory */
@@ -99,7 +100,8 @@
 {
   struct directory const *directory = entry;
   /* FIXME: Work out a better algorytm */
-  return (directory->device_number + directory->inode_number) % n_buckets;
+  /* --ignore-device-id will only work if device_number is not used here! */
+  return ((ignore_device_id_option ? 0 : directory->device_number) + directory->inode_number) % n_buckets;
 }
 
 /* Compare two directories for equality of their device and inode numbers. */
@@ -108,7 +110,8 @@
 {
   struct directory const *directory1 = entry1;
   struct directory const *directory2 = entry2;
-  return directory1->device_number == directory2->device_number
+  return (directory1->ignore_device_id || directory2->ignore_device_id ||
+          directory1->device_number == directory2->device_number)
             && directory1->inode_number == directory2->inode_number;
 }
 
@@ -122,6 +125,7 @@
   directory->contents = directory->icontents = NULL;
   directory->orig = NULL;
   directory->flags = false;
+  directory->ignore_device_id = false;
   strcpy (directory->name, name);
   if (ISSLASH (directory->name[namelen-1]))
     directory->name[namelen-1] = 0;
@@ -191,7 +195,7 @@
 /* Return a directory entry for a given combination of device and inode
    numbers, or zero if none found.  */
 static struct directory *
-find_directory_meta (dev_t dev, ino_t ino)
+find_directory_meta (dev_t dev, ino_t ino, bool ignore_device_id)
 {
   if (! directory_meta_table)
     return 0;
@@ -201,6 +205,7 @@
       struct directory *ret;
       dir->device_number = dev;
       dir->inode_number = ino;
+      dir->ignore_device_id = ignore_device_id;
       ret = hash_lookup (directory_meta_table, dir);
       free (dir);
       return ret;
@@ -247,13 +252,14 @@
 	 directories, consider all NFS devices as equal,
 	 relying on the i-node to establish differences.  */
 
-      if (! (((DIR_IS_NFS (directory) & nfs)
+      if (! (((DIR_IS_NFS (directory) && nfs)
+        || ignore_device_id_option
 	      || directory->device_number == stat_data->st_dev)
 	     && directory->inode_number == stat_data->st_ino))
 	{
 	  /* FIXME: find_directory_meta ignores nfs */
 	  struct directory *d = find_directory_meta (stat_data->st_dev,
-						     stat_data->st_ino);
+						     stat_data->st_ino, DIR_IS_NFS (directory) && nfs || ignore_device_id_option);
 	  if (d)
 	    {
 	      if (verbose_option)
@@ -284,7 +290,7 @@
   else
     {
       struct directory *d = find_directory_meta (stat_data->st_dev,
-						 stat_data->st_ino);
+						 stat_data->st_ino, nfs || ignore_device_id_option);
 
       directory = note_directory (name_buffer,
 				  get_stat_mtime(stat_data),
--- tar/src/tar.c
+++ tar/src/tar.c
@@ -321,7 +321,8 @@
   VERSION_OPTION,
   VOLNO_FILE_OPTION,
   WILDCARDS_MATCH_SLASH_OPTION,
-  WILDCARDS_OPTION
+  WILDCARDS_OPTION,
+  IGNORE_DEVICE_ID_OPTION
 };
 
 const char *argp_program_version = "tar (" PACKAGE_NAME ") " VERSION;
@@ -408,6 +409,8 @@
       " NUMBER defaults to 1"), GRID+1 },
   {"seek", 'n', NULL, 0,
    N_("archive is seekable"), GRID+1 },
+  {"ignore-device-id", IGNORE_DEVICE_ID_OPTION, 0, 0,
+   N_("ignore device ids when doing incremental backups"), GRID+1 },
 #undef GRID
 
 #define GRID 30
@@ -1905,6 +1908,10 @@
       _argp_hang = atoi (arg ? arg : "3600");
       while (_argp_hang-- > 0)
 	sleep (1);
+      break;
+
+    case IGNORE_DEVICE_ID_OPTION:
+      ignore_device_id_option = 1;
       break;
 
     default:

--- perl-5.8.3.orig/ext/Sys/Syslog/Syslog.pm	2003-09-14 10:57:59 +0000
+++ perl-5.8.3/ext/Sys/Syslog/Syslog.pm	2005-12-06 18:05:39 +0000
@@ -1,17 +1,16 @@
 package Sys::Syslog;
-require 5.000;
+require 5.006;
 require Exporter;
-require DynaLoader;
 use Carp;
+use strict;
 
-@ISA = qw(Exporter DynaLoader);
-@EXPORT = qw(openlog closelog setlogmask syslog);
-@EXPORT_OK = qw(setlogsock);
-$VERSION = '0.04';
+our @ISA = qw(Exporter);
+our @EXPORT = qw(openlog closelog setlogmask syslog);
+our @EXPORT_OK = qw(setlogsock);
+our $VERSION = '0.08';
 
 # it would be nice to try stream/unix first, since that will be
 # most efficient. However streams are dodgy - see _syslog_send_stream
-#my @connectMethods = ( 'stream', 'unix', 'tcp', 'udp' );
 my @connectMethods = ( 'tcp', 'udp', 'unix', 'stream', 'console' );
 if ($^O =~ /^(freebsd|linux)$/) {
     @connectMethods = grep { $_ ne 'udp' } @connectMethods;
@@ -22,8 +21,9 @@ my $transmit_ok = 0;
 my $current_proto = undef;
 my $failed = undef;
 my $fail_time = undef;
+our ($connected, @fallbackMethods, $syslog_send, $host);
 
-use Socket;
+use Socket ':all';
 use Sys::Hostname;
 
 =head1 NAME
@@ -53,26 +53,38 @@ Syslog provides the functions:
 
 =item openlog $ident, $logopt, $facility
 
+Opens the syslog.
 I<$ident> is prepended to every message.  I<$logopt> contains zero or
 more of the words I<pid>, I<ndelay>, I<nowait>.  The cons option is
 ignored, since the failover mechanism will drop down to the console
 automatically if all other media fail.  I<$facility> specifies the
 part of the system to report about, for example LOG_USER or LOG_LOCAL0:
 see your C<syslog(3)> documentation for the facilities available in
-your system.
+your system. This function will croak if it can't connect to the syslog
+daemon.
 
 B<You should use openlog() before calling syslog().>
 
+=item syslog $priority, $message
+
 =item syslog $priority, $format, @args
 
-If I<$priority> permits, logs I<($format, @args)>
-printed as by C<printf(3V)>, with the addition that I<%m>
-is replaced with C<"$!"> (the latest error message).
+If I<$priority> permits, logs I<$message> or I<sprintf($format, @args)>
+with the addition that I<%m> in $message or $format is replaced with
+C<"$!"> (the latest error message).
 
 If you didn't use openlog() before using syslog(), syslog will try to
 guess the I<$ident> by extracting the shortest prefix of I<$format>
 that ends in a ":".
 
+Note that Sys::Syslog version v0.07 and older passed the $message as
+the formatting string to sprintf() even when no formatting arguments
+were provided.  If the code calling syslog() might execute with older
+versions of this module, make sure to call the function as
+syslog($priority, "%s", $message) instead of syslog($priority,
+$message).  This protects against hostile formatting sequences that
+might show up if $message contains tainted data.
+
 =item setlogmask $mask_priority
 
 Sets log mask I<$mask_priority> and returns the old mask.
@@ -114,7 +126,7 @@ Note that C<openlog> now takes three arg
 =head1 EXAMPLES
 
     openlog($program, 'cons,pid', 'user');
-    syslog('info', 'this is another test');
+    syslog('info', '%s', 'this is another test');
     syslog('mail|warning', 'this is a better test: %d', time);
     closelog();
 
@@ -128,6 +140,12 @@ Note that C<openlog> now takes three arg
     $! = 55;
     syslog('info', 'problem was %m'); # %m == $! in syslog(3)
 
+    # Log to UDP port on $remotehost instead of logging locally
+    setlogsock('udp');
+    $Sys::Syslog::host = $remotehost;
+    openlog($program, 'ndelay', 'user');
+    syslog('info', 'something happened over here');
+
 =head1 SEE ALSO
 
 L<syslog(3)>
@@ -163,36 +181,38 @@ sub AUTOLOAD {
     if ($error) {
 	croak $error;
     }
+    no strict 'refs';
     *$AUTOLOAD = sub { $val };
     goto &$AUTOLOAD;
 }
 
-bootstrap Sys::Syslog $VERSION;
+require XSLoader;
+XSLoader::load('Sys::Syslog', $VERSION);
 
-$maskpri = &LOG_UPTO(&LOG_DEBUG);
+our $maskpri = &LOG_UPTO(&LOG_DEBUG);
 
 sub openlog {
-    ($ident, $logopt, $facility) = @_;  # package vars
-    $lo_pid = $logopt =~ /\bpid\b/;
-    $lo_ndelay = $logopt =~ /\bndelay\b/;
-    $lo_nowait = $logopt =~ /\bnowait\b/;
+    our ($ident, $logopt, $facility) = @_;  # package vars
+    our $lo_pid = $logopt =~ /\bpid\b/;
+    our $lo_ndelay = $logopt =~ /\bndelay\b/;
+    our $lo_nowait = $logopt =~ /\bnowait\b/;
     return 1 unless $lo_ndelay;
     &connect;
 } 
 
 sub closelog {
-    $facility = $ident = '';
+    our $facility = our $ident = '';
     &disconnect;
 } 
 
 sub setlogmask {
-    local($oldmask) = $maskpri;
+    my $oldmask = $maskpri;
     $maskpri = shift;
     $oldmask;
 }
  
 sub setlogsock {
-    local($setsock) = shift;
+    my $setsock = shift;
     $syslog_path = shift;
     &disconnect if $connected;
     $transmit_ok = 0;
@@ -254,10 +274,11 @@ sub setlogsock {
 }
 
 sub syslog {
-    local($priority) = shift;
-    local($mask) = shift;
-    local($message, $whoami);
-    local(@words, $num, $numpri, $numfac, $sum);
+    my $priority = shift;
+    my $mask = shift;
+    my ($message, $whoami);
+    my (@words, $num, $numpri, $numfac, $sum);
+    our $facility;
     local($facility) = $facility;	# may need to change temporarily.
 
     croak "syslog: expecting argument \$priority" unless $priority;
@@ -292,7 +313,7 @@ sub syslog {
 
     &connect unless $connected;
 
-    $whoami = $ident;
+    $whoami = our $ident;
 
     if (!$whoami && $mask =~ /^(\S.*?):\s?(.*)/) {
 	$whoami = $1;
@@ -305,11 +326,18 @@ sub syslog {
 		($whoami = 'syslog');
     }
 
-    $whoami .= "[$$]" if $lo_pid;
+    $whoami .= "[$$]" if our $lo_pid;
+
+    if ($mask =~ /%m/) {
+	my $err = $!;
+	# escape percent signs if sprintf will be called
+	$err =~ s/%/%%/g if @_;
+	# replace %m with $err, if preceded by an even number of percent signs
+	$mask =~ s/(?<!%)((?:%%)*)%m/$1$err/g;
+    }
 
-    $mask =~ s/%m/$!/g;
     $mask .= "\n" unless $mask =~ /\n$/;
-    $message = sprintf ($mask, @_);
+    $message = @_ ? sprintf($mask, @_) : $mask;
 
     $sum = $numpri + $numfac;
     my $buf = "<$sum>$whoami: $message\0";
@@ -357,6 +385,7 @@ sub _syslog_send_console {
     # so we do it in a child process and always return success
     # to the caller.
     if (my $pid = fork) {
+	our $lo_nowait;
 	if ($lo_nowait) {
 	    return 1;
 	} else {
@@ -393,12 +422,13 @@ sub _syslog_send_socket {
 }
 
 sub xlate {
-    local($name) = @_;
+    my($name) = @_;
+    return $name+0 if $name =~ /^\s*\d+\s*$/;
     $name = uc $name;
     $name = "LOG_$name" unless $name =~ /^LOG_/;
     $name = "Sys::Syslog::$name";
     # Can't have just eval { &$name } || -1 because some LOG_XXX may be zero.
-    my $value = eval { &$name };
+    my $value = eval { no strict 'refs'; &$name };
     defined $value ? $value : -1;
 }
 
@@ -412,15 +442,16 @@ sub connect {
     my @errs = ();
     my $proto = undef;
     while ($proto = shift(@fallbackMethods)) {
+	no strict 'refs';
 	my $fn = "connect_$proto";
-	$connected = &$fn(\@errs) unless (!defined &$fn);
+	$connected = &$fn(\@errs) if defined &$fn;
 	last if ($connected);
     }
 
     $transmit_ok = 0;
     if ($connected) {
 	$current_proto = $proto;
-        local($old) = select(SYSLOG); $| = 1; select($old);
+        my($old) = select(SYSLOG); $| = 1; select($old);
     } else {
 	@fallbackMethods = ();
 	foreach my $err (@errs) {

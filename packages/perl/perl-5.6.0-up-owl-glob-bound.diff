diff -ur perl-5.6.0.orig/ext/File/Glob/bsd_glob.c perl-5.6.0/ext/File/Glob/bsd_glob.c
--- perl-5.6.0.orig/ext/File/Glob/bsd_glob.c	Thu Mar  2 20:53:17 2000
+++ perl-5.6.0/ext/File/Glob/bsd_glob.c	Mon Aug 12 02:59:49 2002
@@ -136,20 +136,20 @@
 
 static int	 compare(const void *, const void *);
 static int	 ci_compare(const void *, const void *);
-static void	 g_Ctoc(const Char *, char *);
+static int	 g_Ctoc(const Char *, char *, STRLEN);
 static int	 g_lstat(Char *, Stat_t *, glob_t *);
 static DIR	*g_opendir(Char *, glob_t *);
 static Char	*g_strchr(Char *, int);
-#ifdef notdef
-static Char	*g_strcat(Char *, const Char *);
-#endif
 static int	 g_stat(Char *, Stat_t *, glob_t *);
 static int	 glob0(const Char *, glob_t *);
-static int	 glob1(Char *, glob_t *);
-static int	 glob2(Char *, Char *, Char *, glob_t *);
-static int	 glob3(Char *, Char *, Char *, Char *, glob_t *);
-static int	 globextend(const Char *, glob_t *);
-static const Char *	 globtilde(const Char *, Char *, glob_t *);
+static int	 glob1(Char *, Char *, glob_t *, size_t *);
+static int	 glob2(Char *, Char *, Char *, Char *, Char *, Char *,
+		       glob_t *, size_t *);
+static int	 glob3(Char *, Char *, Char *, Char *, Char *, Char *,
+		       Char *, Char *, glob_t *, size_t *);
+static int	 globextend(const Char *, glob_t *, size_t *);
+static const Char *
+		 globtilde(const Char *, Char *, size_t, glob_t *);
 static int	 globexp1(const Char *, glob_t *);
 static int	 globexp2(const Char *, const Char *, glob_t *, int *);
 static int	 match(Char *, Char *, Char *, int);
@@ -175,7 +175,7 @@
 {
 	const U8 *patnext;
 	int c;
-	Char *bufnext, *bufend, patbuf[MAXPATHLEN+1];
+	Char *bufnext, *bufend, patbuf[MAXPATHLEN];
 
 	patnext = (U8 *) pattern;
 	if (!(flags & GLOB_APPEND)) {
@@ -189,7 +189,7 @@
 	pglob->gl_matchc = 0;
 
 	bufnext = patbuf;
-	bufend = bufnext + MAXPATHLEN;
+	bufend = bufnext + MAXPATHLEN - 1;
 #ifdef DOSISH
 	/* Nasty hack to treat patterns like "C:*" correctly. In this
 	 * case, the * should match any file in the current directory
@@ -277,11 +277,12 @@
 	int     i;
 	Char   *lm, *ls;
 	const Char *pe, *pm, *pl;
-	Char    patbuf[MAXPATHLEN + 1];
+	Char    patbuf[MAXPATHLEN];
 
 	/* copy part up to the brace */
 	for (lm = patbuf, pm = pattern; pm != ptr; *lm++ = *pm++)
 		continue;
+	*lm = BG_EOS;
 	ls = lm;
 
 	/* Find the balanced brace */
@@ -375,23 +376,29 @@
  * expand tilde from the passwd file.
  */
 static const Char *
-globtilde(const Char *pattern, Char *patbuf, glob_t *pglob)
+globtilde(const Char *pattern, Char *patbuf, size_t patbuf_len, glob_t *pglob)
 {
 	struct passwd *pwd;
 	char *h;
 	const Char *p;
-	Char *b;
+	Char *b, *eb;
 
 	if (*pattern != BG_TILDE || !(pglob->gl_flags & GLOB_TILDE))
 		return pattern;
 
 	/* Copy up to the end of the string or / */
-	for (p = pattern + 1, h = (char *) patbuf; *p && *p != BG_SLASH;
-	     *h++ = *p++)
+	eb = &patbuf[patbuf_len - 1];
+	for (p = pattern + 1, h = (char *) patbuf;
+	     h < (char*)eb && *p && *p != BG_SLASH; *h++ = (char)*p++)
 		continue;
 
 	*h = BG_EOS;
 
+#if 0
+	if (h == (char *)eb)
+		return what;
+#endif
+
 	if (((char *) patbuf)[0] == BG_EOS) {
 		/*
 		 * handle a plain ~ or ~/ by expanding $HOME
@@ -423,12 +430,13 @@
 	}
 
 	/* Copy the home directory */
-	for (b = patbuf; *h; *b++ = *h++)
+	for (b = patbuf; b < eb && *h; *b++ = *h++)
 		continue;
 
 	/* Append the rest of the pattern */
-	while ((*b++ = *p++) != BG_EOS)
+	while (b < eb && (*b++ = *p++) != BG_EOS)
 		continue;
+	*b = BG_EOS;
 
 	return patbuf;
 }
@@ -446,9 +454,10 @@
 {
 	const Char *qpat, *qpatnext;
 	int c, err, oldflags, oldpathc;
-	Char *bufnext, patbuf[MAXPATHLEN+1];
+	Char *bufnext, patbuf[MAXPATHLEN];
+	size_t limit = 0;
 
-	qpat = globtilde(pattern, patbuf, pglob);
+	qpat = globtilde(pattern, patbuf, MAXPATHLEN, pglob);
 	qpatnext = qpat;
 	oldflags = pglob->gl_flags;
 	oldpathc = pglob->gl_pathc;
@@ -506,7 +515,7 @@
 	qprintf("glob0:", patbuf);
 #endif /* GLOB_DEBUG */
 
-	if ((err = glob1(patbuf, pglob)) != 0) {
+	if ((err = glob1(patbuf, patbuf+MAXPATHLEN-1, pglob, &limit)) != 0) {
 		pglob->gl_flags = oldflags;
 		return(err);
 	}
@@ -526,7 +535,7 @@
 		printf("calling globextend from glob0\n");
 #endif /* GLOB_DEBUG */
 		pglob->gl_flags = oldflags;
-		return(globextend(qpat, pglob));
+		return(globextend(qpat, pglob, &limit));
         }
 	else if (!(pglob->gl_flags & GLOB_NOSORT))
 		qsort(pglob->gl_pathv + pglob->gl_offs + oldpathc,
@@ -539,15 +548,19 @@
 static int
 ci_compare(const void *p, const void *q)
 {
-    const char *pp = *(const char **)p;
-    const char *qq = *(const char **)q;
-    while (*pp && *qq) {
-	if (tolower(*pp) != tolower(*qq))
-	    break;
-	++pp;
-	++qq;
-    }
-    return (tolower(*pp) - tolower(*qq));
+	const char *pp = *(const char **)p;
+	const char *qq = *(const char **)q;
+	int ci;
+	while (*pp && *qq) {
+		if (toLOWER(*pp) != toLOWER(*qq))
+			break;
+		++pp;
+		++qq;
+	}
+	ci = toLOWER(*pp) - toLOWER(*qq);
+	if (ci == 0)
+		return compare(p, q);
+	return ci;
 }
 
 static int
@@ -557,14 +570,16 @@
 }
 
 static int
-glob1(Char *pattern, glob_t *pglob)
+glob1(Char *pattern, Char *pattern_last, glob_t *pglob, size_t *limitp)
 {
-	Char pathbuf[MAXPATHLEN+1];
+	Char pathbuf[MAXPATHLEN];
 
 	/* A null pathname is invalid -- POSIX 1003.1 sect. 2.4. */
 	if (*pattern == BG_EOS)
 		return(0);
-	return(glob2(pathbuf, pathbuf, pattern, pglob));
+	return(glob2(pathbuf, pathbuf+MAXPATHLEN-1,
+		     pathbuf, pathbuf+MAXPATHLEN-1,
+		     pattern, pattern_last, pglob, limitp));
 }
 
 /*
@@ -573,7 +588,8 @@
  * meta characters.
  */
 static int
-glob2(Char *pathbuf, Char *pathend, Char *pattern, glob_t *pglob)
+glob2(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,
+      Char *pattern, Char *pattern_last, glob_t *pglob, size_t *limitp)
 {
 	Stat_t sb;
 	Char *p, *q;
@@ -599,6 +615,8 @@
 			    || (S_ISLNK(sb.st_mode) &&
 			    (g_stat(pathbuf, &sb, pglob) == 0) &&
 			    S_ISDIR(sb.st_mode)))) {
+				if (pathend+1 > pathend_last)
+					return (1);
 				*pathend++ = BG_SEP;
 				*pathend = BG_EOS;
 			}
@@ -606,7 +624,7 @@
 #ifdef GLOB_DEBUG
                         printf("calling globextend from glob2\n");
 #endif /* GLOB_DEBUG */
-			return(globextend(pathbuf, pglob));
+			return(globextend(pathbuf, pglob, limitp));
 		}
 
 		/* Find end of next segment, copy tentatively to pathend. */
@@ -619,6 +637,8 @@
 		       ) {
 			if (ismeta(*p))
 				anymeta = 1;
+			if (q+1 > pathend_last)
+				return (1);
 			*q++ = *p++;
 		}
 
@@ -629,17 +649,24 @@
 #ifdef DOSISH
 			       || *pattern == BG_SEP2
 #endif
-			       )
+			       ) {
+				if (pathend+1 > pathend_last)
+					return (1);
 				*pathend++ = *pattern++;
-		} else			/* Need expansion, recurse. */
-			return(glob3(pathbuf, pathend, pattern, p, pglob));
+			}
+		} else
+			/* Need expansion, recurse. */
+			return(glob3(pathbuf, pathbuf_last, pathend,
+				     pathend_last, pattern, pattern_last,
+				     p, pattern_last, pglob, limitp));
 	}
 	/* NOTREACHED */
 }
 
 static int
-glob3(Char *pathbuf, Char *pathend, Char *pattern,
-      Char *restpattern, glob_t *pglob)
+glob3(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,
+      Char *pattern, Char *pattern_last,
+      Char *restpattern, Char *restpattern_last, glob_t *pglob, size_t *limitp)
 {
 	register Direntry_t *dp;
 	DIR *dirp;
@@ -653,8 +680,10 @@
 	 * and dirent.h as taking pointers to differently typed opaque
 	 * structures.
 	 */
-	Direntry_t *(*readdirfunc)();
+	Direntry_t *(*readdirfunc)(DIR*);
 
+	if (pathend > pathend_last)
+		return (1);
 	*pathend = BG_EOS;
 	errno = 0;
 
@@ -676,7 +705,8 @@
 	if ((dirp = g_opendir(pathbuf, pglob)) == NULL) {
 		/* TODO: don't call for ENOENT or ENOTDIR? */
 		if (pglob->gl_errfunc) {
-			g_Ctoc(pathbuf, buf);
+			if (g_Ctoc(pathbuf, buf, sizeof(buf)))
+				return (GLOB_ABEND);
 			if (pglob->gl_errfunc(buf, errno) ||
 			    (pglob->gl_flags & GLOB_ERR))
 				return (GLOB_ABEND);
@@ -689,7 +719,7 @@
 
 	/* Search directory for matching names. */
 	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
-		readdirfunc = pglob->gl_readdir;
+		readdirfunc = (Direntry_t *(*)(DIR *))pglob->gl_readdir;
 	else
 		readdirfunc = my_readdir;
 	while ((dp = (*readdirfunc)(dirp))) {
@@ -699,14 +729,22 @@
 		/* Initial BG_DOT must be matched literally. */
 		if (dp->d_name[0] == BG_DOT && *pattern != BG_DOT)
 			continue;
-		for (sc = (U8 *) dp->d_name, dc = pathend;
-		     (*dc++ = *sc++) != BG_EOS;)
-			continue;
+		dc = pathend;
+		sc = (U8 *) dp->d_name;
+		while (dc < pathend_last && (*dc++ = *sc++) != BG_EOS)
+			;
+		if (dc >= pathend_last) {
+			*dc = BG_EOS;
+			err = 1;
+			break;
+		}
+
 		if (!match(pathend, pattern, restpattern, nocase)) {
 			*pathend = BG_EOS;
 			continue;
 		}
-		err = glob2(pathbuf, --dc, restpattern, pglob);
+		err = glob2(pathbuf, pathbuf_last, --dc, pathend_last,
+			    restpattern, restpattern_last, pglob, limitp);
 		if (err)
 			break;
 	}
@@ -734,10 +772,11 @@
  *	gl_pathv points to (gl_offs + gl_pathc + 1) items.
  */
 static int
-globextend(const Char *path, glob_t *pglob)
+globextend(const Char *path, glob_t *pglob, size_t *limitp)
 {
 	register char **pathv;
 	register int i;
+	STRLEN newsize, len;
 	char *copy;
 	const Char *p;
 
@@ -748,13 +787,18 @@
         printf("\n");
 #endif /* GLOB_DEBUG */
 
+	newsize = sizeof(*pathv) * (2 + pglob->gl_pathc + pglob->gl_offs);
 	if (pglob->gl_pathv)
-		pathv = Renew(pglob->gl_pathv,
-			      (2 + pglob->gl_pathc + pglob->gl_offs),char*);
+		pathv = Renew(pglob->gl_pathv,newsize,char*);
 	else
-		New(0,pathv,(2 + pglob->gl_pathc + pglob->gl_offs),char*);
-	if (pathv == NULL)
+		New(0,pathv,newsize,char*);
+	if (pathv == NULL) {
+		if (pglob->gl_pathv) {
+			Safefree(pglob->gl_pathv);
+			pglob->gl_pathv = NULL;
+		}
 		return(GLOB_NOSPACE);
+	}
 
 	if (pglob->gl_pathv == NULL && pglob->gl_offs > 0) {
 		/* first time around -- clear initial gl_offs items */
@@ -766,9 +810,14 @@
 
 	for (p = path; *p++;)
 		continue;
+	len = (STRLEN)(p - path);
+	*limitp += len;
 	New(0, copy, p-path, char);
 	if (copy != NULL) {
-		g_Ctoc(path, copy);
+		if (g_Ctoc(path, copy, len)) {
+			Safefree(copy);
+			return(GLOB_NOSPACE);
+		}
 		pathv[pglob->gl_offs + pglob->gl_pathc++] = copy;
 	}
 	pathv[pglob->gl_offs + pglob->gl_pathc] = NULL;
@@ -845,6 +894,7 @@
 			if (*pp)
 				Safefree(*pp);
 		Safefree(pglob->gl_pathv);
+		pglob->gl_pathv = NULL;
 	}
 }
 
@@ -853,15 +903,17 @@
 {
 	char buf[MAXPATHLEN];
 
-	if (!*str)
+	if (!*str) {
 		strcpy(buf, ".");
-	else
-		g_Ctoc(str, buf);
+	} else {
+		if (g_Ctoc(str, buf, sizeof(buf)))
+			return(NULL);
+	}
 
 	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
 		return((*pglob->gl_opendir)(buf));
-	else
-	    return(PerlDir_open(buf));
+
+	return(PerlDir_open(buf));
 }
 
 static int
@@ -869,7 +921,8 @@
 {
 	char buf[MAXPATHLEN];
 
-	g_Ctoc(fn, buf);
+	if (g_Ctoc(fn, buf, sizeof(buf)))
+		return(-1);
 	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
 		return((*pglob->gl_lstat)(buf, sb));
 #ifdef HAS_LSTAT
@@ -884,7 +937,8 @@
 {
 	char buf[MAXPATHLEN];
 
-	g_Ctoc(fn, buf);
+	if (g_Ctoc(fn, buf, sizeof(buf)))
+		return(-1);
 	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
 		return((*pglob->gl_stat)(buf, sb));
 	return(PerlLIO_stat(buf, sb));
@@ -900,29 +954,14 @@
 	return (NULL);
 }
 
-#ifdef notdef
-static Char *
-g_strcat(Char *dst, const Char *src)
-{
-	Char *sdst = dst;
-
-	while (*dst++)
-		continue;
-	--dst;
-	while((*dst++ = *src++) != BG_EOS)
-	    continue;
-
-	return (sdst);
-}
-#endif
-
-static void
-g_Ctoc(register const Char *str, char *buf)
+static int
+g_Ctoc(register const Char *str, char *buf, STRLEN len)
 {
-	register char *dc;
-
-	for (dc = buf; (*dc++ = *str++) != BG_EOS;)
-		continue;
+	while (len--) {
+		if ((*buf++ = (char)*str++) == BG_EOS)
+			return (0);
+	}
+	return (1);
 }
 
 #ifdef GLOB_DEBUG

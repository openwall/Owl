diff -upk.orig findutils-4.2.27.orig/find/defs.h findutils-4.2.27/find/defs.h
--- findutils-4.2.27.orig/find/defs.h	2005-09-04 17:59:34 +0000
+++ findutils-4.2.27/find/defs.h	2005-12-08 17:40:21 +0000
@@ -420,6 +420,8 @@ const struct parser_table* find_parser P
 boolean parse_open  PARAMS((const struct parser_table* entry, char *argv[], int *arg_ptr));
 boolean parse_close PARAMS((const struct parser_table* entry, char *argv[], int *arg_ptr));
 boolean parse_print PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
+boolean parse_openparen PARAMS((const struct parser_table* entry, char *argv[], int *arg_ptr));
+boolean parse_closeparen PARAMS((const struct parser_table* entry, char *argv[], int *arg_ptr));
 void pred_sanity_check PARAMS((const struct predicate *predicates));
 void parse_begin_user_args PARAMS((char **args, int argno, const struct predicate *last, const struct predicate *predicates));
 void parse_end_user_args PARAMS((char **args, int argno, const struct predicate *last, const struct predicate *predicates));
diff -upk.orig findutils-4.2.27.orig/find/find.c findutils-4.2.27/find/find.c
--- findutils-4.2.27.orig/find/find.c	2005-11-11 07:41:37 +0000
+++ findutils-4.2.27/find/find.c	2005-12-08 17:34:34 +0000
@@ -1807,7 +1807,7 @@ complete_pending_execs(struct predicate 
 static void
 process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *parent)
 {
-  int subdirs_left;		/* Number of unexamined subdirs in PATHNAME. */
+  int subdirs_left = 0;		/* Number of unexamined subdirs in PATHNAME. */
   boolean subdirs_unreliable;	/* if true, cannot use dir link count as subdir limif (if false, it may STILL be unreliable) */
   int idx;			/* Which entry are we on? */
   struct stat stat_buf;
diff -upk.orig findutils-4.2.27.orig/find/parser.c findutils-4.2.27/find/parser.c
--- findutils-4.2.27.orig/find/parser.c	2005-12-04 02:07:52 +0000
+++ findutils-4.2.27/find/parser.c	2005-12-08 17:40:00 +0000
@@ -150,12 +150,6 @@ static boolean parse_quit          PARAM
 
 
 
-boolean parse_print             PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
-boolean parse_openparen              PARAMS((const struct parser_table* entry, char *argv[], int *arg_ptr));
-boolean parse_closeparen             PARAMS((const struct parser_table* entry, char *argv[], int *arg_ptr));
-
-
-
 static boolean insert_type PARAMS((char **argv, int *arg_ptr, const struct parser_table *entry, PRED_FUNC which_pred));
 static boolean insert_regex PARAMS((char *argv[], int *arg_ptr, const struct parser_table *entry, int regex_options));
 static boolean insert_fprintf PARAMS((FILE *fp, const struct parser_table *entry, PRED_FUNC func, char *argv[], int *arg_ptr));
diff -upk.orig findutils-4.2.27.orig/lib/regexprops.c findutils-4.2.27/lib/regexprops.c
--- findutils-4.2.27.orig/lib/regexprops.c	2005-11-29 07:10:17 +0000
+++ findutils-4.2.27/lib/regexprops.c	2005-12-08 17:36:26 +0000
@@ -67,6 +67,8 @@ static void enum_item(const char *s)
   literal(s);
   newline();
 }
+
+#if 0
 static void table_item(const char *s)
 {
   directive("@item");
@@ -81,6 +83,7 @@ static void code(const char *s)
   content(s);
   directive("}");
 }
+#endif
 
 static void begin_subsection(const char *name,
 			  const char *next,
@@ -102,12 +105,14 @@ static void begin_subsection(const char 
   newline();
 }
 
+#if 0
 static void begintable_asis()
 {
   newline();
   directive("@table @asis");
   newline();
 }
+#endif
 
 static void begintable_markup(char const *markup)
 {
diff -upk.orig findutils-4.2.27.orig/xargs/xargs.c findutils-4.2.27/xargs/xargs.c
--- findutils-4.2.27.orig/xargs/xargs.c	2005-12-04 02:51:36 +0000
+++ findutils-4.2.27/xargs/xargs.c	2005-12-08 17:42:22 +0000
@@ -305,7 +305,7 @@ get_line_max(void)
 static char 
 get_char_oct_or_hex_escape(const char *s)
 {
-  const char * p;
+  const char * p = NULL;
   int base = 8;
   unsigned long val;
   char *endp;
@@ -371,8 +371,6 @@ get_char_oct_or_hex_escape(const char *s
 static char 
 get_input_delimiter(const char *s)
 {
-  char result = '\0';
-  
   if (1 == strlen(s))
     {
       return s[0];

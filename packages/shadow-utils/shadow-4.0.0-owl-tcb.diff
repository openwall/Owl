diff -urN shadow-4.0.0-owl-no-tcb/lib/Makefile.am shadow-4.0.0/lib/Makefile.am
--- shadow-4.0.0-owl-no-tcb/lib/Makefile.am	Sat Oct  6 19:35:26 2001
+++ shadow-4.0.0/lib/Makefile.am	Tue Aug 20 14:19:27 2002
@@ -11,6 +11,8 @@
 	$(top_builddir)/libmisc/libmisc.la
 
 libshadow_la_SOURCES = \
+	pam_chpw.c \
+	tcbfuncs.c \
 	commonio.c \
 	commonio.h \
 	defines.h \
diff -urN shadow-4.0.0-owl-no-tcb/lib/commonio.c shadow-4.0.0/lib/commonio.c
--- shadow-4.0.0-owl-no-tcb/lib/commonio.c	Sun Nov 11 06:48:15 2001
+++ shadow-4.0.0/lib/commonio.c	Tue Aug 20 14:19:27 2002
@@ -1,4 +1,4 @@
-
+#define _GNU_SOURCE
 #include <config.h>
 
 #include "rcsid.h"
@@ -12,6 +12,7 @@
 #include <stdio.h>
 #include <signal.h>
 #include <pwd.h>
+#include <tcb.h>
 #ifdef HAVE_SHADOW_H
 #include <shadow.h>
 #endif
@@ -252,22 +253,14 @@
 	 * lockpw.c calls us and would cause infinite recursion!
 	 */
 
-	/*
-	 * Call lckpwdf() on the first lock.
-	 * If it succeeds, call *_lock() only once
-	 * (no retries, it should always succeed).
-	 */
-	if (lock_count == 0) {
-		if (lckpwdf() == -1)
-			return 0;  /* failure */
-	}
+	if (lock_count == 0 && lckpwdf() == -1)
+		return 0; /* failure */
 
-	if (commonio_lock_nowait(db))
-		return 1;  /* success */
-
-	ulckpwdf();
-	return 0;  /* failure */
+	lock_count++;
+	db->locked = 1;
+	return 1; /* success */
 #else
+#error lckpwdf() is required
 	int i;
 
 	/*
@@ -345,8 +338,6 @@
 int
 commonio_unlock(struct commonio_db *db)
 {
-	char lock[1024];
-
 	if (db->isopen) {
 		db->readonly = 1;
 		if (!commonio_close(db)) {
@@ -361,8 +352,10 @@
 		 * then call ulckpwdf() (if used) on last unlock.
 		 */
   		db->locked = 0;
+#if 0		 
 		snprintf(lock, sizeof lock, "%s.lock", db->filename);
 		unlink(lock);
+#endif
 		dec_lock_count();
 		return 1;
 	}
@@ -436,6 +429,7 @@
 	void *eptr;
 	int flags = mode;
 	int buflen;
+	int fd;
 	int saved_errno;
 
 	mode &= ~O_CREAT;
@@ -453,8 +447,19 @@
 	db->head = db->tail = db->cursor = NULL;
 	db->changed = 0;
 
-	db->fp = fopen(db->filename, db->readonly ? "r" : "r+");
-
+	fd = open(db->filename, (db->readonly ? O_RDONLY : O_RDWR) |
+		O_NOCTTY | O_NONBLOCK | O_NOFOLLOW);
+	saved_errno = errno;
+	db->fp = NULL;
+	if (fd >= 0) {
+		if (!tcb_is_suspect(fd)) {
+			db->fp = fdopen(fd, db->readonly ? "r" : "r+");
+			saved_errno = errno;
+		}
+		if (!db->fp)
+			close(fd);
+	}
+	errno = saved_errno;
 	/*
 	 * If O_CREAT was specified and the file didn't exist, it will be
 	 * created by commonio_close().  We have no entries to read yet.  --marekm
diff -urN shadow-4.0.0-owl-no-tcb/lib/getdef.c shadow-4.0.0/lib/getdef.c
--- shadow-4.0.0-owl-no-tcb/lib/getdef.c	Sun Nov 11 06:49:24 2001
+++ shadow-4.0.0/lib/getdef.c	Tue Aug 20 14:19:27 2002
@@ -116,6 +116,8 @@
 	{ "SYSLOG_SG_ENAB",		NULL },
 	{ "SYSLOG_SU_ENAB",		NULL },
 #endif
+	{ "TCB_AUTH_GROUP",		NULL },
+	{ "TCB_SYMLINKS",		NULL },
 	{ "TTYGROUP",			NULL },
 	{ "TTYPERM",			NULL },
 	{ "TTYTYPE_FILE",		NULL },
@@ -124,7 +126,8 @@
 	{ "ULIMIT",			NULL },
 	{ "UMASK",			NULL },
 	{ "USERDEL_CMD",		NULL },
-	{ "USERGROUPS_ENAB",		NULL }
+	{ "USERGROUPS_ENAB",		NULL },
+	{ "USE_TCB",			NULL }
 };
 
 #ifndef LOGINDEFS
diff -urN shadow-4.0.0-owl-no-tcb/lib/pam_chpw.c shadow-4.0.0/lib/pam_chpw.c
--- shadow-4.0.0-owl-no-tcb/lib/pam_chpw.c	Thu Jan  1 00:00:00 1970
+++ shadow-4.0.0/lib/pam_chpw.c	Tue Aug 20 14:19:27 2002
@@ -0,0 +1,38 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <security/pam_userpass.h>
+
+int do_pam_chpass(const char *service, const char *user, const char *pass)
+{
+	pam_handle_t *pamh;
+	pam_userpass_t userpass;
+	struct pam_conv conv = {pam_userpass_conv, &userpass};
+	int status;
+
+	userpass.user = user;
+	userpass.pass = pass;
+
+	status = pam_start(service, user, &conv, &pamh);
+	if (status != PAM_SUCCESS) {
+		fprintf(stderr, "pam_start: Failed with code %d\n", status);
+		return 0;
+	}
+
+	status = pam_chauthtok(pamh, 0);
+	if (status != PAM_SUCCESS) {
+		fprintf(stderr, "pam_chauthtok: %s\n",
+			pam_strerror(pamh, status));
+		pam_end(pamh, status);
+		return 0;
+	}
+
+	status = pam_end(pamh, status);
+	if (status != PAM_SUCCESS) {
+		fprintf(stderr, "pam_end: Failed with code %d\n", status);
+		return 0;
+	}
+
+	return 1;
+}
diff -urN shadow-4.0.0-owl-no-tcb/lib/pam_chpw.h shadow-4.0.0/lib/pam_chpw.h
--- shadow-4.0.0-owl-no-tcb/lib/pam_chpw.h	Thu Jan  1 00:00:00 1970
+++ shadow-4.0.0/lib/pam_chpw.h	Tue Aug 20 14:19:27 2002
@@ -0,0 +1,7 @@
+#ifndef _PAM_CHPW_H
+#define _PAM_CHPW_H
+
+extern int do_pam_chpass(const char *service,
+	const char *user, const char *pass);
+
+#endif
diff -urN shadow-4.0.0-owl-no-tcb/lib/shadowio.c shadow-4.0.0/lib/shadowio.c
--- shadow-4.0.0-owl-no-tcb/lib/shadowio.c	Tue Aug 14 23:17:53 2001
+++ shadow-4.0.0/lib/shadowio.c	Tue Aug 20 14:19:27 2002
@@ -1,4 +1,3 @@
-
 #include <config.h>
 
 #ifdef SHADOWPWD
@@ -12,9 +11,13 @@
 # include <shadow.h>
 #endif
 #include <stdio.h>
+#include <tcb.h>
 
 #include "commonio.h"
 #include "shadowio.h"
+#include "getdef.h"
+
+#include "tcbfuncs.h"
 
 struct spwd *
 __spw_dup(const struct spwd *spent)
@@ -78,7 +81,7 @@
 	fputs
 };
 
-static struct commonio_db shadow_db = {
+struct commonio_db shadow_db = {
 	SHADOW_FILE,	/* filename */
 	&shadow_ops,	/* ops */
 	NULL,		/* fp */
@@ -100,19 +103,42 @@
 int
 spw_file_present(void)
 {
-	return commonio_present(&shadow_db);
+	if (getdef_bool("USE_TCB"))
+		return 1;
+	else
+		return commonio_present(&shadow_db);
 }
 
 int
 spw_lock(void)
 {
-	return commonio_lock(&shadow_db);
+	int retval;
+
+	if (!getdef_bool("USE_TCB"))
+		return commonio_lock(&shadow_db);
+
+	if (!s_drop_priv()) return 0;
+
+	retval = 0;
+	if (lckpwdf_tcb(shadow_db.filename) == 0) {
+		shadow_db.locked = 1;
+		retval = 1;
+	}
+
+	if (!s_gain_priv()) return 0;
+
+	return retval;
 }
 
 int
 spw_open(int mode)
 {
-	return commonio_open(&shadow_db, mode);
+	int retval;
+
+	if (!s_drop_priv()) return 0;
+	retval = commonio_open(&shadow_db, mode);
+	if (!s_gain_priv()) return 0;
+	return retval;
 }
 
 const struct spwd *
@@ -148,13 +174,33 @@
 int
 spw_close(void)
 {
-	return commonio_close(&shadow_db);
+	int retval;
+
+	if (!s_drop_priv()) return 0;
+	retval = commonio_close(&shadow_db);
+	if (!s_gain_priv()) return 0;
+	return retval;
 }
 
 int
 spw_unlock(void)
 {
-	return commonio_unlock(&shadow_db);
+	int retval;
+
+	if (!getdef_bool("USE_TCB"))
+		return commonio_unlock(&shadow_db);
+
+	if (!s_drop_priv()) return 0;
+
+	retval = 0;
+	if (!ulckpwdf_tcb()) {
+		shadow_db.locked = 0;
+		retval = 1;
+	}
+
+	if (!s_gain_priv()) return 0;
+
+	return retval;
 }
 
 struct commonio_entry *
@@ -177,4 +223,5 @@
 
 	return commonio_sort_wrt(&shadow_db, __pw_get_db());
 }
+
 #endif
diff -urN shadow-4.0.0-owl-no-tcb/lib/tcbfuncs.c shadow-4.0.0/lib/tcbfuncs.c
--- shadow-4.0.0-owl-no-tcb/lib/tcbfuncs.c	Thu Jan  1 00:00:00 1970
+++ shadow-4.0.0/lib/tcbfuncs.c	Thu Oct 24 04:53:50 2002
@@ -0,0 +1,476 @@
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <grp.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <tcb.h>
+
+#include "getdef.h"
+#include "shadowio.h"
+
+#define LOCK_SUFFIX			".lock"
+
+static char *stored_tcb_user = NULL;
+
+int s_drop_priv()
+{
+	if (!getdef_bool("USE_TCB"))
+		return 1;
+
+	if (stored_tcb_user)
+		return !tcb_drop_priv(stored_tcb_user);
+	else
+		return 0;
+}
+
+int s_gain_priv()
+{
+	if (!getdef_bool("USE_TCB"))
+		return 1;
+	return !tcb_gain_priv();
+}
+
+/*
+ * In case something goes wrong, we return immediately, not polluting the
+ * code with free().  All errors are fatal, so an application is expected
+ * to exit soon.
+ */
+
+#define NOMEM { \
+	fprintf(stderr, "Out of memory.\n"); \
+	return 0; \
+}
+
+int tcb_user(const char *name)
+{
+	char *buf;
+	int retval;
+
+	if (!getdef_bool("USE_TCB"))
+		/* The user should be in the traditional shadow file */
+		return 1;
+
+	if (stored_tcb_user)
+		free(stored_tcb_user);
+
+	stored_tcb_user = strdup(name);
+	if (!stored_tcb_user)
+		NOMEM;
+	asprintf(&buf, TCB_FMT, name);
+	if (!buf)
+		NOMEM;
+
+	retval = spw_name(buf);	/* should be 1 */
+
+	free(buf);
+
+	return retval;
+}
+
+static int unlink_suffs(const char *user)
+{
+	static char *suffs[] = { "+", "-", LOCK_SUFFIX };
+	char *tmp;
+	int i;
+
+	for (i = 0; i < 3; i++) {
+		asprintf(&tmp, TCB_FMT "%s", user, suffs[i]);
+		if (!tmp)
+			NOMEM;
+		if (unlink(tmp) && errno != ENOENT) {
+			fprintf(stderr, "unlink: %s: %s\n", tmp,
+				strerror(errno));
+			free(tmp);
+			return 0;
+		}
+		free(tmp);
+	}
+
+	return 1;
+}
+
+/*
+ * tcb_path_rel() must return relative (against TCB_DIR) directory, whose
+ * last component is user's tcb directory.
+ */
+#define HASH_BY 1000
+static char *tcb_path_rel(const char *name, uid_t uid)
+{
+	char *ret;
+
+	if (!getdef_bool("TCB_SYMLINKS") || uid < HASH_BY)
+		asprintf(&ret, "%s", name);
+	else if (uid < HASH_BY * HASH_BY)
+		asprintf(&ret, ":%dK/%s", uid / HASH_BY, name);
+	else
+		asprintf(&ret, ":%dM/:%dK/%s", uid / (HASH_BY * HASH_BY),
+			 (uid % (HASH_BY * HASH_BY)) / HASH_BY, name);
+	if (!ret)
+		NOMEM;
+	return ret;
+}
+
+static char *tcb_path_rel_existing(const char *name)
+{
+	char *path, *rval;
+	struct stat st;
+	char link[8192];
+	int ret;
+
+	asprintf(&path, TCB_DIR "/%s", name);
+	if (!path)
+		NOMEM;
+	if (lstat(path, &st)) {
+		fprintf(stderr, "Cannot stat %s: %s\n", path,
+			strerror(errno));
+		free(path);
+		return NULL;
+	}
+	if (S_ISDIR(st.st_mode)) {
+		free(path);
+		rval = strdup(name);
+		if (!rval)
+			NOMEM;
+		return rval;
+	}
+	if (!S_ISLNK(st.st_mode)) {
+		fprintf(stderr,
+			"%s is neither a directory, nor a symlink.\n",
+			path);
+		free(path);
+		return NULL;
+	}
+	ret = readlink(path, link, sizeof(link) - 1);
+	free(path);
+	if (ret == -1) {
+		perror("readlink");
+		return NULL;
+	}
+	link[ret] = 0;
+	if (ret >= sizeof(link) - 1) {
+		fprintf(stderr, "Suspiciously long symlink: %s\n", link);
+		return NULL;
+	}
+	rval = strdup(link);
+	if (!rval)
+		NOMEM;
+	return rval;
+}
+
+static char *tcb_path(const char *name, uid_t uid)
+{
+	char *ret, *rel;
+
+	if (!(rel = tcb_path_rel(name, uid)))
+		return 0;
+	asprintf(&ret, TCB_DIR "/%s", rel);
+	free(rel);
+	if (!ret)
+		NOMEM;
+	return ret;
+}
+
+static char *tcb_path_existing(const char *name)
+{
+	char *ret, *rel;
+
+	if (!(rel = tcb_path_rel_existing(name)))
+		return 0;
+	asprintf(&ret, TCB_DIR "/%s", rel);
+	free(rel);
+	if (!ret)
+		NOMEM;
+	return ret;
+}
+
+static int mkdir_leading(const char *name, uid_t uid)
+{
+	char *ind, *dir, *ptr, *path = tcb_path_rel(name, uid);
+	struct stat st;
+
+	if (!path)
+		return 0;
+	ptr = path;
+	if (stat(TCB_DIR, &st)) {
+		perror("stat");
+		goto out_free_path;
+	}
+	while ((ind = strchr(ptr, '/'))) {
+		*ind = 0;
+		asprintf(&dir, TCB_DIR "/%s", path);
+		if (!dir)
+			NOMEM;
+		if (mkdir(dir, 0700) && errno != EEXIST) {
+			perror("mkdir");
+			goto out_free_dir;
+		}
+		if (chown(dir, 0, st.st_gid)) {
+			perror("chown");
+			goto out_free_dir;
+		}
+		if (chmod(dir, 0711)) {
+			perror("chmod");
+			goto out_free_dir;
+		}
+		free(dir);
+		*ind = '/';
+		ptr = ind + 1;
+	}
+	free(path);
+	return 1;
+out_free_dir:
+	free(dir);
+out_free_path:
+	free(path);
+	return 0;
+}
+
+/* path should be a relative existing tcb directory */
+static int rmdir_leading(char *path)
+{
+	char *ind, *dir;
+	int ret = 1;
+
+	while ((ind = strrchr(path, '/'))) {
+		*ind = 0;
+		asprintf(&dir, TCB_DIR "/%s", path);
+		if (!dir)
+			NOMEM;
+		if (rmdir(dir)) {
+			if (errno != ENOTEMPTY) {
+				perror("rmdir");
+				ret = 0;
+			}
+			free(dir);
+			break;
+		}
+		free(dir);
+	}
+	return ret;
+}
+
+/* tcb directory must be empty before tcb_rmdir() is called */
+int tcb_rmdir(const char *name)
+{
+	int ret = 1;
+	char *path = tcb_path_existing(name);
+	char *rel = tcb_path_rel_existing(name);
+
+	if (!path || !rel || rmdir(path))
+		return 0;
+	if (!rmdir_leading(rel))
+		return 0;
+	free(path);
+	free(rel);
+	asprintf(&path, TCB_DIR "/%s", name);
+	if (!path)
+		NOMEM;
+	if (unlink(path) && errno != ENOENT)
+		ret = 0;
+	free(path);
+	return ret;
+}
+
+static int move_dir(const char *user_newname, uid_t user_newid)
+{
+	char *olddir = NULL, *newdir = NULL;
+	char *real_old_dir = NULL, *real_new_dir = NULL;
+	char *real_old_dir_rel = NULL, *real_new_dir_rel = NULL;
+	uid_t old_uid, the_newid;
+	struct stat oldmode;
+	int ret = 0;
+
+	asprintf(&olddir, TCB_DIR "/%s", stored_tcb_user);
+	if (!olddir)
+		goto out_free_nomem;
+	if (stat(olddir, &oldmode)) {
+		perror("stat");
+		goto out_free;
+	}
+	old_uid = oldmode.st_uid;
+	if (user_newid == -1)
+		the_newid = old_uid;
+	else
+		the_newid = user_newid;
+	if (!(real_old_dir = tcb_path_existing(stored_tcb_user)) ||
+	    !(real_new_dir = tcb_path(user_newname, the_newid)))
+		goto out_free;
+	if (!strcmp(real_old_dir, real_new_dir)) {
+		ret = 1;
+		goto out_free;
+	}
+	if (!(real_old_dir_rel = tcb_path_rel_existing(stored_tcb_user)) ||
+	    !mkdir_leading(user_newname, the_newid))
+		goto out_free;
+	if (rename(real_old_dir, real_new_dir)) {
+		perror("rename");
+		goto out_free;
+	}
+	if (!rmdir_leading(real_old_dir_rel))
+		goto out_free;
+	if (unlink(olddir) && errno != ENOENT) {
+		perror("unlink");
+		goto out_free;
+	}
+	asprintf(&newdir, TCB_DIR "/%s", user_newname);
+	if (!newdir)
+		goto out_free_nomem;
+	if (!(real_new_dir_rel = tcb_path_rel(user_newname, the_newid)))
+		goto out_free;
+	if (strcmp(real_new_dir, newdir) &&
+	    symlink(real_new_dir_rel, newdir)) {
+		perror("symlink");
+		goto out_free;
+	}
+	ret = 1;
+	goto out_free;
+out_free_nomem:
+	fprintf(stderr, "Out of memory\n");
+out_free:
+	free(olddir);
+	free(newdir);
+	free(real_old_dir);
+	free(real_new_dir);
+	free(real_old_dir_rel);
+	free(real_new_dir_rel);
+	return ret;
+}
+
+int tcb_move(const char *user_newname, uid_t user_newid)
+{
+	struct stat dirmode, filemode;
+	char *tcbdir, *shadow;
+	int ret = 0;
+
+	if (!getdef_bool("USE_TCB"))
+		return 1;
+	if (!user_newname)
+		user_newname = stored_tcb_user;
+	if (!move_dir(user_newname, user_newid))
+		return 0;
+	/* Directory moved, adjust ownership */
+	if (user_newid == -1)
+		return 1;
+	asprintf(&tcbdir, TCB_DIR "/%s", user_newname);
+	asprintf(&shadow, TCB_DIR "/%s/shadow", user_newname);
+	if (!tcbdir || !shadow)
+		NOMEM;
+	if (stat(tcbdir, &dirmode)) {
+		perror("stat");
+		goto out_free;
+	}
+	if (chown(tcbdir, 0, 0)) {
+		perror("chown");
+		goto out_free;
+	}
+	if (chmod(tcbdir, 0700)) {
+		perror("chmod");
+		goto out_free;
+	}
+	if (lstat(shadow, &filemode)) {
+		if (errno != ENOENT) {
+			perror("lstat");
+			goto out_free;
+		}
+		fprintf(stderr,
+			"Warning, user %s has no shadow file.\n",
+			user_newname);
+	} else {
+		if (!S_ISREG(filemode.st_mode) ||
+		    filemode.st_nlink != 1) {
+			fprintf(stderr,
+				"Emergency: %s'shadow is not a regular file"
+				" with st_nlink=1.\n"
+				"The account is left locked.\n",
+				user_newname);
+			goto out_free;
+		}
+		if (chown(shadow, user_newid, filemode.st_gid)) {
+			perror("chown");
+			goto out_free;
+		}
+		if (chmod(shadow, filemode.st_mode & 07777)) {
+			perror("chmod");
+			goto out_free;
+		}
+	}
+	if (!unlink_suffs(user_newname))
+		goto out_free;
+	if (chown(tcbdir, user_newid, dirmode.st_gid)) {
+		perror("chown");
+		goto out_free;
+	}
+	if (chmod(tcbdir, dirmode.st_mode & 07777)) {
+		perror("chmod");
+		goto out_free;
+	}
+	ret = 1;
+out_free:
+	free(tcbdir);
+	free(shadow);
+	return ret;
+}
+
+int tcb_create(const char *name, uid_t uid)
+{
+	char *dir, *shadow;
+	struct stat st;
+	gid_t shadowgid, authgid;
+	struct group *gr;
+	int fd, ret = 0;
+
+	if (!getdef_bool("USE_TCB"))
+		return 1;
+	if (stat(TCB_DIR, &st)) {
+		perror("stat");
+		return 0;
+	}
+	shadowgid = st.st_gid;
+	if (getdef_bool("TCB_AUTH_GROUP") &&
+	    (gr = getgrnam("auth")))
+		authgid = gr->gr_gid;
+	else
+		authgid = shadowgid;
+	asprintf(&dir, TCB_DIR "/%s", name);
+	asprintf(&shadow, TCB_FMT, name);
+	if (!dir || !shadow)
+		NOMEM;
+	if (mkdir(dir, 0700)) {
+		fprintf(stderr, "mkdir: %s: %s\n", dir, strerror(errno));
+		goto out_free;
+		return 0;
+	}
+	fd = open(shadow, O_RDWR | O_CREAT | O_TRUNC, 0600);
+	if (fd < 0) {
+		perror("open");
+		goto out_free;
+	}
+	close(fd);
+	if (chown(shadow, 0, authgid)) {
+		perror("chown");
+		goto out_free;
+	}
+	if (chmod(shadow, authgid == shadowgid ? 0600 : 0640)) {
+		perror("chmod");
+		goto out_free;
+	}
+	if (chown(dir, 0, authgid)) {
+		perror("chown");
+		goto out_free;
+	}
+	if (chmod(dir, authgid == shadowgid ? 02700 : 02710)) {
+		perror("chmod");
+		goto out_free;
+	}
+	if (!tcb_user(name) || !tcb_move(NULL, uid))
+		goto out_free;
+	ret = 1;
+out_free:
+	free(dir);
+	free(shadow);
+	return ret;
+}
diff -urN shadow-4.0.0-owl-no-tcb/lib/tcbfuncs.h shadow-4.0.0/lib/tcbfuncs.h
--- shadow-4.0.0-owl-no-tcb/lib/tcbfuncs.h	Thu Jan  1 00:00:00 1970
+++ shadow-4.0.0/lib/tcbfuncs.h	Tue Aug 20 14:19:27 2002
@@ -0,0 +1,13 @@
+#ifndef _TCBFUNCS_H
+#define _TCBFUNCS_H
+
+#include <sys/types.h>
+
+extern int s_drop_priv(void);
+extern int s_gain_priv(void);
+extern int tcb_user(const char *);
+extern int tcb_create(const char *, uid_t);
+extern int tcb_move(const char *, uid_t);
+extern int tcb_rmdir(const char *);
+
+#endif
diff -urN shadow-4.0.0-owl-no-tcb/man/login.defs.5 shadow-4.0.0/man/login.defs.5
--- shadow-4.0.0-owl-no-tcb/man/login.defs.5	Sun Nov 11 06:49:24 2001
+++ shadow-4.0.0/man/login.defs.5	Thu Oct 24 04:44:38 2002
@@ -27,15 +27,23 @@
 .\"
 .\"	$Id: login.defs.5,v 1.7 2000/08/26 18:27:17 marekm Exp $
 .\"
+.\" 2002/10/24	Rafal Wojtczuk <nergal@owl.openwall.com>
+.\"		Solar Designer <solar@owl.openwall.com>
+.\" Documented TCB_SYMLINKS.
+.\"
 .\" 2001/11/11	Solar Designer <solar@owl.openwall.com>
 .\" Documented CRYPT_PREFIX and CRYPT_ROUNDS.
 .\"
+.\" 2001/11/04	Solar Designer <solar@owl.openwall.com>
+.\"		Rafal Wojtczuk <nergal@owl.openwall.com>
+.\" Documented TCB_AUTH_GROUP and USE_TCB.
+.\"
 .\" 2001/06/15	Solar Designer <solar@owl.openwall.com>
 .\" Removed the descriptions of most parameters as only a small subset is
 .\" actually used on Owl, corrected those which remain, and wrote whatever
 .\" was missing.
 .\"
-.TH LOGIN.DEFS 5 "11 November 2001"
+.TH LOGIN.DEFS 5 "24 October 2002"
 .SH NAME
 /etc/login.defs \- shadow password suite configuration
 .SH DESCRIPTION
@@ -133,6 +141,78 @@
 are only used at the time of account creation.  Any changes to these
 settings won't affect existing accounts.
 .\"
+.IP "TCB_AUTH_GROUP (boolean)"
+If
+.IR yes ,
+newly created tcb shadow files will be group-owned by "auth".
+.\"
+.IP "TCB_SYMLINKS (boolean)"
+If
+.IR yes ,
+the location of the user tcb directory to be created will not be
+automatically set to
+.IR /etc/tcb/user ,
+but will be computed depending on the UID of the user, according to the
+following algorithm:
+.sp
+.ad l
+.in +4
+.ti -4
+if
+.RB ( UID
+is less than 1000)
+.in +8
+.ti -4
+use
+.IR /etc/tcb/user ;
+.in -8
+.ti -4
+else if
+.RB ( UID
+is less than 1000000) {
+.in +8
+.ti -4
+use
+\fI/etc/tcb/:\fBkilos\fIK/user\fR,
+where
+.B kilos
+is calculated as
+.B UID
+/ 1000;
+.br
+.ti -4
+make symlink
+.I /etc/tcb/user
+to the directory;
+.in -8
+.ti -4
+} else {
+.in +8
+.ti -4
+use
+\fI/etc/tcb/:\fBmegas\fIM/:\fBkilos\fIK/user\fR,
+where
+.B megas
+is calculated as
+.B UID
+/ 1000000
+and
+.B kilos
+is calculated as
+.RB ( UID
+-
+.B megas
+* 1000000) / 1000;
+.br
+.ti -4
+make symlink
+.I /etc/tcb/user
+to the directory;
+.in -8
+.ti -4
+}
+.in -4
+.ad b
 .IP "UID_MAX (number)"
 .IP "UID_MIN (number)"
 Range of user IDs to choose from for the
@@ -143,6 +223,13 @@
 The permission mask is initialized to this value.  If not specified,
 the permission mask will be initialized to 077.
 .\"
+.IP "USE_TCB (boolean)"
+If
+.IR yes ,
+the commands which create or modify accounts will adhere to the
+.BR tcb (5)
+password shadowing scheme.
+.\"
 .IP "USERDEL_CMD (string)"
 If defined, this command is run when removing a user.
 It should remove any at/cron/print jobs etc. owned by
@@ -152,8 +239,12 @@
 The following cross reference shows which programs in the shadow password
 suite use which parameters.
 .na
+.IP chage 12
+USE_TCB
 .IP chfn 12
 CHFN_AUTH CHFN_RESTRICT
+.IP chpasswd 12
+USE_TCB
 .IP chsh 12
 CHFN_AUTH
 .IP gpasswd 12
@@ -162,20 +253,34 @@
 GID_MAX GID_MIN
 .IP newusers 12
 PASS_MAX_DAYS PASS_MIN_DAYS PASS_WARN_AGE
+TCB_AUTH_GROUP TCB_SYMLINKS
 UMASK
+USE_TCB
+.IP pwck 12
+USE_TCB
 .IP pwconv 12
 PASS_MAX_DAYS PASS_MIN_DAYS PASS_WARN_AGE
+USE_TCB
+.IP pwunconv 12
+USE_TCB
 .IP useradd 12
 CREATE_HOME
 GID_MAX GID_MIN
 PASS_MAX_DAYS PASS_MIN_DAYS PASS_WARN_AGE
+TCB_AUTH_GROUP TCB_SYMLINKS
 UID_MAX UID_MIN
 UMASK
+USE_TCB
 .IP userdel 12
 MAIL_DIR
+USE_TCB
 USERDEL_CMD
 .IP usermod 12
 MAIL_DIR
+TCB_SYMLINKS
+USE_TCB
+.IP vipw 12
+USE_TCB
 .ad
 .SH BUGS
 Much of the functionality that used to be provided by the shadow password
diff -urN shadow-4.0.0-owl-no-tcb/src/Makefile.am shadow-4.0.0/src/Makefile.am
--- shadow-4.0.0-owl-no-tcb/src/Makefile.am	Sat Oct  6 19:46:49 2001
+++ shadow-4.0.0/src/Makefile.am	Tue Aug 20 14:19:27 2002
@@ -36,9 +36,10 @@
 suidubins = chage chfn chsh expiry gpasswd newgrp passwd
 
 LDADD = $(top_builddir)/libmisc/libmisc.la \
-	$(top_builddir)/lib/libshadow.la
+	$(top_builddir)/lib/libshadow.la \
+	-ltcb
 
-chpasswd_LDADD = $(LDADD) $(LIBPAM)
+chpasswd_LDADD = $(LDADD) $(LIBPAM) -lpam_userpass
 chage_LDADD    = $(LDADD) $(LIBPAM)
 chfn_LDADD     = $(LDADD) $(LIBPAM)
 chsh_LDADD     = $(LDADD) $(LIBPAM)
@@ -47,7 +48,7 @@
 groupdel_LDADD = $(LDADD) $(LIBPAM)
 groupmod_LDADD = $(LDADD) $(LIBPAM)
 login_LDADD    = $(LDADD) $(LIBPAM)
-newusers_LDADD = $(LDADD) $(LIBPAM)
+newusers_LDADD = $(LDADD) $(LIBPAM) -lpam_userpass
 passwd_LDADD   = $(LDADD) $(LIBPAM) $(LIBCRACK)
 su_LDADD       = $(LDADD) $(LIBPAM)
 useradd_LDADD  = $(LDADD) $(LIBPAM)
diff -urN shadow-4.0.0-owl-no-tcb/src/chage.c shadow-4.0.0/src/chage.c
--- shadow-4.0.0-owl-no-tcb/src/chage.c	Sun Nov 11 06:49:15 2001
+++ shadow-4.0.0/src/chage.c	Tue Aug 20 14:19:27 2002
@@ -94,6 +94,7 @@
 
 #ifdef	SHADOWPWD
 #include "shadowio.h"
+#include "tcbfuncs.h"
 #endif
 
 extern	int	optind;
@@ -597,6 +598,11 @@
 	STRFCPY(name, pwent.pw_name);
 
 #ifdef	SHADOWPWD
+	if (!tcb_user(pwent.pw_name)) {
+		cleanup(1);
+		closelog();
+		exit(1);
+	}
 	/*
 	 * For shadow password files we have to lock the file and
 	 * read in the entries as was done for the password file.
diff -urN shadow-4.0.0-owl-no-tcb/src/chpasswd.c shadow-4.0.0/src/chpasswd.c
--- shadow-4.0.0-owl-no-tcb/src/chpasswd.c	Sun Nov 11 06:48:26 2001
+++ shadow-4.0.0/src/chpasswd.c	Tue Aug 20 14:19:27 2002
@@ -25,12 +25,25 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
+ *
+ * chpasswd - update passwords in batch
+ *
+ *      chpasswd reads standard input for a list of colon separated
+ *      user names and new passwords.  the appropriate password
+ *      files are updated to reflect the changes.  because the
+ *      changes are made in a batch fashion, the user must run
+ *      the mkpasswd command after this command terminates since
+ *      no password updates occur until the very end.
+ *
+ * 1997/07/29: Modified to take "-e" argument which specifies that
+ *             the passwords have already been encrypted.
+ *             -- Jay Soffian <jay@lw.net>
  */
 
 #include <config.h>
 
 #include "rcsid.h"
-RCSID(PKG_VER "$Id: chpasswd.c,v 1.13 2001/01/25 10:36:07 kloczek Exp $")
+RCSID (PKG_VER "$Id: chpasswd.c,v 1.10 2000/08/26 18:27:18 marekm Exp $")
 
 #include <stdio.h>
 #include "prototypes.h"
@@ -41,33 +54,137 @@
 #ifdef	SHADOWPWD
 #include "shadowio.h"
 #endif
+#include "pam_chpw.h"
+#include "tcbfuncs.h"
 
 #ifdef USE_PAM
 #include <security/pam_appl.h>
 #include <security/pam_misc.h>
-#include <pwd.h>
 #endif /* USE_PAM */
 
-static char *Prog;
-static int eflg = 0;
-#ifdef SHADOWPWD
-static int is_shadow_pwd;
-#endif
+     static char *Prog;
+     static int eflg = 0;
 
-extern	char	*l64a();
+     extern char *l64a ();
 
 /* local function prototypes */
-static void usage(void);
+     static void usage (void);
 
 /*
  * usage - display usage message and exit
  */
 
-static void
-usage(void)
+     static void
+       usage (void)
+{
+  fprintf (stderr, _ ("usage: %s [-e]\n"), Prog);
+  exit (1);
+}
+
+#ifdef SHADOWPWD
+static int
+paste_pwd_shadow (char *name, char *pwd)
+{
+  const struct spwd *sp;
+  struct spwd newsp;
+  long now = time ((long *) 0) / (24L * 3600L);
+
+  if (!tcb_user (name))
+  	return 0;
+  if (!spw_lock ())
+    {
+      fprintf (stderr, "can't lock shadow file for %s\n",
+	       name);
+      return 0;
+    }
+  if (!spw_open (O_RDWR))
+    {
+      fprintf (stderr, "can't open shadow file for %s\n",
+	       name);
+      spw_unlock ();
+      return 0;
+    }
+  sp = spw_locate (name);
+  if (sp)
+    {
+      newsp = *sp;
+      newsp.sp_pwdp = pwd;
+      newsp.sp_lstchg = now;
+    }
+  else
+    {
+      fprintf (stderr, "can't locate shadow entry for %s\n", name);
+      return 0;
+    }
+  if (!spw_update (&newsp))
+    {
+      fprintf (stderr, "can't update shadow entry for %s\n", name);
+      return 0;
+    }
+  if (!spw_close ())
+    {
+      fprintf (stderr, "error updating shadow file\n");
+      return 0;
+    }
+  spw_unlock ();
+  return 1;
+}
+#endif
+
+static int
+paste_pwd (char *name, char *pwd)
 {
-	fprintf(stderr, _("usage: %s [-e]\n"), Prog);
-	exit(1);
+  const struct passwd *pw;
+  struct passwd newpw;
+#ifdef  ATT_AGE
+  long now = time ((long *) 0) / (24L * 3600L);
+#endif
+#ifdef SHADOWPWD
+  if (spw_file_present ())
+    return paste_pwd_shadow (name, pwd);
+#endif
+
+  if (!pw_lock ())
+    {
+      fprintf (stderr, "can't lock password file\n");
+      return 0;
+    }
+  if (!pw_open (O_RDWR))
+    {
+      fprintf (stderr, "can't open password file\n");
+      return 0;
+    }
+
+  pw = pw_locate (name);
+  if (!pw)
+    {
+      fprintf (stderr, "unknown user %s\n",
+	name);
+      return 0;
+    }
+  newpw = *pw;
+  newpw.pw_passwd = pwd;
+#ifdef	ATT_AGE
+  if (newpw.pw_age[0])
+    {
+      strcpy (newage, newpw.pw_age);
+      strcpy (newage + 2, l64a (now / 7));
+      newpw.pw_age = newage;
+    }
+#endif
+
+  if (!pw_update (&newpw))
+    {
+      fprintf (stderr, "cannot update password entry\n");
+      return 0;
+    }
+  if (!pw_close ())
+    {
+      fprintf (stderr, "error updating password file\n");
+      return 0;
+    }
+  pw_unlock ();
+  return 1;
 }
 
 #ifdef USE_PAM
@@ -80,40 +197,31 @@
 int
 main(int argc, char **argv)
 {
-	char	buf[BUFSIZ];
-	char	*name;
-	char	*newpwd;
-	char	*cp;
-#ifdef	SHADOWPWD
-	const struct spwd *sp;
-	struct	spwd	newsp;
-#endif
-	const struct passwd *pw;
-	struct	passwd	newpw;
+  char buf[BUFSIZ];
+  char *name;
+  char *cp;
 #ifdef ATT_AGE
-	char	newage[5];
+  char newage[5];
 #endif
-	int	errors = 0;
-	int	line = 0;
-	long	now = time ((long *) 0) / (24L*3600L);
-	int ok;
+  int line = 0;
+  static int errors = 0;
 #ifdef USE_PAM
 	pam_handle_t *pamh = NULL;
 	struct passwd *pampw;
 	int retval;
 #endif
 
-	Prog = Basename(argv[0]);
+    Prog = Basename (argv[0]);
 
-	setlocale(LC_ALL, "");
-	bindtextdomain(PACKAGE, LOCALEDIR);
-	textdomain(PACKAGE);
-
-	/* XXX - use getopt() */
-	if (!(argc == 1 || (argc == 2 && !strcmp(argv[1], "-e"))))
-		usage();
-	if (argc == 2)
-		eflg = 1;
+    setlocale (LC_ALL, "");
+    bindtextdomain (PACKAGE, LOCALEDIR);
+    textdomain (PACKAGE);
+
+  /* XXX - use getopt() */
+  if (!(argc == 1 || (argc == 2 && !strcmp (argv[1], "-e"))))
+      usage ();
+  if (argc == 2)
+      eflg = 1;
 
 #ifdef USE_PAM
 	retval = PAM_SUCCESS;
@@ -147,196 +255,63 @@
 	}
 #endif /* USE_PAM */
 
-	/*
-	 * Lock the password file and open it for reading.  This will
-	 * bring all of the entries into memory where they may be
-	 * updated.
-	 */
-
-	if (!pw_lock()) {
-		fprintf(stderr, _("%s: can't lock password file\n"), Prog);
-		exit(1);
-	}
-	if (! pw_open (O_RDWR)) {
-		fprintf(stderr, _("%s: can't open password file\n"), Prog);
-		pw_unlock();
-		exit(1);
-	}
-#ifdef SHADOWPWD
-	is_shadow_pwd = spw_file_present();
-	if (is_shadow_pwd) {
-		if (!spw_lock()) {
-			fprintf(stderr, _("%s: can't lock shadow file\n"), Prog);
-			pw_unlock();
-			exit(1);
-		}
-		if (!spw_open(O_RDWR)) {
-			fprintf(stderr, _("%s: can't open shadow file\n"), Prog);
-			pw_unlock();
-			spw_unlock();
-			exit(1);
-		}
-	}
-#endif
-
-	/*
-	 * Read each line, separating the user name from the password.
-	 * The password entry for each user will be looked up in the
-	 * appropriate file (shadow or passwd) and the password changed.
-	 * For shadow files the last change date is set directly, for
-	 * passwd files the last change date is set in the age only if
-	 * aging information is present.
-	 */
-
-	while (fgets (buf, sizeof buf, stdin) != (char *) 0) {
-		line++;
-		if ((cp = strrchr (buf, '\n'))) {
-			*cp = '\0';
-		} else {
-			fprintf(stderr, _("%s: line %d: line too long\n"),
-				Prog, line);
-			errors++;
-			continue;
-		}
-
-		/*
-		 * The username is the first field.  It is separated
-		 * from the password with a ":" character which is
-		 * replaced with a NUL to give the new password.  The
-		 * new password will then be encrypted in the normal
-		 * fashion with a new salt generated, unless the '-e'
-		 * is given, in which case it is assumed to already be
-		 * encrypted.
-		 */
-
-		name = buf;
-		if ((cp = strchr (name, ':'))) {
-			*cp++ = '\0';
-		} else {
-			fprintf(stderr, _("%s: line %d: missing new password\n"),
-				Prog, line);
-			errors++;
-			continue;
-		}
-		newpwd = cp;
-		if (!eflg)
-			cp = pw_encrypt(newpwd, crypt_make_salt());
-
-		/*
-		 * Get the password file entry for this user.  The user
-		 * must already exist.
-		 */
-
-		pw = pw_locate(name);
-		if (!pw) {
-			fprintf (stderr, _("%s: line %d: unknown user %s\n"),
-				Prog, line, name);
-			errors++;
-			continue;
-		}
-
-#ifdef SHADOWPWD
-		if (is_shadow_pwd)
-			sp = spw_locate(name);
-		else
-			sp = NULL;
-#endif
-
-		/*
-		 * The freshly encrypted new password is merged into
-		 * the user's password file entry and the last password
-		 * change date is set to the current date.
-		 */
-
-#ifdef SHADOWPWD
-		if (sp) {
-			newsp = *sp;
-			newsp.sp_pwdp = cp;
-			newsp.sp_lstchg = now;
-		} else
-#endif
-		{
-			newpw = *pw;
-			newpw.pw_passwd = cp;
-#ifdef	ATT_AGE
-			if (newpw.pw_age[0]) {
-				strcpy(newage, newpw.pw_age);
-				strcpy(newage + 2, l64a(now / 7));
-				newpw.pw_age = newage;
-			}
-#endif
-		}
-
-		/* 
-		 * The updated password file entry is then put back
-		 * and will be written to the password file later, after
-		 * all the other entries have been updated as well.
-		 */
-
-#ifdef SHADOWPWD
-		if (sp)
-			ok = spw_update(&newsp);
-		else
-#endif
-			ok = pw_update(&newpw);
-
-		if (!ok) {
-			fprintf(stderr, _("%s: line %d: cannot update password entry\n"),
-				Prog, line);
-			errors++;
-			continue;
-		}
-	}
-
-	/*
-	 * Any detected errors will cause the entire set of changes
-	 * to be aborted.  Unlocking the password file will cause
-	 * all of the changes to be ignored.  Otherwise the file is
-	 * closed, causing the changes to be written out all at
-	 * once, and then unlocked afterwards.
-	 */
-
-	if (errors) {
-		fprintf(stderr, _("%s: error detected, changes ignored\n"), Prog);
-#ifdef SHADOWPWD
-		if (is_shadow_pwd)
-			spw_unlock();
-#endif
-		pw_unlock();
-		exit(1);
-	}
-#ifdef SHADOWPWD
-	if (is_shadow_pwd) {
-		if (!spw_close()) {
-			fprintf(stderr, _("%s: error updating shadow file\n"), Prog);
-			pw_unlock();
-			exit(1);
-		}
-		spw_unlock();
-	}
-#endif
-	if (!pw_close()) {
-		fprintf(stderr, _("%s: error updating password file\n"), Prog);
-		exit(1);
-	}
-	pw_unlock();
-
-#ifdef USE_PAM
-	if (retval == PAM_SUCCESS) {
-		retval = pam_chauthtok(pamh, 0);
-		if (retval != PAM_SUCCESS) {
-			pam_end(pamh, retval);
-		}
-	}
-
-	if (retval != PAM_SUCCESS) {
-		fprintf (stderr, _("%s: PAM chauthtok failed\n"), Prog);
-		exit (1);
-	}
-
-	if (retval == PAM_SUCCESS)
-		pam_end(pamh, PAM_SUCCESS);
-#endif /* USE_PAM */
-
-	return (0);
+  while (fgets (buf, sizeof buf, stdin) != (char *) 0)
+    {
+      line++;
+      if ((cp = strrchr (buf, '\n')))
+	{
+	  *cp = '\0';
+	}
+      else
+	{
+	  fprintf (stderr, _ ("%s: line %d: line too long\n"),
+		   Prog, line);
+	  errors++;
+	  break;
+	}
+
+      /*
+       * The username is the first field.  It is separated
+       * from the password with a ":" character which is
+       * replaced with a NUL to give the new password.  The
+       * new password will then be encrypted in the normal
+       * fashion with a new salt generated, unless the '-e'
+       * is given, in which case it is assumed to already be
+       * encrypted.
+       */
+
+      name = buf;
+      if ((cp = strchr (name, ':')))
+	{
+	  *cp++ = '\0';
+	}
+      else
+	{
+	  fprintf (stderr, _ ("%s: line %d: missing new password\n"),
+		   Prog, line);
+	  errors++;
+	  break;
+	}
+      if (eflg)
+	{
+	  if (!paste_pwd (name, cp))
+	    {
+	      fprintf (stderr, "%s: line %d: unable to paste new hash\n",
+		       Prog, line);
+	      errors++;
+	      break;
+	    }
+	}
+      else if (!do_pam_chpass ("chpasswd", name, cp))
+	{
+	  fprintf (stderr, "%s: line %d: unable to change password for %s\n",
+		   Prog, line, name);
+	  errors++;
+	  break;
+	}
+    }
+  if (errors)
+    return 1;
+  else
+    return 0;
 }
diff -urN shadow-4.0.0-owl-no-tcb/src/newusers.c shadow-4.0.0/src/newusers.c
--- shadow-4.0.0-owl-no-tcb/src/newusers.c	Sun Nov 11 06:48:26 2001
+++ shadow-4.0.0/src/newusers.c	Tue Aug 20 14:19:27 2002
@@ -62,8 +62,9 @@
 #ifdef	SHADOWPWD
 #include "shadowio.h"
 
-static int is_shadow;
 #endif
+#include "pam_chpw.h"
+#include "tcbfuncs.h"
 
 /* local function prototypes */
 static void usage(void);
@@ -246,7 +247,7 @@
 static void
 update_passwd(struct passwd *pwd, const char *passwd)
 {
-	pwd->pw_passwd = pw_encrypt(passwd, crypt_make_salt());
+	pwd->pw_passwd = "!!";
 #ifdef ATT_AGE
 	if (strlen(pwd->pw_age) == 4) {
 		static char newage[5];
@@ -270,6 +271,7 @@
 	const struct spwd *sp;
 	struct	spwd	spent;
 #endif
+	int retval;
 
 	/*
 	 * In the case of regular password files, this is real
@@ -278,12 +280,23 @@
 	 * things to do ...
 	 */
 
-	if (!is_shadow) {
-		update_passwd(pwd, passwd);
+	if (!spw_file_present()) {
+		update_passwd(pwd, NULL);
 		return 0;
 	}
 
 #ifdef SHADOWPWD
+	retval = -1;
+
+	if (!spw_lock()) {
+		fprintf(stderr, "Can't lock shadow file.\n");
+		goto out;
+	}
+	if (!spw_open(O_RDWR)) {
+		fprintf(stderr, "Can't open shadow file.\n");
+		goto out_unlock;
+	}
+
 	/*
 	 * Do the first and easiest shadow file case.  The user
 	 * already exists in the shadow password file.
@@ -291,10 +304,11 @@
 
 	if ((sp = spw_locate (pwd->pw_name))) {
 		spent = *sp;
-		spent.sp_pwdp = pw_encrypt(passwd, crypt_make_salt());
-		return ! spw_update (&spent);
+		spent.sp_pwdp = "!!";
+		goto out_update;
 	}
 
+#if 0
 	/*
 	 * Pick the next easiest case - the user has an encrypted
 	 * password which isn't equal to "x".  The password was set
@@ -306,6 +320,7 @@
 		update_passwd(pwd, passwd);
 		return 0;
 	}
+#endif
 
 	/*
 	 * Now the really hard case - I need to create an entirely
@@ -313,7 +328,7 @@
 	 */
 
 	spent.sp_namp = pwd->pw_name;
-	spent.sp_pwdp = pw_encrypt(passwd, crypt_make_salt());
+	spent.sp_pwdp = "!!";
 	spent.sp_lstchg = time((time_t *) 0) / SCALE;
 	spent.sp_min = getdef_num("PASS_MIN_DAYS", 0);
 					/* 10000 is infinity this week */
@@ -323,7 +338,24 @@
 	spent.sp_expire = -1;
 	spent.sp_flag = -1;
 
-	return ! spw_update (&spent);
+out_update:
+	if (!spw_update (&spent)) {
+		fprintf(stderr, "Can't update shadow file.\n");
+		spw_close();
+		goto out_unlock;
+	}
+	if (!spw_close()) {
+		fprintf(stderr, "Can't flush shadow file.\n");
+		goto out_unlock;
+	}
+
+	retval = 0;
+
+out_unlock:
+	spw_unlock();
+
+out:
+	return retval;
 #endif
 }
 
@@ -343,7 +375,6 @@
 	char	*cp;
 	const struct passwd *pw;
 	struct	passwd	newpw;
-	int	errors = 0;
 	int	line = 0;
 	uid_t	uid;
 	gid_t	gid;
@@ -376,18 +407,17 @@
 
 	if (retval == PAM_SUCCESS) {
 		retval = pam_authenticate(pamh, 0);
-		if (retval != PAM_SUCCESS) {
-			pam_end(pamh, retval);
-		}
 	}
 
 	if (retval == PAM_SUCCESS) {
 		retval = pam_acct_mgmt(pamh, 0);
-		if (retval != PAM_SUCCESS) {
-			pam_end(pamh, retval);
-		}
 	}
 
+	if (retval == PAM_SUCCESS)
+		retval = pam_end(pamh, retval);
+	else
+		pam_end(pamh, retval);
+
 	if (retval != PAM_SUCCESS) {
 		fprintf (stderr, _("%s: PAM authentication failed\n"), Prog);
 		exit (1);
@@ -402,50 +432,6 @@
 		}
 	}
 
-	/*
-	 * Lock the password files and open them for update.  This will
-	 * bring all of the entries into memory where they may be
-	 * searched for an modified, or new entries added.  The password
-	 * file is the key - if it gets locked, assume the others can
-	 * be locked right away.
-	 */
-
-	if (!pw_lock()) {
-		fprintf (stderr, _("%s: can't lock /etc/passwd.\n"), Prog);
-		exit (1);
-	}
-#ifdef	SHADOWPWD
-	is_shadow = spw_file_present();
-
-	if ((is_shadow && !spw_lock()) || !gr_lock())
-#else
-	if (!gr_lock())
-#endif
-	{
-		fprintf (stderr, _("%s: can't lock files, try again later\n"),
-			Prog);
-		(void) pw_unlock ();
-#ifdef	SHADOWPWD
-		if (is_shadow)
-			spw_unlock();
-#endif
-		exit (1);
-	}
-#ifdef	SHADOWPWD
-	if (!pw_open(O_RDWR) || (is_shadow && !spw_open(O_RDWR)) || !gr_open(O_RDWR))
-#else
-	if (!pw_open(O_RDWR) || !gr_open(O_RDWR))
-#endif
-	{
-		fprintf (stderr, _("%s: can't open files\n"), Prog);
-		(void) pw_unlock ();
-#ifdef	SHADOWPWD
-		if (is_shadow)
-			spw_unlock();
-#endif
-		(void) gr_unlock ();
-		exit (1);
-	}
 
 	/*
 	 * Read each line.  The line has the same format as a password
@@ -464,8 +450,7 @@
 		} else {
 			fprintf (stderr, _("%s: line %d: line too long\n"),
 				Prog, line);
-			errors++;
-			continue;
+			exit(1);
 		}
 
 		/*
@@ -484,7 +469,28 @@
 		if (nfields != 6) {
 			fprintf (stderr, _("%s: line %d: invalid line\n"),
 				Prog, line);
-			continue;
+			exit(1);
+		}
+
+		if (!pw_lock()) {
+			fprintf (stderr, _("%s: Can't lock /etc/passwd.\n"),
+				Prog);
+			fprintf (stderr, "line %d user %s\n", line, fields[0]);
+			exit (1);
+		}
+		if (!gr_lock()) {
+			fprintf (stderr, _("%s: Can't lock /etc/group.\n"),
+				Prog);
+			fprintf (stderr, "line %d user %s\n", line, fields[0]);
+			(void) pw_unlock ();
+			exit (1);
+		}
+		if (!pw_open(O_RDWR) || !gr_open(O_RDWR)) {
+			fprintf (stderr, _("%s: Can't open files\n"), Prog);
+			fprintf (stderr, "line %d user %s\n", line, fields[0]);
+			(void) gr_unlock ();
+			(void) pw_unlock ();
+			exit (1);
 		}
 
 		/*
@@ -502,8 +508,9 @@
 			add_group (fields[0], fields[3], &gid)) {
 			fprintf (stderr, _("%s: line %d: can't create GID\n"),
 				Prog, line);
-			errors++;
-			continue;
+			(void) gr_unlock ();
+			(void) pw_unlock ();
+			exit(1);
 		}
 
 		/*
@@ -518,8 +525,18 @@
 		if (! pw && add_user (fields[0], fields[2], &uid, gid)) {
 			fprintf (stderr, _("%s: line %d: can't create UID\n"),
 				Prog, line);
-			errors++;
-			continue;
+			(void) gr_unlock ();
+			(void) pw_unlock ();
+			exit(1);
+		}
+
+		if (!tcb_create(fields[0], uid)) {
+			fprintf(stderr, "Problems creating /etc/tcb/%s; "
+			    "there may be a stale entry left.\n", fields[0]);
+			fprintf (stderr, "line %d user %s\n", line, fields[0]);
+			(void) gr_unlock ();
+			(void) pw_unlock ();
+			exit (1);
 		}
 
 		/*
@@ -530,16 +547,18 @@
 		if (! (pw = pw_locate (fields[0]))) {
 			fprintf (stderr, _("%s: line %d: cannot find user %s\n"),
 				Prog, line, fields[0]);
-			errors++;
-			continue;
+			(void) gr_unlock ();
+			(void) pw_unlock ();
+			exit(1);
 		}
 		newpw = *pw;
 
 		if (add_passwd (&newpw, fields[1])) {
 			fprintf (stderr, _("%s: line %d: can't update password\n"),
 				Prog, line);
-			errors++;
-			continue;
+			(void) gr_unlock ();
+			(void) pw_unlock ();
+			exit(1);
 		}
 		if (fields[4][0])
 			newpw.pw_gecos = fields[4];
@@ -552,68 +571,51 @@
 
 		if (newpw.pw_dir[0] && access(newpw.pw_dir, F_OK)) {
 			if (mkdir (newpw.pw_dir,
-					0777 & ~getdef_num("UMASK", 077)))
-				fprintf (stderr, _("%s: line %d: mkdir failed\n"),
+					0777 & ~getdef_num("UMASK", 077))) {
+				fprintf (stderr,
+					_("%s: line %d: mkdir failed\n"),
 					Prog, line);
-			else if (chown (newpw.pw_dir,
-					newpw.pw_uid, newpw.pw_gid))
-				fprintf (stderr, _("%s: line %d: chown failed\n"),
+				(void) gr_unlock ();
+				(void) pw_unlock ();
+				exit(1);
+			} else if (chown (newpw.pw_dir,
+					newpw.pw_uid, newpw.pw_gid)) {
+				fprintf (stderr,
+					_("%s: line %d: chown failed\n"),
 					Prog, line);
+				(void) gr_unlock ();
+				(void) pw_unlock ();
+				exit(1);
+			}
 		}
 
 		/*
 		 * Update the password entry with the new changes made.
 		 */
-
+		uid = pw->pw_uid;
 		if (! pw_update (&newpw)) {
 			fprintf (stderr, _("%s: line %d: can't update entry\n"),
 				Prog, line);
-			errors++;
-			continue;
+			(void) gr_unlock ();
+			(void) pw_unlock ();
+			exit(1);
+		}
+		if (!pw_close() || ! gr_close()) {
+			fprintf (stderr, _("%s: error updating files\n"), Prog);
+			fprintf (stderr, "line %d user %s\n", line, fields[0]);
+			(void) gr_unlock ();
+			(void) pw_unlock ();
+			exit(1);
 		}
-	}
-
-	/*
-	 * Any detected errors will cause the entire set of changes
-	 * to be aborted.  Unlocking the password file will cause
-	 * all of the changes to be ignored.  Otherwise the file is
-	 * closed, causing the changes to be written out all at
-	 * once, and then unlocked afterwards.
-	 */
-
-	if (errors) {
-		fprintf (stderr, _("%s: error detected, changes ignored\n"), Prog);
-		(void) gr_unlock ();
-#ifdef	SHADOWPWD
-		if (is_shadow)
-			spw_unlock();
-#endif
-		(void) pw_unlock ();
-		exit (1);
-	}
-#ifdef	SHADOWPWD
-	if (!pw_close() || (is_shadow && !spw_close()) || !gr_close())
-#else
-	if (!pw_close() || ! gr_close())
-#endif
-	{
-		fprintf (stderr, _("%s: error updating files\n"), Prog);
 		(void) gr_unlock ();
-#ifdef	SHADOWPWD
-		if (is_shadow)
-			spw_unlock();
-#endif
 		(void) pw_unlock ();
-		exit (1);
+		if (!do_pam_chpass("newusers", fields[0], fields[1])) {
+			fprintf (stderr, "line %d user %s\n", line, fields[0]);
+			exit(1);
+		}
 	}
-	(void) gr_unlock ();
-#ifdef	SHADOWPWD
-	if (is_shadow)
-		spw_unlock();
-#endif
-	(void) pw_unlock ();
 
-#ifdef USE_PAM
+#if 0
 	if (retval == PAM_SUCCESS) {
 		retval = pam_chauthtok(pamh, 0);
 		if (retval != PAM_SUCCESS) {
@@ -628,7 +630,7 @@
 
 	if (retval == PAM_SUCCESS)
 		pam_end(pamh, PAM_SUCCESS);
-#endif /* USE_PAM */
+#endif /* used to be USE_PAM */
 
 	exit (0);
 	/*NOTREACHED*/
diff -urN shadow-4.0.0-owl-no-tcb/src/pwck.c shadow-4.0.0/src/pwck.c
--- shadow-4.0.0-owl-no-tcb/src/pwck.c	Sun Nov 11 06:48:26 2001
+++ shadow-4.0.0/src/pwck.c	Tue Aug 20 14:19:27 2002
@@ -34,12 +34,13 @@
 
 #include <stdio.h>
 #include <fcntl.h>
+#include <pwd.h>
 #include <grp.h>
 
 #include "prototypes.h"
 #include "defines.h"
 #include "chkname.h"
-#include <pwd.h>
+#include "getdef.h"
 
 #include "commonio.h"
 
@@ -215,6 +216,11 @@
 		is_shadow = 1;
 	} else if (optind == argc)
 		is_shadow = spw_file_present();
+	if (getdef_bool("USE_TCB")) {
+		fprintf(stderr, _("%s: shadow files will not be checked\n"),
+			Prog);
+		is_shadow = 0;
+	}
 #endif
 
 	/*
diff -urN shadow-4.0.0-owl-no-tcb/src/pwconv.c shadow-4.0.0/src/pwconv.c
--- shadow-4.0.0-owl-no-tcb/src/pwconv.c	Sat Aug 26 18:27:18 2000
+++ shadow-4.0.0/src/pwconv.c	Tue Aug 20 14:19:27 2002
@@ -90,6 +90,11 @@
 	bindtextdomain(PACKAGE, LOCALEDIR);
 	textdomain(PACKAGE);
 
+	if (getdef_bool("USE_TCB")) {
+		fprintf(stderr, _("%s: can't work with tcb enabled\n"), Prog);
+		fail_exit(E_FAILURE);
+	}
+
 	if (!pw_lock()) {
 		fprintf(stderr, _("%s: can't lock passwd file\n"), Prog);
 		fail_exit(E_PWDBUSY);
diff -urN shadow-4.0.0-owl-no-tcb/src/pwunconv.c shadow-4.0.0/src/pwunconv.c
--- shadow-4.0.0-owl-no-tcb/src/pwunconv.c	Thu Jan 25 10:36:07 2001
+++ shadow-4.0.0/src/pwunconv.c	Tue Aug 20 14:19:27 2002
@@ -41,6 +41,7 @@
 #include "prototypes.h"
 #include "pwio.h"
 #include "shadowio.h"
+#include "getdef.h"
 
 #ifndef	SHADOWPWD
 int
@@ -90,6 +91,11 @@
 	setlocale (LC_ALL, "");
 	bindtextdomain (PACKAGE, LOCALEDIR);
 	textdomain (PACKAGE);
+
+	if (getdef_bool("USE_TCB")) {
+		fprintf(stderr, _("%s: can't work with tcb enabled\n"), Prog);
+		exit(1);
+	}
 
 	if (!spw_file_present())
 		/* shadow not installed, do nothing */
diff -urN shadow-4.0.0-owl-no-tcb/src/useradd.c shadow-4.0.0/src/useradd.c
--- shadow-4.0.0-owl-no-tcb/src/useradd.c	Sun Nov 11 06:49:06 2001
+++ shadow-4.0.0/src/useradd.c	Thu Oct 24 04:38:24 2002
@@ -59,6 +59,8 @@
 #endif
 #include "faillog.h"
 
+#include "tcbfuncs.h"
+
 #ifndef SKEL_DIR
 #define SKEL_DIR "/etc/skel"
 #endif
@@ -229,6 +231,7 @@
 static void process_flags(int argc, char **argv);
 static void close_files(void);
 static void open_files(void);
+static void open_shadow(void);
 static void faillog_reset(uid_t);
 static void lastlog_reset(uid_t);
 static void usr_update(void);
@@ -1505,21 +1508,6 @@
 		pw_unlock();
 		exit(E_PW_UPDATE);
 	}
-#ifdef	SHADOWPWD
-	if (is_shadow_pwd && !spw_lock()) {
-		fprintf(stderr, _("%s: cannot lock shadow password file\n"),
-			Prog);
-		pw_unlock();
-		exit(E_PW_UPDATE);
-	}
-	if (is_shadow_pwd && !spw_open(O_RDWR)) {
-		fprintf(stderr, _("%s: cannot open shadow password file\n"),
-			Prog);
-		spw_unlock();
-		pw_unlock();
-		exit(E_PW_UPDATE);
-	}
-#endif
 	/*
 	 * Lock and open the group file.  This will load all of the group
 	 * entries.
@@ -1547,6 +1535,25 @@
 #endif        /* SHADOWGRP*/
 }
 
+static void
+open_shadow(void)
+{
+#ifdef	SHADOWPWD
+	if (is_shadow_pwd && !spw_lock()) {
+		fprintf(stderr, _("%s: cannot lock shadow password file\n"),
+			Prog);
+		pw_unlock();
+		exit(E_PW_UPDATE);
+	}
+	if (is_shadow_pwd && !spw_open(O_RDWR)) {
+		fprintf(stderr, _("%s: cannot open shadow password file\n"),
+			Prog);
+		spw_unlock();
+		pw_unlock();
+		exit(E_PW_UPDATE);
+	}
+#endif
+}
 
 static void
 faillog_reset(uid_t uid)
@@ -2044,6 +2051,11 @@
 	 * gid too ... --gafton */
 	if (! uflg)
 	    find_new_uid ();
+	if (getdef_bool("USE_TCB") && !tcb_create(user_name, user_id)) {
+		fprintf(stderr, "Problems creating /etc/tcb/%s\n", user_name);
+		exit(E_UID_IN_USE);
+	}
+	open_shadow();
 	/* do we have to add a group for that user? This is why we need to
 	 * open the group files in the open_files() function  --gafton */
 	if (! (nflg || gflg)) {
diff -urN shadow-4.0.0-owl-no-tcb/src/userdel.c shadow-4.0.0/src/userdel.c
--- shadow-4.0.0-owl-no-tcb/src/userdel.c	Sun Nov 11 06:48:43 2001
+++ shadow-4.0.0/src/userdel.c	Thu Oct 24 04:39:55 2002
@@ -27,6 +27,8 @@
  * SUCH DAMAGE.
  */
 
+#define _GNU_SOURCE
+
 #include <config.h>
 
 #include "rcsid.h"
@@ -40,6 +42,7 @@
 #include <ctype.h>
 #include <fcntl.h>
 #include <utmp.h>
+#include <tcb.h>
 
 #ifdef USE_PAM
 #include <security/pam_appl.h>
@@ -52,6 +55,8 @@
 #include "getdef.h"
 #include "pwauth.h"
 
+#include "tcbfuncs.h"
+
 /*
  * exit status values
  */
@@ -772,6 +777,42 @@
 };
 #endif /* USE_PAM */
 
+static int userdel_rm_tcbdir(const char *user_name, uid_t user_id)
+{
+	char *buf;
+	int ret = 0;
+	
+	if (!getdef_bool("USE_TCB"))
+		return 0;
+
+	asprintf(&buf, TCB_DIR "/%s", user_name);
+	if (!buf) {
+		fprintf(stderr, "Can't allocate memory, "
+			"tcb entry for %s not removed.\n",
+			user_name);
+		return 1;
+	}
+	if (!s_drop_priv()) {
+		perror("tcb_drop_privs");
+		free(buf);
+		return 1;
+	}		
+	if (remove_tree(buf)) {
+		perror("remove_tree");
+		s_gain_priv();
+		free(buf);
+		return 1;
+	}
+	s_gain_priv();
+	free(buf);
+	if (!tcb_rmdir(user_name)) {
+		fprintf(stderr, "Cannot remove tcb files for %s: %s\n",
+			user_name, strerror(errno));
+		ret = 1;
+	}
+	free(buf);
+	return ret;
+}
 /*
  * main - userdel command
  */
@@ -884,6 +925,8 @@
 			Prog, user_name);
 		exit(E_NOTFOUND);
 	}
+	if (!tcb_user(user_name))
+		exit(E_NOTFOUND);
 #ifdef	USE_NIS
 
 	/*
@@ -989,6 +1032,7 @@
 
 	close_files ();
 
+	errors += userdel_rm_tcbdir(user_name, user_id);
 #ifdef USE_PAM
 	if (retval == PAM_SUCCESS) {
 		retval = pam_chauthtok(pamh, 0);
diff -urN shadow-4.0.0-owl-no-tcb/src/usermod.c shadow-4.0.0/src/usermod.c
--- shadow-4.0.0-owl-no-tcb/src/usermod.c	Sun Nov 11 06:48:43 2001
+++ shadow-4.0.0/src/usermod.c	Tue Aug 20 14:19:27 2002
@@ -59,6 +59,7 @@
 #endif
 #include "pwauth.h"
 #include "getdef.h"
+#include "tcbfuncs.h"
 
 /*
  * exit status values
@@ -81,10 +82,10 @@
 #define	VALID(s)	(strcspn (s, ":\n") == strlen (s))
 
 static char *user_name;
-static char *user_newname;
+static char *user_newname = NULL;
 static char *user_pass;
 static uid_t user_id;
-static uid_t user_newid;
+static uid_t user_newid = -1;
 static gid_t user_gid;
 static gid_t user_newgid;
 static char *user_comment;
@@ -1724,6 +1725,9 @@
 	 * change the home directory, then close and update the files.
 	 */
 
+	if (!tcb_user(user_name))
+		exit(E_PW_UPDATE);
+
 	open_files();
 
 	usr_update();
@@ -1753,6 +1757,10 @@
 			user_id, user_newid,
 			user_gid, gflg ? user_newgid:user_gid);
 	}
+
+	if ((user_newname || user_newid != -1) &&
+	    !tcb_move(user_newname, user_newid))
+		exit(E_PW_UPDATE);
 
 	if (grp_err)
 		exit(E_GRP_UPDATE);
diff -urN shadow-4.0.0-owl-no-tcb/src/vipw.c shadow-4.0.0/src/vipw.c
--- shadow-4.0.0-owl-no-tcb/src/vipw.c	Sun Nov 11 06:48:15 2001
+++ shadow-4.0.0/src/vipw.c	Thu Oct 24 04:41:31 2002
@@ -20,6 +20,7 @@
 
   */
 
+#define _GNU_SOURCE
 #include <config.h>
 
 #include "rcsid.h"
@@ -35,15 +36,20 @@
 #include <sys/types.h>
 #include <signal.h>
 #include <utime.h>
+#include <tcb.h>
 #include "prototypes.h"
 #include "pwio.h"
 #include "shadowio.h"
 #include "groupio.h"
 #include "sgroupio.h"
-
+#include "commonio.h"
+#include "getdef.h"
+#include "tcbfuncs.h"
 
 static const char *progname, *filename, *fileeditname;
 static int filelocked = 0, createedit = 0;
+static int securemode = 0;
+static char *user = NULL;
 static int (*unlock)(void);
 
 /* local function prototypes */
@@ -91,6 +97,24 @@
   return 0;
 }
 
+static int prep_new(char **to_rename, char *fileedit, const char *file)
+{
+	FILE *f;
+	struct stat st;
+
+	if (!(f = fopen(fileedit, "r"))) return 0;
+	if (unlink(fileedit)) return 0;
+	if (!s_drop_priv()) return 0;
+	if (stat(file, &st)) return 0;
+	asprintf(to_rename, "%s+", file);
+	if (!*to_rename) {
+		fclose(f);
+		return 0;
+	}
+	if (create_backup_file(f, *to_rename, &st)) return 0;
+
+	return 1;
+}
 
 static void
 vipwexit(const char *msg, int syserr, int ret)
@@ -108,6 +132,8 @@
 #define DEFAULT_EDITOR "vi"
 #endif
 
+#define SCRATCHDIR ":tmp"
+
 static void
 vipwedit(const char *file, int (*file_lock)(void), int (*file_unlock)(void))
 {
@@ -117,22 +143,51 @@
   int status;
   FILE *f;
   char filebackup[1024], fileedit[1024];
+  char *to_rename;
 
   snprintf(filebackup, sizeof filebackup, "%s-", file);
-  snprintf(fileedit, sizeof fileedit, "%s.edit", file);
+  if (securemode) {
+    if (mkdir(TCB_DIR "/" SCRATCHDIR, 0700) && errno != EEXIST) {
+       fprintf(stderr, "%s when trying to mkdir " TCB_DIR "/" SCRATCHDIR
+         "\nare you sure you're the admin here? :^)\n", strerror(errno));
+       exit(1);
+    }
+    snprintf(fileedit, sizeof fileedit, TCB_DIR "/" SCRATCHDIR "/.vipw.shadow.%s", user);
+  }
+  else
+    snprintf(fileedit, sizeof fileedit, "%s.edit", file);
   unlock = file_unlock;
   filename = file;
   fileeditname = fileedit;
   
+  if (securemode && !s_drop_priv()) {
+    fprintf(stderr, "Unable to open %s\n", file);
+    exit(1);
+  }
   if (access(file, F_OK)) vipwexit(file, 1, 1);
+  if (securemode && !s_gain_priv()) {
+    fprintf(stderr, "Unable to gain privs\n");
+    exit(1);
+  }
+
   if (!file_lock()) vipwexit(_("Couldn't lock file"), errno, 5);
+
   filelocked = 1;
+  if (securemode && !s_drop_priv()) {
+    fprintf(stderr, "Unable to open %s\n", file);
+    exit(1);
+  }
 
   /* edited copy has same owners, perm */
   if (stat(file, &st1)) vipwexit(file, 1, 1);
   if (!(f = fopen(file, "r"))) vipwexit(file, 1, 1);
+  if (securemode && !s_gain_priv()) {
+    fprintf(stderr, "Unable to gain privs\n");
+    exit(1);
+  }
   if (create_backup_file(f, fileedit, &st1))
     vipwexit(_("Couldn't make backup"), errno, 1);
+
   createedit = 1;
   
   editor = getenv("VISUAL");
@@ -182,17 +237,46 @@
      without saving).  Use pwck or grpck to do the check.  --marekm */
 
   createedit = 0;
+  if (securemode) {
+    if (!prep_new(&to_rename, fileedit, file)) {
+      fprintf(stderr, _("%s: can't restore %s: %s (your changes are in %s)\n"),
+	progname, file, strerror(errno), fileedit);
+      vipwexit(0,0,1);
+    }
+  } else
+    to_rename = fileedit;
+
   unlink(filebackup);
   link(file, filebackup);
-  if (rename(fileedit, file) == -1) {
+  if (rename(to_rename, file) == -1) {
     fprintf(stderr, _("%s: can't restore %s: %s (your changes are in %s)\n"),
 	    progname, file, strerror(errno), fileedit);
     vipwexit(0,0,1);
   }
+  if (securemode && !s_gain_priv()) {
+    fprintf(stderr, "Unable to gain privs\n");
+    exit(1);
+  }
 
   (*file_unlock)();
 }
 
+static void
+usage(void)
+{
+  if (getdef_bool("USE_TCB"))
+    fprintf(stderr,
+"Usage:\n"
+"`vipw' edits /etc/passwd        `vipw -s user' edits /etc/tcb/user/shadow\n"
+"`vigr' edits /etc/group         `vigr -s' edits /etc/gshadow\n");
+  else
+    fprintf(stderr,
+"Usage:\n"
+"`vipw' edits /etc/passwd        `vipw -s' edits /etc/shadow\n"
+"`vigr' edits /etc/group         `vigr -s' edits /etc/gshadow\n");
+}
+
+extern struct commonio_db shadow_db;
 
 int
 main(int argc, char **argv)
@@ -224,18 +308,25 @@
     case 'h':
       e = 0;
     default:
-      printf(_("Usage:\n\
-`vipw' edits /etc/passwd        `vipw -s' edits /etc/shadow\n\
-`vigr' edits /etc/group         `vigr -s' edits /etc/gshadow\n\
-"));
+      usage();
       exit(e);
     }
   }
 
+  if (do_vipw && editshadow && getdef_bool("USE_TCB")) {
+    securemode = 1;
+    user = argv[optind];
+    if (!user) {
+      usage();
+      exit(1);
+    }
+    if (!tcb_user(user))
+      exit(1);
+  }
   if (do_vipw) {
 #ifdef SHADOWPWD
     if (editshadow)
-      vipwedit(SHADOW_FILE, spw_lock, spw_unlock);
+      vipwedit(shadow_db.filename, spw_lock, spw_unlock);
     else
 #endif
       vipwedit(PASSWD_FILE, pw_lock, pw_unlock);

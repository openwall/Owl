diff -ur shadow-4.0.0-owl-warnings/configure.in shadow-4.0.0/configure.in
--- shadow-4.0.0-owl-warnings/configure.in	Mon Aug  6 12:30:27 2001
+++ shadow-4.0.0/configure.in	Sun Nov 11 03:37:30 2001
@@ -27,7 +27,7 @@
 AC_HEADER_STDC
 AC_HEADER_SYS_WAIT
 
-AC_CHECK_HEADERS(fcntl.h limits.h unistd.h sys/time.h utmp.h utmpx.h \
+AC_CHECK_HEADERS(errno.h fcntl.h limits.h unistd.h sys/time.h utmp.h utmpx.h \
 	termios.h termio.h sgtty.h sys/ioctl.h syslog.h paths.h usersec.h \
 	utime.h ulimit.h sys/resource.h gshadow.h shadow.h lastlog.h \
 	rpc/key_prot.h)
diff -ur shadow-4.0.0-owl-warnings/lib/defines.h shadow-4.0.0/lib/defines.h
--- shadow-4.0.0-owl-warnings/lib/defines.h	Fri Jun 29 00:47:05 2001
+++ shadow-4.0.0/lib/defines.h	Sun Nov 11 03:37:30 2001
@@ -43,6 +43,10 @@
 # endif
 #endif /* not STDC_HEADERS */
 
+#if HAVE_ERRNO_H
+# include <errno.h>
+#endif
+
 /* Solaris 2.4 defines __SVR4, but not SVR4 -j. */
 
 #ifdef __SVR4
diff -ur shadow-4.0.0-owl-warnings/lib/prototypes.h shadow-4.0.0/lib/prototypes.h
--- shadow-4.0.0-owl-warnings/lib/prototypes.h	Sat Aug 26 22:27:17 2000
+++ shadow-4.0.0/lib/prototypes.h	Sun Nov 11 03:37:30 2001
@@ -55,7 +55,7 @@
 extern int is_listed(const char *, const char *, int);
 
 /* copydir.c */
-extern int copy_tree(const char *, const char *, uid_t, gid_t);
+extern int copy_tree(const char *, const char *, uid_t, gid_t, int);
 extern int remove_tree(const char *);
 
 /* encrypt.c */
diff -ur shadow-4.0.0-owl-warnings/libmisc/copydir.c shadow-4.0.0/libmisc/copydir.c
--- shadow-4.0.0-owl-warnings/libmisc/copydir.c	Thu Jun 28 22:27:29 2001
+++ shadow-4.0.0/libmisc/copydir.c	Sun Nov 11 03:37:30 2001
@@ -125,7 +125,8 @@
  */
 
 int
-copy_tree(const char *src_root, const char *dst_root, uid_t uid, gid_t gid)
+copy_tree(const char *src_root, const char *dst_root, uid_t uid, gid_t gid,
+	  int preserve)
 {
 	char	src_name[1024];
 	char	dst_name[1024];
@@ -135,6 +136,7 @@
 	int	err = 0;
 	int	cnt;
 	int	set_orig = 0;
+	int	open_flags;
 	struct	DIRECT	*ent;
 	struct	stat	sb;
 	struct	link_name *lp;
@@ -206,7 +208,7 @@
 			chown (dst_name, uid == (uid_t) -1 ? sb.st_uid:uid,
 				gid == (gid_t) -1 ? sb.st_gid:gid);
 
-			if (copy_tree (src_name, dst_name, uid, gid)) {
+			if (copy_tree (src_name, dst_name, uid, gid, preserve)) {
 				err++;
 				break;
 			}
@@ -293,14 +295,22 @@
 			err++;
 			break;
 		}
-		if ((ofd = open (dst_name, O_WRONLY|O_CREAT|O_TRUNC, 0)) < 0 ||
+		open_flags = O_WRONLY | O_CREAT;
+		if (preserve)
+			open_flags |= O_EXCL;
+		if ((ofd = open (dst_name, open_flags, 0)) < 0 ||
 			chown (dst_name, uid == (uid_t) -1 ? sb.st_uid:uid,
 					gid == (gid_t) -1 ? sb.st_gid:gid) ||
 				chmod (dst_name, sb.st_mode & 07777)) {
+			if (preserve && (errno == EEXIST)) {
+				close (ifd);
+				continue;
+			}
 			close (ifd);
 			err++;
 			break;
 		}
+		ftruncate (ofd, 0);
 		while ((cnt = read (ifd, buf, sizeof buf)) > 0) {
 			if (write (ofd, buf, cnt) != cnt) {
 				cnt = -1;
diff -ur shadow-4.0.0-owl-warnings/man/groupadd.8 shadow-4.0.0/man/groupadd.8
--- shadow-4.0.0-owl-warnings/man/groupadd.8	Sat Jan 27 05:55:52 2001
+++ shadow-4.0.0/man/groupadd.8	Sun Nov 11 03:37:30 2001
@@ -29,7 +29,7 @@
 .SH NAME
 groupadd \- Create a new group
 .SH SYNOPSIS
-\fBgroupadd\fR [\fB-g\fI gid \fR[\fB-o\fR]] \fIgroup\fR
+\fBgroupadd\fR [\fB-g\fI gid \fR[\fB-o\fR]] [\fB-r\fR] [\fB-f\fR] \fIgroup\fR
 .SH DESCRIPTION
 The \fBgroupadd\fR command
 creates a new group account using the values specified on the
@@ -40,9 +40,29 @@
 The numerical value of the group's ID.
 This value must be unique, unless the \fB-o\fR option is used.
 The value must be non-negative.
-The default is to use the smallest ID value greater than 99 and
+The default is to use the smallest ID value greater than 500 and
 greater than every other group.
-Values between 0 and 99 are typically reserved for system accounts.
+Values between 0 and 499 are typically reserved for \fIsystem accounts\fR.
+.IP \fB-r\fR
+This flag instructs \fBgroupadd\fR to add a \fIsystem
+account\fR.  First available \fIgid\fR lower than 499 will be
+automatically selected unless \fB-g\fR option is given also on the
+command line.
+.br
+This is an option added by Red Hat Software.
+.IP \fB-f\fR
+This is \fIforce\fR flag.  This will stop \fBgroupadd\fR exit with
+error when the group about to be added already exists on the
+system.  If that is the case, the group won't be altered (or added
+again, for that matter).
+.br
+This option also modifies the way \fB-g\fR option works.  When you
+request a \fIgid\fR that is not unique and you don't give \fB-o\fR
+option too, the group creation will fall back to the standard behavior
+(adding a group as if neither \fB-g\fR nor \fB-o\fR options were
+specified).
+.br
+This is an option added by Red Hat Software.
 .SH FILES
 /etc/group \- group account information
 .br
diff -ur shadow-4.0.0-owl-warnings/man/useradd.8 shadow-4.0.0/man/useradd.8
--- shadow-4.0.0-owl-warnings/man/useradd.8	Sat Jan 27 05:55:52 2001
+++ shadow-4.0.0/man/useradd.8	Sun Nov 11 03:37:30 2001
@@ -36,9 +36,9 @@
 .br
 [\fB-g\fR \fIinitial_group\fR] [\fB-G\fR \fIgroup\fR[,...]]
 .br
-[\fB-m\fR [\fB-k\fR \fIskeleton_dir\fR]] [\fB-p\fR \fIpasswd\fR]
+[\fB-m\fR [\fB-k\fR \fIskeleton_dir\fR] | \fI-M\fR] [\fB-p\fR \fIpasswd\fR]
 .br
-[\fB-s\fR \fIshell\fR] [\fB-u\fR \fIuid\fR [\fB-o\fR]] \fIlogin\fR
+[\fB-s\fR \fIshell\fR] [\fB-u\fR \fIuid\fR [\fB-o\fR]] [\fI-n\fR] [\fI-r\fR]\fR \fIlogin\fR
 .TP 8
 \fBuseradd\fR \fB-D\fR [\fB-g\fI default_group\fR] [\fB-b\fI default_home\fR]
 .br
@@ -53,6 +53,9 @@
 The new user account will be entered into the system files as needed,
 the home directory will be created, and initial files copied, depending
 on the command line options.
+This version of \fBuseradd\fR will create a group for each
+user added to the system, unless \fB-n\fR option is given.
+This behavior was introduced by Red Hat Software.
 The options which apply to the \fBuseradd\fR command are:
 .IP "\fB-c \fIcomment\fR"
 The new user's password file comment field.
@@ -94,8 +97,23 @@
 option.
 The default is to not create the directory and to not copy any
 files.
+.IP \fB-M\fR
+The user home directory will not be created, even if the system-wide
+setting in \fI/etc/login.defs\fR is to create home directories.
+.IP \fB-n\fR
+A group having the same name as the user being added to the system
+will be created by default.
+This option will turn off this Red Hat Linux-style behavior.
+.IP \fB-r\fR
+This flag is used to create a system account.  That is, a user with an
+UID lower than value of UID_MIN defined in \fI/etc/login.defs\fR.  Note
+that \fBuseradd\fR will not create a home directory for such a user
+regardless of the setting in \fI/etc/login.defs\fR.
+You have to specify \fB-m\fR option if you want a home directory for a
+system account to be created.
+This is an option added by Red Hat Software.
 .IP "\fB-p \fIpasswd\fR"
-The encrypted password, as returned by \fBcrypt\fR(3).
+The encrypted password as returned by \fBcrypt\fR(3).
 The default is to disable the account.
 .IP "\fB-s \fIshell\fR"
 The name of the user's login shell.
@@ -147,6 +165,8 @@
 /etc/group \- group information
 .br
 /etc/default/useradd \- default information
+.br
+/etc/login.defs \- system-wide settings
 .br
 /etc/skel \- directory containing default files
 .SH SEE ALSO
diff -ur shadow-4.0.0-owl-warnings/src/groupadd.c shadow-4.0.0/src/groupadd.c
--- shadow-4.0.0-owl-warnings/src/groupadd.c	Mon Oct  9 23:02:20 2000
+++ shadow-4.0.0/src/groupadd.c	Sun Nov 11 03:37:30 2001
@@ -78,6 +78,10 @@
 static int oflg = 0; /* permit non-unique group ID to be specified with -g */
 static int gflg = 0; /* ID value for the new group */
 static int fflg = 0; /* if group already exists, do nothing and exit(0) */
+static int rflg = 0; /* for adding system accounts (RedHat) */
+
+/* For adding "system" accounts */
+#define MIN_GID		10
 
 #ifdef	NDBM
 extern	int	gr_dbm_mode;
@@ -108,7 +112,7 @@
 static void
 usage(void)
 {
-	fprintf(stderr, _("usage: groupadd [-g gid [-o]] group\n"));
+	fprintf(stderr, _("usage: groupadd [-g gid [-o]]  [-r] [-f] group\n"));
 	exit(E_USAGE);
 }
 
@@ -233,8 +237,13 @@
 	const struct group *grp;
 	gid_t gid_min, gid_max;
 
-	gid_min = getdef_num("GID_MIN", 100);
-	gid_max = getdef_num("GID_MAX", 60000);
+	if (!rflg) {
+	    gid_min = getdef_num("GID_MIN", 500);
+	    gid_max = getdef_num("GID_MAX", 60000);
+	} else {
+	    gid_min = MIN_GID;
+	    gid_max = getdef_num("GID_MIN", 499);
+	}
 
 	/*
 	 * Start with some GID value if the user didn't provide us with
@@ -344,7 +353,7 @@
 	char *cp;
 	int arg;
 
-	while ((arg = getopt(argc, argv, "og:O:f")) != EOF) {
+	while ((arg = getopt(argc, argv, "og:O:fr")) != EOF) {
 		switch (arg) {
 		case 'g':
 			gflg++;
@@ -389,7 +398,13 @@
 			 */
 			fflg++;
 			break;
-		default:
+		    case 'r':
+			/*
+			 * create a system group
+			 */
+			rflg++;
+			break;
+		    default:
 			usage();
 		}
 	}
diff -ur shadow-4.0.0-owl-warnings/src/useradd.c shadow-4.0.0/src/useradd.c
--- shadow-4.0.0-owl-warnings/src/useradd.c	Sun Nov 11 03:39:46 2001
+++ shadow-4.0.0/src/useradd.c	Sun Nov 11 03:40:04 2001
@@ -81,7 +81,7 @@
 static gid_t def_group = 100;
 static const char *def_gname = "other";
 static const char *def_home = "/home";
-static const char *def_shell = "";
+static const char *def_shell = "/dev/null";
 static const char *def_template = SKEL_DIR;
 #ifdef SHADOWPWD
 static long def_inactive = -1;
@@ -93,7 +93,7 @@
 #define	VALID(s)	(strcspn (s, ":\n") == strlen (s))
 
 static const char *user_name = "";
-static const char *user_pass = "!";
+static const char *user_pass = "!!";
 static uid_t user_id;
 static gid_t user_gid;
 static const char *user_comment = "";
@@ -125,7 +125,10 @@
 	kflg = 0, /* specify a directory to fill new user directory */
 	fflg = 0, /* days until account with expired password is locked */
 	eflg = 0, /* days since 1970-01-01 when account is locked */
-	Dflg = 0; /* set/show new user default values */
+	Dflg = 0, /* set/show new user default values */
+	Mflg = 0, /* do NOT create user's home directory no matter what */
+	nflg = 0, /* do not add a group for this user */
+	rflg = 0; /* create a system account */
 
 #ifdef AUTH_METHODS
 static int Aflg = 0; /* specify authentication method for user */
@@ -727,7 +730,7 @@
 #ifdef AUTH_METHODS
 	fprintf(stderr, _("[-A program] "));
 #endif
-	fprintf(stderr, _("[-p passwd] name\n"));
+	fprintf(stderr, _("[-p passwd] [-n] [-r] name\n"));
 
 	fprintf(stderr, _("       %s\t-D [-g group] [-b base] [-s shell]\n"),
 		Prog);
@@ -823,31 +826,8 @@
 	struct sgrp *nsgrp;
 #endif
 
-	/*
-	 * Lock and open the group file.  This will load all of the group
-	 * entries.
-	 */
-
-	if (! gr_lock ()) {
-		fprintf(stderr, _("%s: error locking group file\n"), Prog);
-		fail_exit(E_GRP_UPDATE);
-	}
-	if (! gr_open (O_RDWR)) {
-		fprintf(stderr, _("%s: error opening group file\n"), Prog);
-		fail_exit(E_GRP_UPDATE);
-	}
-#ifdef	SHADOWGRP
-	if (is_shadow_grp && ! sgr_lock ()) {
-		fprintf(stderr, _("%s: error locking shadow group file\n"),
-			Prog);
-		fail_exit(E_GRP_UPDATE);
-	}
-	if (is_shadow_grp && ! sgr_open (O_RDWR)) {
-		fprintf(stderr, _("%s: error opening shadow group file\n"),
-			Prog);
-		fail_exit(E_GRP_UPDATE);
-	}
-#endif
+	/* Locking and opening of the group files moved to open_files()
+	 * --gafton */
 
 	/*
 	 * Scan through the entire group file looking for the groups that
@@ -985,8 +965,13 @@
 	const struct passwd *pwd;
 	uid_t uid_min, uid_max;
 
-	uid_min = getdef_num("UID_MIN", 100);
-	uid_max = getdef_num("UID_MAX", 60000);
+	if (!rflg) {
+	    uid_min = getdef_num("UID_MIN", 500);
+	    uid_max = getdef_num("UID_MAX", 60000);
+	} else {
+	    uid_min = 1;
+	    uid_max = 499;
+	}
 
 	/*
 	 * Start with some UID value if the user didn't provide us with
@@ -1052,6 +1037,88 @@
 	}
 }
 
+/*
+ * find_new_gid - find the next available GID
+ *
+ *	find_new_gid() locates the next highest unused GID in the group
+ *	file, or checks the given group ID against the existing ones for
+ *	uniqueness.
+ */
+
+static void
+find_new_gid()
+{
+	const struct group *grp;
+	gid_t gid_min, gid_max;
+
+	if (!rflg) {
+	    gid_min = getdef_num("GID_MIN", 500);
+	    gid_max = getdef_num("GID_MAX", 60000);
+	} else {
+	    gid_min = 1;
+	    gid_max = 499;
+	}
+
+	/*
+	 * Start with some GID value if the user didn't provide us with
+	 * one already.
+	 */
+
+	user_gid = gid_min;
+
+	/*
+	 * Search the entire group file, either looking for this
+	 * GID (if the user specified one with -g) or looking for the
+	 * largest unused value.
+	 */
+
+#ifdef NO_GETGRENT
+	gr_rewind();
+	while ((grp = gr_next()))
+#else
+	setgrent();
+	while ((grp = getgrent()))
+#endif
+	    {
+		if (strcmp(user_name, grp->gr_name) == 0) {
+		    user_gid = grp->gr_gid;
+		    return;
+		}
+		if (grp->gr_gid >= user_gid) {
+		    if (grp->gr_gid > gid_max)
+			continue;
+		    user_gid = grp->gr_gid + 1;
+		}
+	}
+#ifndef NO_GETGRENT /* RH Linux does have this, so ... */
+	/* A quick test gets here: if the UID is available
+	 * as a GID, go ahead and use it */
+	if (!getgrgid(user_id)) {
+	    user_gid = user_id;
+	    return;
+	}
+#endif
+	if (user_gid == gid_max + 1) {
+		for (user_gid = gid_min; user_gid < gid_max; user_gid++) {
+#ifdef NO_GETGRENT
+			gr_rewind();
+			while ((grp = gr_next()) && grp->gr_gid != user_gid)
+				;
+			if (!grp)
+				break;
+#else
+			if (!getgrgid(user_gid))
+				break;
+#endif
+		}
+		if (user_gid == gid_max) {
+			fprintf(stderr, "%s: can't get unique gid (run out of GIDs)\n",
+				Prog);
+			fail_exit(4);
+		}
+	}
+}
+
 #ifdef AUTH_METHODS
 /*
  * convert_auth - convert the argument list to a authentication list
@@ -1142,9 +1209,9 @@
 	char *cp;
 
 #ifdef SHADOWPWD
-#define FLAGS "A:Du:og:G:d:s:c:mk:p:f:e:b:O:M"
+#define FLAGS "A:Du:og:G:d:s:c:mk:p:f:e:b:O:Mnr"
 #else
-#define FLAGS "A:Du:og:G:d:s:c:mk:p:b:O:M"
+#define FLAGS "A:Du:og:G:d:s:c:mk:p:b:O:Mnr"
 #endif
 	while ((arg = getopt(argc, argv, FLAGS)) != EOF) {
 #undef FLAGS
@@ -1268,12 +1335,6 @@
 		case 'm':
 			mflg++;
 			break;
-		case 'M':
-			/*
-			 * don't create home dir - this is the default,
-			 * ignored for RedHat/PLD adduser compatibility.
-			 */
-			break;
 		case 'o':
 			oflg++;
 			break;
@@ -1318,6 +1379,15 @@
 			user_id = get_number(optarg);
 			uflg++;
 			break;
+		case 'M':
+		    Mflg++;
+		    break;
+		case 'n':
+		    nflg++;
+		    break;
+		case 'r':
+		    rflg++;
+		    break;
 		default:
 			usage();
 		}
@@ -1328,9 +1398,12 @@
 	 * Certain options are only valid in combination with others.
 	 * Check it here so that they can be specified in any order.
 	 */
-	if ((oflg && !uflg) || (kflg && !mflg))
+	if (kflg && !mflg)
 		usage();
 
+	if (mflg && Mflg) /* the admin hasn't decided to create or not? */
+	    usage();
+
 	/*
 	 * Either -D or username is required.  Defaults can be set with -D
 	 * for the -b, -e, -f, -g, -s options only.
@@ -1451,6 +1524,31 @@
 		exit(E_PW_UPDATE);
 	}
 #endif
+	/*
+	 * Lock and open the group file.  This will load all of the group
+	 * entries.
+	 */
+
+	if (! gr_lock ()) {
+		fprintf(stderr, _("%s: error locking group file\n"), Prog);
+		fail_exit(E_GRP_UPDATE);
+	}
+	if (! gr_open (O_RDWR)) {
+		fprintf(stderr, _("%s: error opening group file\n"), Prog);
+		fail_exit(E_GRP_UPDATE);
+	}
+#ifdef	SHADOWGRP
+	if (is_shadow_grp && ! sgr_lock ()) {
+		fprintf(stderr, _("%s: error locking shadow group file\n"),
+			Prog);
+		fail_exit(E_GRP_UPDATE);
+	}
+	if (is_shadow_grp && ! sgr_open (O_RDWR)) {
+		fprintf(stderr, _("%s: error opening shadow group file\n"),
+			Prog);
+		fail_exit(E_GRP_UPDATE);
+	}
+#endif        /* SHADOWGRP*/
 }
 
 
@@ -1499,9 +1597,6 @@
 	struct	spwd	spent;
 #endif
 
-	if (! oflg)
-		find_new_uid ();
-
 #ifdef AUTH_METHODS
 	if (Aflg) {
 		convert_auth(user_auth, auth_arg);
@@ -1631,11 +1726,119 @@
 		grp_update();
 }
 
+/* a fake something */
+static char *empty_list = NULL;
+
+/*
+ * new_grent - initialize the values in a group file entry
+ *
+ *	new_grent() takes all of the values that have been entered and
+ *	fills in a (struct group) with them.
+ */
+
+static void
+new_grent(grent)
+	struct group *grent;
+{
+	bzero ((char *) grent, sizeof *grent);
+	(const char *) (grent->gr_name) = user_name;
+	grent->gr_passwd = "x";
+	grent->gr_gid = user_gid;
+	grent->gr_mem = &empty_list;
+}
+
+#ifdef	SHADOWGRP
+/*
+ * new_sgent - initialize the values in a shadow group file entry
+ *
+ *	new_sgent() takes all of the values that have been entered and
+ *	fills in a (struct sgrp) with them.
+ */
+
+static void
+new_sgent(sgent)
+	struct sgrp *sgent;
+{
+	bzero ((char *) sgent, sizeof *sgent);
+	(const char *)(sgent->sg_name) = user_name;
+	sgent->sg_passwd = "!";
+	sgent->sg_adm = &empty_list;
+	sgent->sg_mem = &empty_list;
+}
+#endif	/* SHADOWGRP */
+
+/*
+ * grp_update - add new group file entries
+ *
+ *	grp_update() writes the new records to the group files.
+ */
+
+static void grp_add()
+{
+	struct	group	grp;
+#ifdef	SHADOWGRP
+	struct	sgrp	sgrp;
+#endif	/* SHADOWGRP */
+
+	/*
+	 * Create the initial entries for this new group.
+	 */
+
+	new_grent (&grp);
+#ifdef	SHADOWGRP
+	new_sgent (&sgrp);
+#endif	/* SHADOWGRP */
+
+	/*
+	 * Write out the new group file entry.
+	 */
+	if (! gr_update (&grp)) {
+		fprintf (stderr, "%s: error adding new group entry\n", Prog);
+		fail_exit (10);
+	}
+
+#ifdef	NDBM
+	/*
+	 * Update the DBM group file with the new entry as well.
+	 */
+	if (gr_dbm_present() && ! gr_dbm_update (&grp)) {
+		fprintf (stderr, "%s: cannot add new dbm group entry\n", Prog);
+		fail_exit (10);
+	}
+	endgrent ();
+#endif	/* NDBM */
+
+#ifdef	SHADOWGRP
+	/*
+	 * Write out the new shadow group entries as well.
+	 */
+	if (is_shadow_grp && ! sgr_update (&sgrp)) {
+		fprintf (stderr, "%s: error adding new group entry\n", Prog);
+		fail_exit (10);
+	}
+
+#ifdef	NDBM
+	/*
+	 * Update the DBM group file with the new entry as well.
+	 */
+	if (is_shadow_grp && sg_dbm_present() && ! sg_dbm_update (&sgrp)) {
+		fprintf (stderr, "%s: cannot add new dbm group entry\n", Prog);
+		fail_exit (10);
+	}
+	endsgent ();
+#endif	/* NDBM */
+#endif	/* SHADOWGRP */
+	SYSLOG((LOG_INFO, "new group: name=%s, gid=%d\n",
+		user_name, user_gid));
+	/* we need to remember we have to close the group file... */
+	do_grp_update++;
+}
+
 /*
  * create_home - create the user's home directory
  *
  *	create_home() creates the user's home directory if it does not
- *	already exist.  It will be created mode 755 owned by the user
+ *	already exist.  It will be created mode 700 owned by the user
  *	with the user's default group.
  */
 
@@ -1650,11 +1853,7 @@
 			fail_exit(E_HOMEDIR);
 		}
 		chown (user_home, user_id, user_gid);
-#if 1
-		chmod(user_home, 0777 & ~getdef_num("UMASK", 077));
-#else
-		chmod (user_home, 0755);
-#endif
+		chmod (user_home, 0777 & ~getdef_num ("UMASK", 077));
 		home_added++;
 	}
 }
@@ -1750,6 +1949,14 @@
 
 	process_flags(argc, argv);
 
+	if (!rflg) /* for system accounts defaults are ignored and we
+		    * do not create a home dir -- gafton */
+	    if (getdef_bool("CREATE_HOME"))
+		mflg = 1;
+
+	if (Mflg) /* absolutely sure that we do not create home dirs */
+	    mflg = 0;
+	
 	/*
 	 * See if we are messing with the defaults file, or creating
 	 * a new user.
@@ -1768,8 +1975,12 @@
 	 */
 
 	if (getpwnam(user_name)) {
+	    if (!oflg) {
 		fprintf(stderr, _("%s: user %s exists\n"), Prog, user_name);
 		exit(E_NAME_IN_USE);
+	    } else {
+		exit(E_SUCCESS);
+	    }
 	}
 
 	/*
@@ -1792,27 +2003,23 @@
 
 	open_files ();
 
+	/* first, seek for a valid uid to use for this user.
+	 * We do this because later we can use the uid we found as
+	 * gid too ... --gafton */
+	if (! uflg)
+	    find_new_uid ();
+	/* do we have to add a group for that user? This is why we need to
+	 * open the group files in the open_files() function  --gafton */
+	if (! (nflg || gflg)) {
+	    find_new_gid();
+	    grp_add();
+	}
+		    
 	usr_update ();
 
 	if (mflg) {
 		create_home ();
-		copy_tree (def_template, user_home, user_id, user_gid);
-	} else if (getdef_str("CREATE_HOME")) {
-		/*
-		 * RedHat added the CREATE_HOME option in login.defs in their
-		 * version of shadow-utils (which makes -m the default, with
-		 * new -M option to turn it off).  Unfortunately, this
-		 * changes the way useradd works (it can be run by scripts
-		 * expecting some standard behaviour), compared to other
-		 * Unices and other Linux distributions, and also adds a lot
-		 * of confusion :-(.
-		 * So we now recognize CREATE_HOME and give a warning here
-		 * (better than "configuration error ... notify administrator"
-		 * errors in every program that reads /etc/login.defs).  -MM
-		 */
-		fprintf(stderr,
-	_("%s: warning: CREATE_HOME not supported, please use -m instead.\n"),
-			Prog);
+		copy_tree (def_template, user_home, user_id, user_gid, 1);
 	}
 
 	close_files ();
diff -ur shadow-4.0.0-owl-warnings/src/userdel.c shadow-4.0.0/src/userdel.c
--- shadow-4.0.0-owl-warnings/src/userdel.c	Mon Oct  9 23:02:20 2000
+++ shadow-4.0.0/src/userdel.c	Sun Nov 11 03:37:30 2001
@@ -65,7 +65,9 @@
 
 static char *user_name;
 static uid_t user_id;
+static gid_t user_gid;
 static char *user_home;
+static char *user_group;
 
 static char	*Prog;
 static int fflg = 0, rflg = 0;
@@ -284,6 +286,93 @@
 #endif	/* SHADOWGRP */
 }
 
+/* remove_group()
+ * remove the user's group unless it is not really a user-private group
+ */
+static void
+remove_group ()
+{
+	char	**glist_name;
+	struct	group	*gr;
+	struct	passwd	*pwd;
+#ifdef	NDBM
+	struct	group	*ogrp;
+#endif
+
+	if (user_group == NULL || user_name == NULL)
+	    return;
+
+	if (strcmp(user_name, user_group))
+	    return;
+
+	glist_name = NULL;
+	gr = getgrnam(user_group);
+	if (gr)
+	    glist_name = gr->gr_mem;
+	if (glist_name)
+	while (*glist_name) {
+		if (strcmp(*glist_name, user_name))
+		    return;
+		glist_name++;
+	}
+
+	setpwent();
+	while ((pwd = getpwent())) {
+	    if (strcmp(pwd->pw_name, user_name) == 0)
+		continue;
+
+	    if (pwd->pw_gid == user_gid) {
+		return;
+	    }
+	}
+
+	/* now actually do the removal if we haven't already returned */
+
+	if (! gr_remove (user_group)) {
+	    fprintf (stderr, "%s: error removing group entry\n", Prog);
+	}
+
+#ifdef	NDBM
+	/*
+	 * Update the DBM group file
+	 */
+	if (gr_dbm_present()) {
+		if ((ogrp = getgrnam (user_group)) &&
+				! gr_dbm_remove (ogrp)) {
+			fprintf (stderr, "%s: error removing group dbm entry\n",
+				Prog);
+		}
+	}
+	endgrent ();
+#endif	/* NDBM */
+
+#ifdef	SHADOWGRP
+	/*
+	 * Delete the shadow group entries as well.
+	 */
+	if (is_shadow_grp && ! sgr_remove (user_group)) {
+		fprintf (stderr, "%s: error removing shadow group entry\n",
+			Prog);
+	}
+
+#ifdef	NDBM
+	/*
+	 * Update the DBM shadow group file
+	 */
+	if (is_shadow_grp && sg_dbm_present()) {
+		if (! sg_dbm_remove (user_group)) {
+			fprintf (stderr,
+				"%s: error removing shadow group dbm entry\n",
+				Prog);
+		}
+	}
+	endsgent ();
+#endif	/* NDBM */
+#endif	/* SHADOWGRP */
+	SYSLOG((LOG_INFO, "remove group `%s'\n", user_group));
+	return;
+}
+
 /*
  * close_files - close all of the files that were opened
  *
@@ -548,7 +637,8 @@
 
 		fprintf(stderr, _("%s: user %s is currently logged in\n"),
 			Prog, name);
-		exit(E_USER_BUSY);
+		if (!fflg)
+			exit(E_USER_BUSY);
 	}
 }
 
@@ -690,6 +780,7 @@
 main(int argc, char **argv)
 {
 	struct	passwd	*pwd;
+	struct	group	*gr;
 	int	arg;
 	int	errors = 0;
 #ifdef USE_PAM
@@ -816,6 +907,9 @@
 #endif
 	user_id = pwd->pw_uid;
 	user_home = xstrdup(pwd->pw_dir);
+	user_gid = pwd->pw_gid;
+	gr = getgrgid(pwd->pw_gid);
+	user_group = gr ? xstrdup(gr->gr_name) : NULL;
 
 	/*
 	 * Check to make certain the user isn't logged in.
@@ -872,6 +966,9 @@
 		}
 	}
 #endif
+
+	/* remove user's group if appropriate */
+	remove_group ();
 
 	if (rflg) {
 		if (remove_tree(user_home) || rmdir(user_home)) {
diff -ur shadow-4.0.0-owl-warnings/src/usermod.c shadow-4.0.0/src/usermod.c
--- shadow-4.0.0-owl-warnings/src/usermod.c	Sat Sep  1 08:19:16 2001
+++ shadow-4.0.0/src/usermod.c	Sun Nov 11 03:37:30 2001
@@ -1501,7 +1501,7 @@
 				}
 				if (copy_tree (user_home, user_newhome,
 						uflg ? user_newid:-1,
-						gflg ? user_newgid:-1) == 0 &&
+						gflg ? user_newgid:-1, 0) == 0 &&
 					remove_tree (user_home) == 0 &&
 						rmdir (user_home) == 0)
 					return;

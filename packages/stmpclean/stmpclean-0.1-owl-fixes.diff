diff -urN stmpclean-0.1.orig/Makefile stmpclean-0.1/Makefile
--- stmpclean-0.1.orig/Makefile	Wed Aug  4 22:30:02 1999
+++ stmpclean-0.1/Makefile	Sat Mar 30 03:25:08 2002
@@ -2,19 +2,21 @@
 # Written by Stanislav Shalunov.
 # $Id: Makefile,v 1.4 1999/08/04 18:30:02 shalunov Exp $
 
-PREFIX=/usr/local
-BINDIR=$(PREFIX)/sbin
-MANDIR=$(PREFIX)/man/man8
+DESTDIR =
+PREFIX = /usr/local
+BINDIR = $(PREFIX)/sbin
+MANDIR = $(PREFIX)/man
 
-CFLAGS += -O6 -Wall -W -pedantic
+CC = gcc
+CFLAGS = -O2 -fomit-frame-pointer -Wall -W -pedantic
 
 all:		stmpclean stmpclean.0
 
 install:	all
-	if [ ! -d $(BINDIR) ] ; then mkdir -p -m 0755 $(BINDIR); fi
-	if [ ! -d $(MANDIR) ] ; then mkdir -p -m 0755 $(MANDIR); fi
-	install -c -o root -g wheel -m 0555 stmpclean $(BINDIR)
-	install -c -o root -g wheel -m 0444 stmpclean.8 $(MANDIR)
+	mkdir -p -m 755 $(DESTDIR)$(BINDIR) $(DESTDIR)$(MANDIR)/man8
+	install -m 755 stmpclean $(DESTDIR)$(BINDIR)/
+	ln -s stmpclean $(DESTDIR)$(BINDIR)/tmpwatch
+	install -m 644 stmpclean.8 tmpwatch.8 $(DESTDIR)$(MANDIR)/man8/
 
 stmpclean.o:	stmpclean.c
 
diff -urN stmpclean-0.1.orig/stmpclean.8 stmpclean-0.1/stmpclean.8
--- stmpclean-0.1.orig/stmpclean.8	Wed Aug  4 21:12:34 1999
+++ stmpclean-0.1/stmpclean.8	Sat Mar 30 00:26:39 2002
@@ -80,6 +80,7 @@
 as
 .Bl -tag -width example
 .It Li "stmpclean /tmp /var/tmp"
+.El
 .Sh SEE ALSO
 .Xr cron 8
 .Sh BUGS
diff -urN stmpclean-0.1.orig/stmpclean.c stmpclean-0.1/stmpclean.c
--- stmpclean-0.1.orig/stmpclean.c	Wed Aug  4 19:48:39 1999
+++ stmpclean-0.1/stmpclean.c	Sat Mar 30 04:15:53 2002
@@ -1,7 +1,7 @@
 /* stmpclean.c -- remove old files from a world-writable directory.
-   
+
    Copyright (C)  1999, Stanislav Shalunov.
-   
+
    Redistribution and use in source and binary forms, standalone or as
    a part of a larger product, are permitted provided that the above
    copyright notice and this paragraph are duplicated in all such
@@ -17,6 +17,7 @@
         "$Id: stmpclean.c,v 1.3 1999/08/04 15:48:39 shalunov Exp $";
 #endif
 
+#define _GNU_SOURCE
 #include <sys/types.h>
 #include <sys/time.h>
 #include <sys/resource.h>
@@ -31,7 +32,16 @@
 #include <fcntl.h>
 #include <dirent.h>
 #include <time.h>
+#include <grp.h>
 #include <errno.h>
+#include <libgen.h>
+
+#ifndef O_DIRECTORY
+#define O_DIRECTORY 0
+#endif
+#ifndef O_NOFOLLOW
+#define O_NOFOLLOW 0
+#endif
 
 /* How deep to descend into directories?  Won't go any deeper than
    MAX_DEPTH levels.  */
@@ -42,20 +52,27 @@
 #define SECONDS_IN_A_DAY    (SECONDS_IN_AN_HOUR * 24)
 #define SECONDS_IN_A_WEEK   (SECONDS_IN_A_DAY * 7)
 
-#define GETCWD {if (getcwd(cwd, MAXPATHLEN) == NULL)\
+#define GETCWD {if (getcwd(cwd, sizeof(cwd)) == NULL) \
 		strcpy(cwd, "/FULL/PATH/TOO/LONG");}
 
+/* Are we emulating tmpwatch? */
+static int	am_tmpwatch;
 /* Time at the start of the program, in seconds since beginning of epoch. */
 static time_t   now;
-/* Minimum age (mtime) of a file or empty directory to be deleted. */
-int             minage;
+/* Minimum age (atime) of a file or empty directory to be deleted. */
+static int      minage;
 /* Current working directory is used for logging purposes only. */
 static char     cwd[MAXPATHLEN];
 
 /* Print usage message, exit with a failure. */
 void
-usage()
+usage(void)
 {
+	if (am_tmpwatch) {
+		fprintf(stderr, "stmpclean: "
+			"Don't know how to emulate these tmpwatch options.\n");
+		exit(1);
+	}
 	fprintf(stderr,
 		"Usage: stmpclean [-t <timespec>] dir1 [dir2 [dir3]...]]\n\n"
 		"Where time specification <timespec> is a string like 1w\n"
@@ -68,7 +85,7 @@
 
 /* Parse time specification (a la sendmail queue time), return its
    value in seconds, or -1 if the spec is invalid.
-  
+
    Side effects: Modifies contents of timespec.  */
 int
 parse_time(timespec)
@@ -76,14 +93,16 @@
 {
 	char           *p, *q;
 	char            symbol;
-	int             result, num, multiple;
+	int             result, num, multiple, seconds;
 
 	result = 0;
 	p = timespec;
 	while (*p) {
-		if (!isdigit(*p))
+		if (!isdigit((int)(unsigned char)*p))
+			return -1;
+		for (q = p; isdigit((int)(unsigned char)*q); q++);
+		if (q == p || q - p > 9)
 			return -1;
-		for (q = p; isdigit(*q); q++);
 		symbol = *q;
 		*q = 0;
 		num = atoi(p);
@@ -92,6 +111,8 @@
 		   again anyway.  I didn't want to have strdup()s here
 		   all around, did you?  */
 		*q = symbol;
+		if (am_tmpwatch)
+			return symbol ? -1 : num;
 		switch (symbol) {
 		case 'w':
 			multiple = SECONDS_IN_A_WEEK;
@@ -111,8 +132,11 @@
 		default:
 			return -1;
 		}
-		result += num * multiple;
-		if (result < 0)
+		seconds = num * multiple;
+		if (seconds < 0 || seconds / multiple != num)
+			return -1;
+		result += seconds;
+		if (result < seconds)
 			return -1;
 		p = q + 1;
 	}
@@ -125,7 +149,12 @@
 	uid_t           uid;
 	gid_t           gid;
 {
-	if ((setegid(gid) == -1) || (seteuid(uid) == -1)) {
+	gid_t groups[2];
+
+	groups[0] = groups[1] = gid;
+	if ((uid && setgroups(1, groups))
+	    || setegid(gid) || seteuid(uid)
+	    || (!uid && setgroups(1, groups))) {
 		syslog(LOG_ERR, "cannot set EUID/EGID to %d/%d, exiting",
 		       uid, gid);
 		exit(1);
@@ -182,6 +211,8 @@
 		return;
 	}
 	if (lstat(dir, &st) == -1) {
+		if (errno == ENOENT)
+			return;
 		GETCWD;
 		syslog(LOG_ERR, "RACE?: lstat(\"%s\") in %s failed: %m, "
 		       "exiting", dir, cwd);
@@ -193,8 +224,10 @@
 		       dir, cwd);
 		exit(1);
 	}
-	dir_fd = open(dir, O_RDONLY);
+	dir_fd = open(dir, O_RDONLY | O_NONBLOCK | O_DIRECTORY | O_NOFOLLOW);
 	if (dir_fd == -1) {
+		if (errno == ENOENT)
+			return;
 		GETCWD;
 		syslog(LOG_ERR,
 		       "RACE?: cannot open(\"%s\"): %m (lstat was OK), "
@@ -219,7 +252,8 @@
 	}
 	/* We'll chdir up later once done with recursive descend.
 	   Hence the name. */
-	dot_dot_fd = open(".", O_RDONLY);
+	dot_dot_fd = open(".",
+		O_RDONLY | O_NONBLOCK | O_DIRECTORY | O_NOFOLLOW);
 	if (dot_dot_fd == -1) {
 		GETCWD;
 		syslog(LOG_ERR, "open(\".\") in %s: %m, exiting", cwd);
@@ -258,11 +292,18 @@
 			/* Looking at a directory. */
 			if (isemptydir(dp->d_name)) {
 				/* Looking at an empty directory. */
-				if (now - st.st_mtime > minage && st.st_uid) {
+				if (now - st.st_atime > minage && st.st_uid) {
 					/* An old non-root owned directory. */
 					setecreds(st.st_uid, st.st_gid);
 					if (rmdir(dp->d_name) == -1
-					    && errno != EACCES) {
+					    && errno != ENOENT
+					    && errno != EACCES
+					    && errno != EPERM) {
+						if (errno == ENOTEMPTY) {
+							setecreds(0, 0);
+							goto notempty;
+						}
+						setecreds(0, 0);
 						GETCWD;
 						syslog(LOG_ERR, "RACE?: rmdir"
 						       "(\"%s\") in %s: %m, "
@@ -273,6 +314,7 @@
 					setecreds(0, 0);
 				}
 			} else {
+notempty:
 				/*
 				 * Looking at a non-empty directory. Clean it
 				 * recursively (call ourselves).
@@ -281,10 +323,14 @@
 			}
 		} else {
 			/* Looking at a non-directory. */
-			if (now - st.st_mtime > minage && st.st_uid) {
+			if (now - st.st_atime > minage && st.st_uid) {
 				/* Old non-root owned non-directory. */
 				setecreds(st.st_uid, st.st_gid);
-				if (unlink(dp->d_name) == -1) {
+				if (unlink(dp->d_name) == -1
+				    && errno != ENOENT
+				    && errno != EACCES
+				    && errno != EPERM) {
+					setecreds(0, 0);
 					GETCWD;
 					syslog(LOG_ERR, "RACE?: unlink(\"%s\")"
 					       "in %s: %m, exiting",
@@ -315,15 +361,27 @@
 	/* By default, delete files older than three days. */
 	extern char    *optarg;
 	extern int      optind;
+	char	       *me;
 	int             c, i;
 	struct rlimit	rlp;
 
 	if (argc <= 0)
 		usage();
+	me = strdup(argv[0]);
+	if (!me) {
+		errno = ENOMEM;
+		perror("strdup");
+		exit(1);
+	}
+	am_tmpwatch = !strcmp(basename(me), "tmpwatch");
 	openlog("stmpclean", LOG_PID | LOG_CONS | LOG_PERROR, LOG_DAEMON);
 	minage = SECONDS_IN_A_DAY * 3;
-	while ((c = getopt(argc, argv, "t:")) != -1)
+	while ((c = getopt(argc, argv, am_tmpwatch ? "uaf" : "t:")) != -1)
 		switch (c) {
+		case 'u':
+		case 'a':
+		case 'f':
+			break;
 		case 't':
 			minage = parse_time(optarg);
 			if (minage == -1)
@@ -334,8 +392,14 @@
 		}
 	argc -= optind;
 	argv += optind;
-	if (argc <= 0)
+	if (argc <= (am_tmpwatch ? 1 : 0))
 		usage();
+	if (am_tmpwatch) {
+		argc--;
+		minage = parse_time(*argv++);
+		if (minage == -1)
+			usage();
+	}
 	/* For logging niceties in case one of the directories on the
 	   command line is bad.  */
 	chdir("/");
diff -urN stmpclean-0.1.orig/tmpwatch.8 stmpclean-0.1/tmpwatch.8
--- stmpclean-0.1.orig/tmpwatch.8	Thu Jan  1 03:00:00 1970
+++ stmpclean-0.1/tmpwatch.8	Sat Mar 30 03:24:51 2002
@@ -0,0 +1 @@
+.so man8/stmpclean.8

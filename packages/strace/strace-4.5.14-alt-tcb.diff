2006-03-29  Dmitry V. Levin  <ldv at altlinux.org>

	Fix race conditions in tcb allocation.
	* process.c (fork_tcb): Return error code as documented.  Do not
	print "tcb table full" error message.
	[USE_PROCFS] (internal_fork): Do not print "tcb table full"
	error message.
	[SYS_clone || SYS_clone2] (internal_clone, internal_fork): Call
	fork_tcb() before alloctcb().  Do not print "tcb table full"
	error message.
	* strace.c (main): Do not print "tcb table full" error message.
	(expand_tcbtab): Print error message in case of memory allocation
	failure.
	(alloctcb): Print error message when tcb table is full.
	(trace): Expand tcb table if necessary prior to allocating
	entry there.  Do not print "tcb table full" error message.
	Fixes RH#180293.

diff -upk.orig strace-4.5.14.orig/process.c strace-4.5.14/process.c
--- strace-4.5.14.orig/process.c	2005-08-03 11:23:43 +0000
+++ strace-4.5.14/process.c	2006-03-29 00:17:05 +0000
@@ -412,7 +412,7 @@ fork_tcb(struct tcb *tcp)
 	if (nprocs == tcbtabsize) {
 		if (expand_tcbtab()) {
 			tcp->flags &= ~TCB_FOLLOWFORK;
-			fprintf(stderr, "sys_fork: tcb table full\n");
+			return 1;
 		}
 	}
 
@@ -474,10 +474,8 @@ struct tcb *tcp;
 			return 0;
 		if (syserror(tcp))
 			return 0;
-		if ((tcpchild = alloctcb(tcp->u_rval)) == NULL) {
-			fprintf(stderr, "sys_fork: tcb table full\n");
+		if ((tcpchild = alloctcb(tcp->u_rval)) == NULL)
 			return 0;
-		}
 		if (proc_open(tcpchild, 2) < 0)
 		  	droptcb(tcpchild);
 	}
@@ -823,10 +821,9 @@ struct tcb *tcp;
 		}
 		else
 #endif
-		if ((tcpchild = alloctcb(pid)) == NULL) {
+		if (fork_tcb(tcp) || (tcpchild = alloctcb(pid)) == NULL) {
 			if (bpt)
 				clearbpt(tcp);
-			fprintf(stderr, " [tcb table full]\n");
 			kill(pid, SIGKILL); /* XXX */
 			return 0;
 		}
@@ -960,8 +957,7 @@ struct tcb *tcp;
 			return 0;
 
 		pid = tcp->u_rval;
-		if ((tcpchild = alloctcb(pid)) == NULL) {
-			fprintf(stderr, " [tcb table full]\n");
+		if (fork_tcb(tcp) || (tcpchild = alloctcb(pid)) == NULL) {
 			kill(pid, SIGKILL); /* XXX */
 			return 0;
 		}
diff -upk.orig strace-4.5.14.orig/strace.c strace-4.5.14/strace.c
--- strace-4.5.14.orig/strace.c	2006-01-12 09:50:49 +0000
+++ strace-4.5.14/strace.c	2006-03-29 00:18:53 +0000
@@ -435,11 +435,8 @@ char *argv[];
 							tcp = NULL;
 						else
 							tcp = alloctcb(tid);
-						if (tcp == NULL) {
-							fprintf(stderr, "%s: out of memory\n",
-								progname);
+						if (tcp == NULL)
 							exit(1);
-						}
 						tcp->flags |= TCB_ATTACHED|TCB_CLONE_THREAD|TCB_CLONE_DETACHED|TCB_FOLLOWFORK;
 						tcbtab[c]->nchildren++;
 						tcbtab[c]->nclone_threads++;
@@ -619,7 +616,6 @@ Process %u attached - interrupt to quit\
 		}
 		default:
 			if ((tcp = alloctcb(pid)) == NULL) {
-				fprintf(stderr, "tcb table full\n");
 				cleanup();
 				exit(1);
 			}
@@ -718,6 +714,8 @@ expand_tcbtab()
 	if (newtab == NULL || newtcbs == NULL) {
 		if (newtab != NULL)
 			free(newtab);
+		fprintf(stderr, "%s: expand_tcbtab: out of memory\n",
+			progname);
 		return 1;
 	}
 	for (i = tcbtabsize; i < 2 * tcbtabsize; ++i)
@@ -756,6 +754,7 @@ int pid;
 			return tcp;
 		}
 	}
+	fprintf(stderr, "%s: alloctcb: tcb table full\n", progname);
 	return NULL;
 }
 
@@ -2097,8 +2096,12 @@ trace()
 				   will we have the association of parent and
 				   child so that we know how to do clearbpt
 				   in the child.  */
-				if ((tcp = alloctcb(pid)) == NULL) {
-					fprintf(stderr, " [tcb table full]\n");
+				if (nprocs == tcbtabsize &&
+				    expand_tcbtab())
+					tcp = NULL;
+				else
+					tcp = alloctcb(pid);
+				if (tcp == NULL) {
 					kill(pid, SIGKILL); /* XXX */
 					return 0;
 				}

Add -k option.

2003-12-15  Dmitry V. Levin <ldv@altlinux.org>

	* strace.c (main, trace): Handle -k option.  When specified,
	strace attempts to keep exit status of traced processes,
	and return it to the caller.
	* strace.1: Document it.

diff -uprk.orig strace-4.5.1.orig/strace.1 strace-4.5.1/strace.1
--- strace-4.5.1.orig/strace.1	2003-10-22 10:16:32 +0400
+++ strace-4.5.1/strace.1	2003-12-15 00:43:19 +0300
@@ -43,7 +43,7 @@ strace \- trace system calls and signals
 .SH SYNOPSIS
 .B strace
 [
-.B \-dffhiqrtttTvxx
+.B \-dffhikqrtttTvxx
 ]
 [
 .BI \-a column
@@ -277,6 +277,11 @@ Suppress messages about attaching, detac
 automatically when output is redirected to a file and the command
 is run directly instead of attaching.
 .TP
+.B \-k
+Attempt to keep exit status of traced processes, and return it to the caller.
+Main purpose of this option is to exit with nonzero code in case of
+unsucessful exit of a last traced process.
+.TP
 .B \-r
 Print a relative timestamp upon entry to each system call.  This
 records the time difference between the beginning of successive
diff -uprk.orig strace-4.5.1.orig/strace.c strace-4.5.1/strace.c
--- strace-4.5.1.orig/strace.c	2003-11-12 00:24:23 +0300
+++ strace-4.5.1/strace.c	2003-12-15 00:43:19 +0300
@@ -70,6 +70,9 @@ int pflag_seen = 0;
 /* Sometimes we want to print only succeeding syscalls. */
 int not_failing_only = 0;
 
+static int keep_status = 0;
+static int return_code = 0;
+
 char *username = NULL;
 uid_t run_uid;
 gid_t run_gid;
@@ -134,7 +137,7 @@ FILE *ofp;
 int exitval;
 {
 	fprintf(ofp, "\
-usage: strace [-dffhiqrtttTvVxx] [-a column] [-e expr] ... [-o file]\n\
+usage: strace [-dffhikqrtttTvVxx] [-a column] [-e expr] ... [-o file]\n\
               [-p pid] ... [-s strsize] [-u username] [-E var=val] ...\n\
               [command [arg ...]]\n\
    or: strace -c [-e expr] ... [-O overhead] [-S sortby] [-E var=val] ...\n\
@@ -143,6 +146,7 @@ usage: strace [-dffhiqrtttTvVxx] [-a col
 -f -- follow forks, -ff -- with output into separate files\n\
 -F -- attempt to follow vforks, -h -- print help message\n\
 -i -- print instruction pointer at time of syscall\n\
+-k -- attempt to keep exit status of traced processes\n\
 -q -- suppress messages about attaching, detaching, etc.\n\
 -r -- print relative timestamp, -t -- absolute timestamp, -tt -- with usecs\n\
 -T -- print time spent in each syscall, -V -- print version\n\
@@ -205,7 +209,7 @@ char *argv[];
 	set_sortby(DEFAULT_SORTBY);
 	set_personality(DEFAULT_PERSONALITY);
 	while ((c = getopt(argc, argv,
-		"+cdfFhiqrtTvVxza:e:o:O:p:s:S:u:E:")) != EOF) {
+		"+cdfFhikqrtTvVxza:e:o:O:p:s:S:u:E:")) != EOF) {
 		switch (c) {
 		case 'c':
 			cflag++;
@@ -226,6 +230,9 @@ char *argv[];
 		case 'i':
 			iflag++;
 			break;
+		case 'k':
+			keep_status++;
+			break;
 		case 'q':
 			qflag++;
 			break;
@@ -593,7 +600,7 @@ char *argv[];
 	if (trace() < 0)
 		exit(1);
 	cleanup();
-	exit(0);
+	exit(return_code);
 }
 
 void
@@ -2019,6 +2026,8 @@ Process %d attached (waiting for parent)
 			continue;
 		}
 		if (WIFSIGNALED(status)) {
+			if (keep_status)
+				return_code = 128 + WTERMSIG(status);
 			if (!cflag
 			    && (qual_flags[WTERMSIG(status)] & QUAL_SIGNAL)) {
 				printleader(tcp);
@@ -2034,6 +2043,8 @@ Process %d attached (waiting for parent)
 			continue;
 		}
 		if (WIFEXITED(status)) {
+			if (keep_status)
+				return_code = WEXITSTATUS(status);
 			if (debug)
 				fprintf(stderr, "pid %u exited\n", pid);
 			if (tcp->flags & TCB_ATTACHED)

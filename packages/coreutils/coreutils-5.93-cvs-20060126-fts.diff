2006-01-26  Paul Eggert  <eggert at cs.ucla.edu>

	* fts.c (diropen): Open with O_NOCTTY | O_NONBLOCK too.
	Don't attempt to open for write; this always fails, at
	least on POSIX hosts.

2006-01-21  Jim Meyering  <jim at meyering.net>

	* fts.c (fts_children): Don't let close() clobber errno from
	failed fchdir().

2006-01-11  Jim Meyering  <jim at meyering.net>

	* fts.c (fts_stat): When following a symlink-to-directory,
	don't necessarily interpret stat-fails+lstat-succeeds as indicating
	a dangling symlink.  That can also happen at least for ELOOP.
	The fix: return FTS_SLNONE only when the stat errno is ENOENT.
	FYI, this bug predates the inclusion of fts.c in coreutils.

2006-01-10  Jim Meyering  <jim at meyering.net>

	* tests/chmod/no-x: Add a test for today's fts.c fix.

2006-01-10  Jim Meyering  <jim at meyering.net>

	Avoid the double-free (first in fts_read, second in fts_close) that
	would occur when an `active' directory is made inaccessible (e.g.,
	via chmod a-x) during a traversal.
	* fts.c (fts_read): After a failed fchdir, update sp->fts_cur
	before returning.  Reproduce this failure by
	mkdir -p a/b; cd a; chmod a-x . b
	Reported by Stavros Passas.

2006-01-04  Jim Meyering  <jim at meyering.net>

	Merge from glibc.
	* fts.c (fts_open): Avoid function call in MAX macro use.

--- lib/fts.c	12 Aug 2005 13:00:57 -0000	1.37
+++ lib/fts.c	26 Jan 2006 22:11:40 -0000	1.37.2.5
@@ -203,10 +203,7 @@ static int
 internal_function
 diropen (char const *dir)
 {
-  int fd = open (dir, O_RDONLY | O_DIRECTORY);
-  if (fd < 0)
-    fd = open (dir, O_WRONLY | O_DIRECTORY);
-  return fd;
+  return open (dir, O_RDONLY | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);
 }
 
 FTS *
@@ -244,8 +241,11 @@ fts_open (char * const *argv,
 #ifndef MAXPATHLEN
 # define MAXPATHLEN 1024
 #endif
-	if (! fts_palloc(sp, MAX(fts_maxarglen(argv), MAXPATHLEN)))
-		goto mem1;
+	{
+	  size_t maxarglen = fts_maxarglen(argv);
+	  if (! fts_palloc(sp, MAX(maxarglen, MAXPATHLEN)))
+		  goto mem1;
+	}
 
 	/* Allocate/initialize root's parent. */
 	if ((parent = fts_alloc(sp, "", 0)) == NULL)
@@ -524,6 +524,7 @@ next:	tmp = p;
 		if (p->fts_level == FTS_ROOTLEVEL) {
 			if (FCHDIR(sp, sp->fts_rfd)) {
 				SET(FTS_STOP);
+				sp->fts_cur = p;
 				return (NULL);
 			}
 			fts_load(sp, p);
@@ -694,7 +695,9 @@ fts_children (register FTS *sp, int inst
 		return (sp->fts_child = NULL);
 	sp->fts_child = fts_build(sp, instr);
 	if (fchdir(fd)) {
+		int saved_errno = errno;
 		(void)close(fd);
+		__set_errno (saved_errno);
 		return (NULL);
 	}
 	(void)close(fd);
@@ -1067,7 +1070,8 @@ fts_stat(FTS *sp, register FTSENT *p, bo
 	if (ISSET(FTS_LOGICAL) || follow) {
 		if (stat(p->fts_accpath, sbp)) {
 			saved_errno = errno;
-			if (!lstat(p->fts_accpath, sbp)) {
+			if (errno == ENOENT
+			    && lstat(p->fts_accpath, sbp) == 0) {
 				__set_errno (0);
 				return (FTS_SLNONE);
 			}
--- tests/chmod/no-x	19 Oct 2003 19:11:00 -0000	1.3
+++ tests/chmod/no-x	10 Jan 2006 11:42:39 -0000	1.3.4.1
@@ -37,4 +37,13 @@ EOF
 cmp out exp || fail=1
 test $fail = 1 && diff out exp 2> /dev/null
 
+mkdir -p a/b
+cd a
+# This will fail with ``chmod: fts_read failed: Permission denied''
+chmod a-x . b 2> /dev/null && fail=1
+# chmod must exit with status 1.
+# Due to a bug in coreutils-5.93's fts.c, chmod would provoke
+# an abort (exit with status 134) on recent glibc-based systems.
+test $? = 1 || fail=1
+
 (exit $fail); exit $fail

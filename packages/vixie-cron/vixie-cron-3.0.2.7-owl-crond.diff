--- vixie-cron-3.0.2.7/usr.sbin/cron/database.c.orig	Thu Jul 19 00:44:08 2001
+++ vixie-cron-3.0.2.7/usr.sbin/cron/database.c	Thu Jul 19 00:52:49 2001
@@ -36,6 +36,17 @@
 					     struct stat *,
 					     cron_db *, cron_db *));
 
+struct spooldir {
+	char *path;
+	char *uname;
+	char *fname;
+};
+
+static struct spooldir spools[] = {
+	{SPOOL_DIR, NULL, NULL},
+	{"/etc/cron.d", "root", "*system*"},
+	{NULL, NULL, NULL}
+};
 
 void
 load_database(old_db)
@@ -47,23 +58,27 @@
 	DIR_T   	*dp;
 	cron_db		new_db;
 	user		*u, *nu;
-
+	struct spooldir *p = spools;
+	time_t		maxtime;
+		
 	Debug(DLOAD, ("[%d] load_database()\n", getpid()))
 
-	/* before we start loading any data, do a stat on SPOOL_DIR
-	 * so that if anything changes as of this moment (i.e., before we've
-	 * cached any of the database), we'll see the changes next time.
-	 */
-	if (stat(SPOOL_DIR, &statbuf) < OK) {
-		log_it("CRON", getpid(), "STAT FAILED", SPOOL_DIR);
-		(void) exit(ERROR_EXIT);
-	}
-
 	/* track system crontab file
 	 */
 	if (stat(SYSCRONTAB, &syscron_stat) < OK)
 		syscron_stat.st_mtime = 0;
 
+	maxtime = syscron_stat.st_mtime;
+	while (p->path) {
+		if (stat(p->path, &statbuf) < OK) {
+			log_it("CRON", getpid(), "STAT FAILED", p->path);
+			(void) exit(ERROR_EXIT);
+		}
+		if (statbuf.st_mtime > maxtime)
+			maxtime = statbuf.st_mtime;
+		p++;
+	}
+
 	/* if spooldir's mtime has not changed, we don't need to fiddle with
 	 * the database.
 	 *
@@ -71,7 +86,7 @@
 	 * so is guaranteed to be different than the stat() mtime the first
 	 * time this function is called.
 	 */
-	if (old_db->mtime == HASH(statbuf.st_mtime, syscron_stat.st_mtime)) {
+	if (old_db->mtime == maxtime) {
 		Debug(DLOAD, ("[%d] spool dir mtime unch, no load needed.\n",
 			      getpid()))
 		return;
@@ -82,7 +97,7 @@
 	 * actually changed.  Whatever is left in the old database when
 	 * we're done is chaff -- crontabs that disappeared.
 	 */
-	new_db.mtime = HASH(statbuf.st_mtime, syscron_stat.st_mtime);
+	new_db.mtime = maxtime;
 	new_db.head = new_db.tail = NULL;
 
 	if (syscron_stat.st_mtime) {
@@ -91,36 +106,46 @@
 				&new_db, old_db);
 	}
 
-	/* we used to keep this dir open all the time, for the sake of
-	 * efficiency.  however, we need to close it in every fork, and
-	 * we fork a lot more often than the mtime of the dir changes.
-	 */
-	if (!(dir = opendir(SPOOL_DIR))) {
-		log_it("CRON", getpid(), "OPENDIR FAILED", SPOOL_DIR);
-		(void) exit(ERROR_EXIT);
-	}
-
-	while (NULL != (dp = readdir(dir))) {
-		char	fname[MAXNAMLEN+1],
-			tabname[MAXPATHLEN];
-
-		/* avoid file names beginning with ".".  this is good
-		 * because we would otherwise waste two guaranteed calls
-		 * to getpwnam() for . and .., and also because user names
-		 * starting with a period are just too nasty to consider.
-		 */
-		if (dp->d_name[0] == '.')
-			continue;
-
-		if (strlen(dp->d_name) > sizeof(fname) - 1) continue;
-		(void) strcpy(fname, dp->d_name);
-		snprintf(tabname, sizeof(tabname), CRON_TAB(fname));
-		if (strlen(tabname) >= sizeof(tabname) - 1) continue;
-
-		process_crontab(fname, fname, tabname,
-				&statbuf, &new_db, old_db);
-	}
-	closedir(dir);
+	p = spools;
+ 	while (p->path) {
+ 		if (!(dir = opendir(p->path))) {
+ 			log_it("CRON", getpid(), "OPENDIR FAILED", p->path);
+ 			(void) exit(ERROR_EXIT);
+ 		}
+ 
+ 		while (NULL != (dp = readdir(dir))) {
+ 			char	fname[MAXNAMLEN+1],
+ 				tabname[MAXPATHLEN];
+ 
+ 			/* Don't try to parse any files containing a dot ('.')
+ 			 * or ending with a tilde ('~'). This catches the case
+			 * of '.' and '..', as well as preventing the parsing
+			 * of many editor files, temporary files and those
+			 * saved by RPM package upgrades.
+ 			 */
+ 			if ( !dp->d_name[0] /* Shouldn't happen */ || 
+ 			      strchr(dp->d_name, '.') ||
+ 			      dp->d_name[strlen(dp->d_name)-1] == '~')
+ 				continue;
+ 
+ 			if (strlen(dp->d_name) > sizeof(fname) - 1) continue;
+ 			(void) strcpy(fname, dp->d_name);
+ 			snprintf(tabname, sizeof(tabname), "%s/%s", p->path, fname);
+ 			if (strlen(tabname) >= sizeof(tabname) - 1) continue;
+ 
+ 			process_crontab(p->uname ? p->uname : fname,
+ 					p->fname ? p->fname : fname,
+ 					tabname,
+ 					&statbuf, &new_db, old_db);
+ 		}
+ 		closedir(dir);
+ 		/* we used to keep this dir open all the time, for the sake of
+ 		 * efficiency.  however, we need to close it in every fork, and
+ 		 * we fork a lot more often than the mtime of the dir changes.
+  		 */
+  
+ 		p++;
+  	}
 
 	/* if we don't do this, then when our children eventually call
 	 * getpwnam() in do_command.c's child_process to verify MAILTO=,
@@ -143,7 +168,6 @@
 	*old_db = new_db;
 	Debug(DLOAD, ("load_database is done\n"))
 }
-
 
 void
 link_user(db, u)
--- vixie-cron-3.0.2.7/usr.sbin/cron/cron.8.orig	Thu Jul 19 00:44:08 2001
+++ vixie-cron-3.0.2.7/usr.sbin/cron/cron.8	Thu Jul 19 00:44:17 2001
@@ -45,8 +45,11 @@
 .Nm
 also searches for
 .Pa /etc/crontab
-which is in a different format (see
-.Xr crontab 5 ) .
+and the files in the 
+.Pa /etc/cron.d/
+directory which are in a different format (see
+.Xr crontab 5 ), excluding files with names containing
+a dot ('.') or ending with a tilde ('~').
 .Nm
 then wakes up every minute, examining all loaded crontabs, checking each
 command to see if it should be run in the current minute.

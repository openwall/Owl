diff -ur pam-0.75.orig/modules/pam_pwdb/Makefile pam-0.75/modules/pam_pwdb/Makefile
--- pam-0.75.orig/modules/pam_pwdb/Makefile	Fri Jan  5 01:51:31 2001
+++ pam-0.75/modules/pam_pwdb/Makefile	Sun Oct  7 08:58:59 2001
@@ -26,9 +26,8 @@
 LIBOBJD = $(addprefix dynamic/,$(LIBOBJ))
 #LIBOBJS = $(addprefix static/,$(LIBOBJ))
 LIBDEPS = pam_unix_acct.-c pam_unix_auth.-c pam_unix_passwd.-c \
-	pam_unix_sess.-c pam_unix_pwupd.-c support.-c bigcrypt.-c
+	pam_unix_sess.-c pam_unix_pwupd.-c support.-c
 
-PLUS += md5_good.o md5_broken.o md5_crypt_good.o md5_crypt_broken.o
 CFLAGS += $(EXTRAS)
 
 ifdef DYNAMIC
@@ -51,11 +50,10 @@
 	@echo "*** Building PAM_pwdb module..."
 	@echo
 
-$(CHKPWD): pwdb_chkpwd.o md5_good.o md5_broken.o \
-           md5_crypt_good.o md5_crypt_broken.o
+$(CHKPWD): pwdb_chkpwd.o
 	$(CC) -o $(CHKPWD) $^ -lpwdb
 
-pwdb_chkpwd.o: pwdb_chkpwd.c pam_unix_md.-c bigcrypt.-c
+pwdb_chkpwd.o: pwdb_chkpwd.c pam_unix_md.-c
 
 md5_good.o: md5.c
 	$(CC) $(CFLAGS) $(CPPFLAGS) -DHIGHFIRST -D'MD5Name(x)=Good##x' \
@@ -106,7 +104,7 @@
 	$(INSTALL) -m $(SHLIBMODE) $(LIBSHARED) $(FAKEROOT)$(SECUREDIR)
 endif
 	$(MKDIR) $(FAKEROOT)$(SUPLEMENTED)
-	$(INSTALL) -m 4555 $(CHKPWD) $(FAKEROOT)$(SUPLEMENTED)
+	$(INSTALL) -m 700 $(CHKPWD) $(FAKEROOT)$(SUPLEMENTED)
 
 remove:
 	rm -f $(FAKEROOT)$(SECUREDIR)/$(TITLE).so
diff -ur pam-0.75.orig/modules/pam_pwdb/pam_pwdb.c pam-0.75/modules/pam_pwdb/pam_pwdb.c
--- pam-0.75.orig/modules/pam_pwdb/pam_pwdb.c	Fri Jan  5 01:51:31 2001
+++ pam-0.75/modules/pam_pwdb/pam_pwdb.c	Sun Oct  7 08:54:18 2001
@@ -190,7 +190,7 @@
 
     pwdb_start();
     ctrl = set_ctrl(flags, argc, argv);
-    retval = _unix_chauthtok(pamh, ctrl);
+    retval = _unix_chauthtok(pamh, ctrl, argc, argv);
     pwdb_end();
 
     D(("done."));
diff -ur pam-0.75.orig/modules/pam_pwdb/pam_unix_acct.-c pam-0.75/modules/pam_pwdb/pam_unix_acct.-c
--- pam-0.75.orig/modules/pam_pwdb/pam_unix_acct.-c	Mon Jan 22 19:04:15 2001
+++ pam-0.75/modules/pam_pwdb/pam_unix_acct.-c	Sun Oct  7 08:54:12 2001
@@ -145,7 +145,7 @@
 	warn_days = *((const int *) pwe->value);
 	(void) pwdb_entry_delete(&pwe);
 
-	if ((daysleft <= warn_days) && (warn_days > 0)) {
+	if ((daysleft <= warn_days) && (warn_days > 0) && daysleft >= 0) {
 	    char *s;
 
 	    if ( on(UNIX_DEBUG, ctrl) ) {
diff -ur pam-0.75.orig/modules/pam_pwdb/pam_unix_md.-c pam-0.75/modules/pam_pwdb/pam_unix_md.-c
--- pam-0.75.orig/modules/pam_pwdb/pam_unix_md.-c	Mon Jan  3 22:01:53 2000
+++ pam-0.75/modules/pam_pwdb/pam_unix_md.-c	Sun Oct  7 08:54:18 2001
@@ -9,6 +9,9 @@
  * software freely from the US, please do not send me any. (AGM)
  */
 
+#include <crypt.h>
+
+#if 0
 /* this should have been defined in a header file.. Why wasn't it? AGM */
 extern char *crypt(const char *key, const char *salt);
 
@@ -27,10 +30,12 @@
 const static struct cfns cfn_list[N_MDS] = {
     { "$1$", 3, Goodcrypt_md5 },
 };
+#endif
 
 static char *_pam_md(const char *key, const char *salt)
 {
     char *x,*e=NULL;
+#if 0
     int i;
 
     D(("called with key='%s', salt='%s'", key, salt));
@@ -47,12 +52,16 @@
     if ( i >= N_MDS ) {
 	e = bigcrypt(key, salt);      /* (defaults to standard algorithm) */
     }
+#endif
+
+    e = crypt(key, salt);
 
     x = x_strdup(e);                        /* put e in malloc()ed memory */
     _pam_overwrite(e);                                        /* clean up */
     return x;                           /* this must be deleted elsewhere */
 }
 
+#if 0
 #ifndef PWDB_NO_MD_COMPAT
 static char *_pam_md_compat(const char *key, const char *salt)
 {
@@ -74,3 +83,4 @@
     return x;                           /* this must be deleted elsewhere */
 }
 #endif /* PWDB_NO_MD_COMPAT */
+#endif
diff -ur pam-0.75.orig/modules/pam_pwdb/pam_unix_passwd.-c pam-0.75/modules/pam_pwdb/pam_unix_passwd.-c
--- pam-0.75.orig/modules/pam_pwdb/pam_unix_passwd.-c	Mon Jan 22 19:04:15 2001
+++ pam-0.75/modules/pam_pwdb/pam_unix_passwd.-c	Sun Oct  7 08:54:18 2001
@@ -5,12 +5,20 @@
 " - PAM_PWDB password module <morgan@parc.power.net>"
 ;
 
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#define _OW_SOURCE
+#include <crypt.h>
+
 #include "pam_unix_pwupd.-c"
 
+#if 0
 /* passwd/salt conversion macros */
 
 #define ascii_to_bin(c) ((c)>='a'?(c-59):(c)>='A'?((c)-53):(c)-'.')
 #define bin_to_ascii(c) ((c)>=38?((c)-38+'a'):(c)>=12?((c)-12+'A'):(c)+'.')
+#endif
 
 /* data tokens */
 
@@ -19,6 +27,28 @@
 
 /* Implementation */
 
+static int read_loop(int fd, char *buffer, int count)
+{
+	int offset, block;
+
+	offset = 0;
+	while (count > 0) {
+		block = read(fd, &buffer[offset], count);
+
+		if (block < 0) {
+			if (errno == EINTR) continue;
+			return block;
+		}
+		if (!block) return offset;
+
+		offset += block;
+		count -= block;
+	}
+
+	return offset;
+}
+
+#if 0
 /*
  * i64c - convert an integer to a radix 64 character
  */
@@ -40,6 +70,7 @@
         return ('a' - 38 + i);
     return ('\0');
 }
+#endif
 
 /*
  * FUNCTION: _pam_unix_chauthtok() 
@@ -61,18 +92,39 @@
  * in this release (.52) mostly for the purpose of discussion.
  */
 
-static int _unix_chauthtok(pam_handle_t *pamh, unsigned int ctrl)
+static int _unix_chauthtok(pam_handle_t *pamh, unsigned int ctrl,
+	int argc, const char **argv)
 {
     int retval;
     unsigned int lctrl;
+    const char *prefix;
+    unsigned long count;
 
     /* <DO NOT free() THESE> */
     const char *user;
-    const char *pass_old, *pass_new;
+    const char *pass_old;
+    char *pass_new;
     /* </DO NOT free() THESE> */
 
     D(("called"));
 
+    prefix = "";
+    count = 0;
+
+    while (argc-- > 0) {
+	if (!strncmp(*argv, "prefix=", 7)) {
+	    prefix = *argv + 7;
+	    unset(UNIX_MD5_PASS, ctrl);
+	} else
+	if (!strncmp(*argv, "count=", 6))
+	    count = strtoul(*argv + 6, NULL, 0);
+
+	++argv;
+    }
+
+    if (on(UNIX_MD5_PASS, ctrl))
+	prefix = "$1$";
+
     /*
      * First get the name of a user
      */
@@ -150,10 +202,12 @@
 	}
 
     } else if ( on( UNIX__UPDATE, ctrl ) ) {
+#if 0
 	/* tpass is used below to store the _pam_md() return; it
 	 * should be _pam_delete()'d. */
 
 	char *tpass=NULL;     
+#endif
 
 	/*
 	 * obtain the proposed password
@@ -202,7 +256,7 @@
 				      , "Enter new UNIX password: "
 				      , "Retype new UNIX password: "
 				      , _UNIX_NEW_AUTHTOK
-				      , &pass_new );
+				      , (const char **)&pass_new );
 
 	if ( retval != PAM_SUCCESS ) {
 	    if ( on(UNIX_DEBUG,ctrl) ) {
@@ -221,7 +275,8 @@
 	 * password is acceptable.
 	 */
 
-	if (pass_new[0] == '\0') {     /* "\0" password = NULL */
+	/* "\0" password = NULL */
+	if (pass_new[0] == '\0' && on(UNIX__NONULL, ctrl)) {
 	    pass_new = NULL;
 	}
 
@@ -229,7 +284,7 @@
 
 	if (retval != PAM_SUCCESS) {
 	    _log_err(LOG_NOTICE, "new password not acceptable");
-	    pass_new = pass_old = NULL;	              /* tidy up */
+	    pass_new = NULL; pass_old = NULL;	           /* tidy up */
 	    return retval;
 	}
 
@@ -245,6 +300,7 @@
 	 *       of password handling... no encryption needed..
 	 */
 
+#if 0
 	if ( on(UNIX_MD5_PASS, ctrl) ) {
 
 	    /*
@@ -314,6 +370,39 @@
 		/* no longer need cleartext */
 		pass_new = tpass = _pam_md( pass_new, salt );
 	    }
+#endif
+	if (pass_new[0] != '\0') {
+		int fd;
+		char pool[16];
+		char *pw, *salt;
+
+		if ((fd = open("/dev/urandom", O_RDONLY)) < 0 ||
+		    read_loop(fd, pool, sizeof(pool)) != sizeof(pool)) {
+			if (fd >= 0) close(fd);
+			_log_err(LOG_CRIT, "failed to read /dev/urandom");
+			return PAM_ABORT;
+		}
+		close(fd);
+
+		salt = crypt_gensalt(prefix, count, pool, sizeof(pool));
+		memset(pool, 0, sizeof(pool));
+		if (!salt) {
+			_log_err(LOG_CRIT, "failed to generate salt");
+			return PAM_ABORT;
+		}
+
+		pw = pass_new;
+		pass_new = _pam_md(pw, salt);
+		_pam_overwrite(pw);	/* XXX: this changes the PAM item */
+		_pam_overwrite(salt);
+
+		if (pass_new && strchr(pass_new, ':'))
+			pass_new = _pam_delete(pass_new);
+
+		if (!pass_new) {
+			_log_err(LOG_CRIT, "failed to hash password");
+			return PAM_ABORT;
+		}
 	}
 
 	D(("password processed"));
diff -ur pam-0.75.orig/modules/pam_pwdb/pwdb_chkpwd.c pam-0.75/modules/pam_pwdb/pwdb_chkpwd.c
--- pam-0.75.orig/modules/pam_pwdb/pwdb_chkpwd.c	Mon Apr 23 22:14:19 2001
+++ pam-0.75/modules/pam_pwdb/pwdb_chkpwd.c	Sun Oct  7 09:02:48 2001
@@ -108,7 +108,7 @@
 	fprintf(stderr,
 		"This program is not designed for running in this way\n"
 		"-- the system administrator has been informed\n");
-	exit(UNIX_FAILED);
+	exit(1);
     }
 
     /*
@@ -127,7 +127,7 @@
     if (retval != PWDB_SUCCESS) {
 	_log_err(LOG_ALERT, "could not identify user");
 	while (pwdb_end() != PWDB_SUCCESS);
-	exit(UNIX_FAILED);
+	exit(1);
     }
     if (argc == 2) {
 	if (pwdb_get_entry(pw, "user", &pwe) == PWDB_SUCCESS) {
@@ -143,7 +143,7 @@
     }
 
     /* read the password from stdin (a pipe from the pam_pwdb module) */
-
+    /* XXX: should loop */
     npass = read(STDIN_FILENO, pass, MAXPASS);
 
     if (npass < 0) {                             /* is it a valid password? */
@@ -177,7 +177,7 @@
     
     /* return pass or fail */
 
-    exit(retval);
+    exit(retval == 0 ? 0 : 1);
 }
 
 /*
diff -ur pam-0.75.orig/modules/pam_pwdb/support.-c pam-0.75/modules/pam_pwdb/support.-c
--- pam-0.75.orig/modules/pam_pwdb/support.-c	Mon Apr 23 22:39:04 2001
+++ pam-0.75/modules/pam_pwdb/support.-c	Sun Oct  7 09:09:36 2001
@@ -228,7 +228,12 @@
 	}
 
 	if ( j >= UNIX_CTRLS_ ) {
-	    _log_err(LOG_ERR, "unrecognized option [%s]",*argv);
+	    if (strncmp(*argv, "prefix=", 7) && strncmp(*argv, "count=", 6))
+		_log_err(LOG_ERR, "unrecognized option [%s]",*argv);
+	} else
+	if (j == UNIX_BIGCRYPT) {
+	    _log_err(LOG_ERR,
+		"bigcrypt shouldn't be used for new passwords", *argv);
 	} else {
 	    ctrl &= unix_args[j].mask;    /* for turning things off */
 	    ctrl |= unix_args[j].flag;    /* for turning things on  */
@@ -374,8 +379,8 @@
 	while (pwdb_end() == PWDB_SUCCESS);
 
 	/* reopen stdin as pipe */
-	close(fds[1]);
-	dup2(fds[0], STDIN_FILENO);
+	if (close(fds[1])) exit(1);
+	if (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO) exit(1);
 
 	/* exec binary helper */
 	args[0] = x_strdup(CHKPWD_HELPER);
@@ -385,20 +390,26 @@
 
 	/* should not get here: exit with error */
 	D(("helper binary is not available"));
-	exit(PWDB_SUCCESS+1);
+	exit(1);
     } else if (child > 0) {
 	/* wait for child */
+	int fail = 0, status;
 	if (passwd != NULL) {            /* send the password to the child */
-	    write(fds[1], passwd, strlen(passwd)+1);
+	    if (write(fds[1], passwd, strlen(passwd) + 1) != strlen(passwd) + 1)
+		fail = 1;
 	    passwd = NULL;
 	} else {
-	    write(fds[1], "", 1);                        /* blank password */
+	    /* blank password */
+	    if (write(fds[1], "", 1) != 1)
+		fail = 1;
 	}
 	close(fds[0]);   /* we close this after the write because we want
 			    to avoid a possible SIGPIPE. */
 	close(fds[1]);
-	(void) waitpid(child, &retval, 0);  /* wait for helper to complete */
-	retval = (retval == PWDB_SUCCESS) ? PAM_SUCCESS:PAM_AUTH_ERR;
+	(void) waitpid(child, &status, 0); /* wait for helper to complete */
+	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
+	    fail = 1;
+	retval = fail ? PAM_AUTH_ERR : PAM_SUCCESS;
     } else {
 	D(("fork failed"));
 	retval = PAM_AUTH_ERR;
@@ -411,11 +422,14 @@
     return retval;
 }
 
+#include <pwd.h>
+
 static int _unix_verify_password(pam_handle_t *pamh, const char *name,
 				 const char *p, unsigned int ctrl)
 {
     const struct pwdb *pw=NULL;
     const struct pwdb_entry *pwe=NULL;
+    const struct passwd *libc_pw;
 
     const char *salt;
     char *pp = NULL;
@@ -475,7 +489,9 @@
 
     retval = pwdb_get_entry(pw, "passwd", &pwe);
     if (retval != PWDB_SUCCESS) {
-	if (geteuid()) {
+	if ((libc_pw = getpwnam(name)))
+		memset(libc_pw->pw_passwd, 0, strlen(libc_pw->pw_passwd));
+	if (libc_pw && geteuid() != 0 && getuid() == libc_pw->pw_uid) {
 	    /* we are not root perhaps this is the reason? Run helper */
 	    D(("running helper binary"));
 	    retval = pwdb_run_helper_binary(pamh, p, name);
@@ -535,6 +551,7 @@
 	    if ( pp != NULL && strcmp( pp, salt ) == 0 ) {
 		verify_result = PAM_SUCCESS;
 	    } else {
+#if 0
 		_pam_delete(pp);
 		D(("did not match"));
 		pp = _pam_md_compat(p, salt);
@@ -542,8 +559,11 @@
 		if ( pp != NULL && strcmp( pp, salt ) == 0 ) {
 		    verify_result = PAM_SUCCESS;
 		} else {
+#endif
 		    verify_result = PAM_AUTH_ERR;
+#if 0
 		}
+#endif
 	    }
 	    D(("verify result is %s", pam_strerror(pamh, verify_result)));
 	    p = NULL; /* no longer needed here */

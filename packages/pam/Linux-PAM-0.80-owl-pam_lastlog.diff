Bug and reliability fixes (but the module is still dirty).
Enable logging to wtmp by default.
New option "nowtmp" to disable logging to wtmp when the program does that.

diff -upk.orig Linux-PAM-0.80.orig/modules/pam_lastlog/pam_lastlog.c Linux-PAM-0.80/modules/pam_lastlog/pam_lastlog.c
--- Linux-PAM-0.80.orig/modules/pam_lastlog/pam_lastlog.c	2005-08-03 15:14:40 +0000
+++ Linux-PAM-0.80/modules/pam_lastlog/pam_lastlog.c	2005-08-03 15:15:05 +0000
@@ -102,10 +102,11 @@ static void _log_err(int err, const char
 #define LASTLOG_NEVER      010  /* display a welcome message for first login */
 #define LASTLOG_DEBUG      020  /* send info to syslog(3) */
 #define LASTLOG_QUIET      040  /* keep quiet about things */
+#define LASTLOG_WTMP      0100  /* log to wtmp as well as lastlog */
 
 static int _pam_parse(int flags, int argc, const char **argv)
 {
-    int ctrl=(LASTLOG_DATE|LASTLOG_HOST|LASTLOG_LINE);
+    int ctrl=(LASTLOG_DATE|LASTLOG_HOST|LASTLOG_LINE|LASTLOG_WTMP);
 
     /* does the appliction require quiet? */
     if (flags & PAM_SILENT) {
@@ -120,15 +121,17 @@ static int _pam_parse(int flags, int arg
 	if (!strcmp(*argv,"debug")) {
 	    ctrl |= LASTLOG_DEBUG;
 	} else if (!strcmp(*argv,"nodate")) {
-	    ctrl |= ~LASTLOG_DATE;
+	    ctrl &= ~LASTLOG_DATE;
 	} else if (!strcmp(*argv,"noterm")) {
-	    ctrl |= ~LASTLOG_LINE;
+	    ctrl &= ~LASTLOG_LINE;
 	} else if (!strcmp(*argv,"nohost")) {
-	    ctrl |= ~LASTLOG_HOST;
+	    ctrl &= ~LASTLOG_HOST;
 	} else if (!strcmp(*argv,"silent")) {
 	    ctrl |= LASTLOG_QUIET;
 	} else if (!strcmp(*argv,"never")) {
 	    ctrl |= LASTLOG_NEVER;
+	} else if (!strcmp(*argv,"nowtmp")) {
+	    ctrl &= ~LASTLOG_WTMP;
 	} else {
 	    _log_err(LOG_ERR,"unknown option; %s",*argv);
 	}
@@ -207,7 +210,8 @@ static int make_remark(pam_handle_t *pam
  * Values for the announce flags..
  */
 
-static int last_login_date(pam_handle_t *pamh, int announce, uid_t uid)
+static int last_login_date(pam_handle_t *pamh, int announce, uid_t uid,
+			   const char *user)
 {
     struct flock last_lock;
     struct lastlog last_login;
@@ -221,12 +225,12 @@ static int last_login_date(pam_handle_t 
 	if (announce & LASTLOG_DEBUG) {
 	    _log_err(LOG_DEBUG, "unable to open %s file", _PATH_LASTLOG);
 	}
-	retval = PAM_PERM_DENIED;
+	retval = PAM_SYSTEM_ERR;
     } else {
-	int win;
+	int win, err;
 
 	/* read the lastlogin file - for this uid */
-	(void) lseek(last_fd, sizeof(last_login) * (off_t) uid, SEEK_SET);
+	err = lseek(last_fd, sizeof(last_login) * (off_t) uid, SEEK_SET) < 0;
 
 	memset(&last_lock, 0, sizeof(last_lock));
 	last_lock.l_type = F_RDLCK;
@@ -240,13 +244,13 @@ static int last_login_date(pam_handle_t 
 	    sleep(LASTLOG_IGNORE_LOCK_TIME);
 	}
 
-	win = (_pammodutil_read (last_fd, (char *) &last_login,
-				 sizeof(last_login)) == sizeof(last_login));
+	win = _pammodutil_read (last_fd, (char *) &last_login,
+				sizeof(last_login));
 
 	last_lock.l_type = F_UNLCK;
 	(void) fcntl(last_fd, F_SETLK, &last_lock);        /* unlock */
 
-	if (!win) {
+	if (!err && !win) {
 	    D(("First login for user uid=%d", _PATH_LASTLOG, uid));
 	    if (announce & LASTLOG_DEBUG) {
 		_log_err(LOG_DEBUG, "creating lastlog for uid %d", uid);
@@ -254,10 +258,12 @@ static int last_login_date(pam_handle_t 
 	    memset(&last_login, 0, sizeof(last_login));
 	}
 
+	err |= win && win != sizeof(last_login);
+
 	/* rewind */
-	(void) lseek(last_fd, sizeof(last_login) * (off_t) uid, SEEK_SET);
+	err |= lseek(last_fd, sizeof(last_login) * (off_t) uid, SEEK_SET) < 0;
 
-	if (!(announce & LASTLOG_QUIET)) {
+	if (!err && !(announce & LASTLOG_QUIET)) {
 	    if (last_login.ll_time) {
 		time_t ll_time;
 		char *the_time;
@@ -267,7 +273,8 @@ static int last_login_date(pam_handle_t 
 		the_time = ctime(&ll_time);
 		the_time[-1+strlen(the_time)] = '\0';    /* delete '\n' */
 
-		remark = malloc(LASTLOG_MAXSIZE);
+		/* add a safety margin; this module is crappy either way */
+		remark = malloc(LASTLOG_MAXSIZE + 0x1000);
 		if (remark == NULL) {
 		    D(("no memory for last login remark"));
 		    retval = PAM_BUF_ERR;
@@ -318,7 +325,8 @@ static int last_login_date(pam_handle_t 
 	    } else if ((!last_login.ll_time) && (announce & LASTLOG_NEVER)) {
 		D(("this is the first time this user has logged in"));
 		retval = make_remark(pamh, announce, LASTLOG_NEVER_WELCOME);
-	    }
+	    } else
+		retval = PAM_SUCCESS;
 	} else {
 	    D(("no text was requested"));
 	    retval = PAM_SUCCESS;
@@ -327,8 +335,9 @@ static int last_login_date(pam_handle_t 
 	/* write latest value */
 	{
 	    time_t ll_time;
-	    const void *remote_host=NULL
-		, *void_terminal_line=DEFAULT_TERM;
+	    const void *void_remote_host=NULL;
+	    const void *void_terminal_line=DEFAULT_TERM;
+	    const char *remote_host;
 	    const char *terminal_line;
 
 	    /* set this login date */
@@ -338,7 +347,8 @@ static int last_login_date(pam_handle_t 
             last_login.ll_time = ll_time;
 
 	    /* set the remote host */
-	    (void) pam_get_item(pamh, PAM_RHOST, &remote_host);
+	    (void) pam_get_item(pamh, PAM_RHOST, &void_remote_host);
+	    remote_host = void_remote_host;
 	    if (remote_host == NULL) {
 		remote_host = DEFAULT_HOST;
 	    }
@@ -347,7 +357,6 @@ static int last_login_date(pam_handle_t 
 	    strncpy(last_login.ll_host, remote_host,
 		    sizeof(last_login.ll_host));
 	    last_login.ll_host[sizeof(last_login.ll_host) - 1] = '\0';
-	    remote_host = NULL;
 
 	    /* set the terminal line */
 	    (void) pam_get_item(pamh, PAM_TTY, &void_terminal_line);
@@ -383,16 +392,27 @@ static int last_login_date(pam_handle_t 
 	    }
 
 	    D(("writing to the last_log file"));
-	    _pammodutil_write (last_fd, (char *) &last_login,
-			        sizeof (last_login));
+	    if (!err)
+		err |= _pammodutil_write (last_fd, (char *) &last_login,
+			   sizeof (last_login)) != sizeof(last_login);
 
 	    last_lock.l_type = F_UNLCK;
 	    (void) fcntl(last_fd, F_SETLK, &last_lock);        /* unlock */
 	    D(("unlocked"));
 
 	    close(last_fd);                                  /* all done */
+
+	    if (announce & LASTLOG_WTMP) {
+		/* write wtmp entry for user */
+		logwtmp(last_login.ll_line, user, remote_host);
+	    }
+	    terminal_line = NULL;
+	    remote_host = NULL;
 	}
 	D(("all done with last login"));
+
+	if (err && retval == PAM_SUCCESS)
+	    retval = PAM_SYSTEM_ERR;
     }
 
     /* reset the last login structure */
@@ -432,14 +452,14 @@ int pam_sm_open_session(pam_handle_t *pa
     pwd = _pammodutil_getpwnam (pamh, user);
     if (pwd == NULL) {
 	D(("couldn't identify user %s", user));
-	return PAM_CRED_INSUFFICIENT;
+	return PAM_USER_UNKNOWN;
     }
     uid = pwd->pw_uid;
     pwd = NULL;                                         /* tidy up */
 
     /* process the current login attempt (indicate last) */
 
-    retval = last_login_date(pamh, ctrl, uid);
+    retval = last_login_date(pamh, ctrl, uid, user);
 
     /* indicate success or failure */
 
@@ -452,6 +472,26 @@ PAM_EXTERN
 int pam_sm_close_session(pam_handle_t *pamh,int flags,int argc
 			 ,const char **argv)
 {
+    const void *void_terminal_line = NULL;
+    const char *terminal_line;
+
+    if (!(_pam_parse(flags, argc, argv) & LASTLOG_WTMP))
+	return PAM_SUCCESS;
+
+    pam_get_item(pamh, PAM_TTY, &void_terminal_line);
+    terminal_line = void_terminal_line;
+
+    D(("terminal = %s", terminal_line));
+
+    if (terminal_line == NULL) {
+	terminal_line = DEFAULT_TERM;
+    } else if ( !strncmp("/dev/", terminal_line, 5) ) {
+	/* strip leading "/dev/" from tty */
+	terminal_line += 5;
+    }
+    /* Wipe out utmp logout entry */
+    logwtmp(terminal_line, "", "");
+
     return PAM_SUCCESS;
 }
 

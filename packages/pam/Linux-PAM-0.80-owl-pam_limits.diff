Support stacking for account management (as well as for session setup).
Be fail-close on configuration file reads.
Report the "too many logins" via PAM conversation rather than direct printf(3).

diff -upk.orig Linux-PAM-0.80.orig/modules/pam_limits/pam_limits.c Linux-PAM-0.80/modules/pam_limits/pam_limits.c
--- Linux-PAM-0.80.orig/modules/pam_limits/pam_limits.c	2005-08-03 15:17:19 +0000
+++ Linux-PAM-0.80/modules/pam_limits/pam_limits.c	2005-08-03 15:17:43 +0000
@@ -94,6 +94,52 @@ struct pam_limit_s {
 #include <security/_pam_macros.h>
 #include <security/_pam_modutil.h>
 
+/* A generic interface to sending messages, originally from pam_passwdqc */
+static int converse(pam_handle_t *pamh, int style, const char *text,
+    struct pam_response **resp)
+{
+	const void *void_conv = NULL;
+	const struct pam_conv *conv;
+	struct pam_message msg, *pmsg;
+	int status;
+
+	status = pam_get_item(pamh, PAM_CONV, &void_conv);
+	conv = void_conv;
+	if (status != PAM_SUCCESS)
+		return status;
+
+	pmsg = &msg;
+	msg.msg_style = style;
+	msg.msg = text;
+
+	*resp = NULL;
+	return conv->conv(1, (const struct pam_message **)&pmsg, resp,
+	    conv->appdata_ptr);
+}
+
+static int say(pam_handle_t *pamh, int style, const char *format, ...)
+{
+	va_list args;
+	char buffer[0x800];
+	int needed;
+	struct pam_response *resp;
+	int status;
+
+	va_start(args, format);
+	needed = vsnprintf(buffer, sizeof(buffer), format, args);
+	va_end(args);
+
+	if ((unsigned int)needed < sizeof(buffer)) {
+		status = converse(pamh, style, buffer, &resp);
+		_pam_overwrite(buffer);
+	} else {
+		status = PAM_ABORT;
+		memset(buffer, 0, sizeof(buffer));
+	}
+
+	return status;
+}
+
 /* logging */
 static void _pam_log(int err, const char *format, ...)
 {
@@ -265,7 +311,7 @@ static void process_limit(int source, co
     int limit_item;
     int limit_type = 0;
     int int_value = 0;
-    unsigned long rlimit_value = 0;
+    rlim_t rlimit_value = 0;
     char *endptr;
     const char *value_orig = lim_value;
 
@@ -449,8 +495,8 @@ static int parse_config_file(pam_handle_
         _pam_log(LOG_DEBUG,"reading settings from '%s'", CONF_FILE);
     fil = fopen(CONF_FILE, "r");
     if (fil == NULL) {
-        _pam_log (LOG_WARNING, "can not read settings from %s", CONF_FILE);
-        return PAM_SERVICE_ERR;
+        _pam_log (LOG_WARNING, "cannot read settings from %s", CONF_FILE);
+        return PAM_ABORT;
     }
 #undef CONF_FILE
 
@@ -572,12 +618,17 @@ static int setup_limits(pam_handle_t *pa
     }
 
     for (i=0, status=LIMITED_OK; i<RLIM_NLIMITS; i++) {
-        if (pl->limits[i].limit.rlim_cur > pl->limits[i].limit.rlim_max)
-            pl->limits[i].limit.rlim_cur = pl->limits[i].limit.rlim_max;
 	if (!pl->supported[i]) {
 	    /* skip it if its not known to the system */
 	    continue;
 	}
+	if (pl->limits[i].src_soft == LIMITS_DEF_NONE &&
+	    pl->limits[i].src_hard == LIMITS_DEF_NONE) {
+	    /* skip it if its not initialized */
+	    continue;
+	}
+        if (pl->limits[i].limit.rlim_cur > pl->limits[i].limit.rlim_max)
+            pl->limits[i].limit.rlim_cur = pl->limits[i].limit.rlim_max;
 	status |= setrlimit(i, &pl->limits[i].limit);
     }
 
@@ -635,7 +686,7 @@ PAM_EXTERN int pam_sm_open_session(pam_h
     retval = init_limits(&pl);
     if (retval != PAM_SUCCESS) {
         _pam_log(LOG_WARNING, "cannot initialize");
-        return PAM_IGNORE;
+        return PAM_ABORT;
     }
 
     retval = parse_config_file(pamh, pwd->pw_name, ctrl, &pl);
@@ -645,13 +696,15 @@ PAM_EXTERN int pam_sm_open_session(pam_h
     }
     if (retval != PAM_SUCCESS) {
         _pam_log(LOG_WARNING, "error parsing the configuration file");
-        return PAM_IGNORE;
+        return retval;
     }
 
     if (ctrl & PAM_DO_SETREUID) {
 	setreuid(pwd->pw_uid, -1);
     }
     retval = setup_limits(pamh, pwd->pw_name, pwd->pw_uid, ctrl, &pl);
+    if (retval & LOGIN_ERR)
+	say(pamh, PAM_ERROR_MSG, "Too many logins for '%s'.", pwd->pw_name);
     if (retval != LIMITED_OK) {
         return PAM_PERM_DENIED;
     }
@@ -667,14 +720,24 @@ PAM_EXTERN int pam_sm_close_session(pam_
 }
 
 #ifdef PAM_STATIC
+#define pam_sm_acct_mgmt pam_sm_open_session
+#elif defined(__linux__) && defined(__ELF__)
+__asm__(".globl pam_sm_acct_mgmt; pam_sm_acct_mgmt = pam_sm_open_session");
+#else
+PAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags,
+	int argc, const char **argv)
+{
+	return pam_sm_open_session(pamh, flags, argc, argv);
+}
+#endif
 
+#ifdef PAM_STATIC
 /* static module data */
-
 struct pam_module _pam_limits_modstruct = {
      "pam_limits",
      NULL,
      NULL,
-     NULL,
+     pam_sm_acct_mgmt,
      pam_sm_open_session,
      pam_sm_close_session,
      NULL

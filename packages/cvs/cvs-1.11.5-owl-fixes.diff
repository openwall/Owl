diff -ur cvs-1.11.5.orig/diff/diff.c cvs-1.11.5/diff/diff.c
--- cvs-1.11.5.orig/diff/diff.c	Sun Apr 28 23:09:50 2002
+++ cvs-1.11.5/diff/diff.c	Mon Apr 28 23:04:25 2003
@@ -248,6 +248,15 @@
   int optind_old;
   int opened_file = 0;
 
+  /* This actually makes a difference for optind_old and opened_file,
+   * the rest are just to avoid possible compiler warnings. */
+  (void) &c;
+  (void) &prev;
+  (void) &width;
+  (void) &show_c_function;
+  (void) &optind_old;
+  (void) &opened_file;
+
   callbacks = callbacks_arg;
 
   /* Do our initializations.  */
diff -ur cvs-1.11.5.orig/diff/diff3.c cvs-1.11.5/diff/diff3.c
--- cvs-1.11.5.orig/diff/diff3.c	Tue Aug  7 15:35:52 2001
+++ cvs-1.11.5/diff/diff3.c	Mon Apr 28 23:15:00 2003
@@ -209,7 +209,11 @@
 static struct diff3_block *using_to_diff3_block PARAMS((struct diff_block *[2], struct diff_block *[2], int, int, struct diff3_block const *));
 static struct diff_block *process_diff PARAMS((char const *, char const *, struct diff_block **, char **));
 static void check_output PARAMS((FILE *));
-static void diff3_fatal PARAMS((char const *));
+static void diff3_fatal PARAMS((char const *))
+#ifdef __GNUC__
+__attribute__ ((noreturn))
+#endif
+	;
 static void output_diff3 PARAMS((struct diff3_block *, int const[3], int const[3]));
 static void diff3_perror_with_exit PARAMS((char const *));
 static int try_help PARAMS((char const *));
@@ -273,6 +277,10 @@
   int optind_old;
   int opened_file = 0;
 
+  /* Here we don't care if this or another variable is clobbered by the
+   * setjmp()/longjmp(), so this is just to avoid a warning with gcc. */
+  (void) &opened_file;
+
   callbacks = callbacks_arg;
 
   initialize_main (&argc, &argv);
@@ -1447,6 +1455,10 @@
   static int skew_increment[3] = { 2, 3, 1 }; /* 0==>2==>1==>3 */
   char const *line_prefix = tab_align_flag ? "\t" : "  ";
 
+  /* never used */
+  oddoneout = 0;
+  dontprint = 0;
+
   for (ptr = diff; ptr; ptr = D_NEXT (ptr))
     {
       char x[2];
@@ -1555,10 +1567,12 @@
 {
   write_output (".\n", 2);
   if (leading_dot)
-    if (num == 1)
-      printf_output ("%ds/^\\.//\n", start);
-    else
-      printf_output ("%d,%ds/^\\.//\n", start, start + num - 1);
+    {
+      if (num == 1)
+	printf_output ("%ds/^\\.//\n", start);
+      else
+	printf_output ("%d,%ds/^\\.//\n", start, start + num - 1);
+    }
 }
 
 /*
@@ -1750,10 +1764,12 @@
 	  {
 	    c = getc (infile);
 	    if (c == EOF)
-	      if (ferror (infile))
-		diff3_perror_with_exit ("input file");
-	      else if (feof (infile))
-		diff3_fatal ("input file shrank");
+	      {
+		if (ferror (infile))
+		  diff3_perror_with_exit ("input file");
+		else if (feof (infile))
+		  diff3_fatal ("input file shrank");
+	      }
 	    cc = c;
 	    write_output (&cc, 1);
 	  }
@@ -1804,14 +1820,16 @@
       while (0 <= --i)
 	while ((c = getc (infile)) != '\n')
 	  if (c == EOF)
-	    if (ferror (infile))
-	      diff3_perror_with_exit ("input file");
-	    else if (feof (infile))
-	      {
-		if (i || b->next)
-		  diff3_fatal ("input file shrank");
-		return conflicts_found;
-	      }
+	    {
+	      if (ferror (infile))
+		diff3_perror_with_exit ("input file");
+	      else if (feof (infile))
+		{
+		  if (i || b->next)
+		    diff3_fatal ("input file shrank");
+		  return conflicts_found;
+		}
+	    }
     }
   /* Copy rest of common file.  */
   while ((c = getc (infile)) != EOF || !(ferror (infile) | feof (infile)))
diff -ur cvs-1.11.5.orig/diff/side.c cvs-1.11.5/diff/side.c
--- cvs-1.11.5.orig/diff/side.c	Thu Jun 18 16:57:14 1998
+++ cvs-1.11.5/diff/side.c	Mon Apr 28 23:17:01 2003
@@ -123,16 +123,18 @@
 
 	case '\b':
 	  if (in_position != 0 && --in_position < out_bound)
-	    if (out_position <= in_position)
-	      /* Add spaces to make up for suppressed tab past out_bound.  */
-	      for (;  out_position < in_position;  out_position++)
-		write_output (" ", 1);
-	    else
-	      {
-		out_position = in_position;
-		cc = c;
-		write_output (&cc, 1);
-	      }
+	    {
+	      if (out_position <= in_position)
+		/* Add spaces to make up for suppressed tab past out_bound.  */
+		for (;  out_position < in_position;  out_position++)
+		  write_output (" ", 1);
+	      else
+		{
+		  out_position = in_position;
+		  cc = c;
+		  write_output (&cc, 1);
+		}
+	    }
 	  break;
 
 	case '\f':
diff -ur cvs-1.11.5.orig/lib/regex.c cvs-1.11.5/lib/regex.c
--- cvs-1.11.5.orig/lib/regex.c	Fri Sep 20 02:48:59 2002
+++ cvs-1.11.5/lib/regex.c	Tue Apr 29 00:02:55 2003
@@ -262,6 +262,7 @@
 #ifdef REGEX_MALLOC
 
 #define REGEX_ALLOCATE malloc
+#define REGEX_REALLOCATE_DECLARE_destination /* nothing */
 #define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
 #define REGEX_FREE free
 
@@ -289,6 +290,9 @@
 
 #define REGEX_ALLOCATE alloca
 
+#define REGEX_REALLOCATE_DECLARE_destination \
+  char *destination;
+
 /* Assumes a `char *destination' variable.  */
 #define REGEX_REALLOCATE(source, osize, nsize)				\
   (destination = (char *) alloca (nsize),				\
@@ -1286,7 +1290,7 @@
 
 #define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
   do {									\
-    char *destination;							\
+    REGEX_REALLOCATE_DECLARE_destination				\
     /* Must be int, so when we don't save any registers, the arithmetic	\
        of 0 + -1 isn't done as unsigned.  */				\
     int this_reg;							\
@@ -2351,7 +2355,9 @@
 			   Split that into two ranges,,
 			   the low one ending at 0237, and the high one
 			   starting at ...040.  */
+#if 0
 			int c1_base = (c1 & ~0177) | 040;
+#endif
 			SET_RANGE_TABLE_WORK_AREA (range_table_work, c, c1);
 			c1 = 0237;
 		      }
@@ -2514,10 +2520,12 @@
 	      if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
 
 	      if (COMPILE_STACK_EMPTY)
-		if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
-		  goto normal_backslash;
-		else
-		  FREE_STACK_RETURN (REG_ERPAREN);
+		{
+		  if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
+		    goto normal_backslash;
+		  else
+		    FREE_STACK_RETURN (REG_ERPAREN);
+		}
 
 	    handle_close:
 	      if (fixup_alt_jump)
@@ -2534,10 +2542,12 @@
 
 	      /* See similar code for backslashed left paren above.  */
 	      if (COMPILE_STACK_EMPTY)
-		if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
-		  goto normal_char;
-		else
-		  FREE_STACK_RETURN (REG_ERPAREN);
+		{
+		  if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
+		    goto normal_char;
+		  else
+		    FREE_STACK_RETURN (REG_ERPAREN);
+		}
 
 	      /* Since we just checked for an empty stack above, this
 		 ``can't happen''.  */
@@ -3172,15 +3182,13 @@
 re_compile_fastmap (bufp)
      struct re_pattern_buffer *bufp;
 {
-  int i, j, k;
+  int j, k;
 #ifdef MATCH_MAY_ALLOCATE
   fail_stack_type fail_stack;
 #endif
 #ifndef REGEX_MALLOC
   char *destination;
 #endif
-  /* We don't push any register information onto the failure stack.  */
-  unsigned num_regs = 0;
 
   register char *fastmap = bufp->fastmap;
   unsigned char *pattern = bufp->buffer;
@@ -3188,9 +3196,11 @@
   unsigned char *p = pattern;
   register unsigned char *pend = pattern + size;
 
+#if defined (REL_ALLOC) && defined (REGEX_MALLOC)
   /* This holds the pointer to the failure stack, when
      it is allocated relocatably.  */
   fail_stack_elt_t *failure_stack_ptr;
+#endif
 
   /* Assume that each path through the pattern can be null until
      proven otherwise.	We set this false at the bottom of switch
@@ -3841,9 +3851,11 @@
 	    }
 	  else				/* Searching backwards.	 */
 	    {
+#ifdef emacs
 	      int room = (size1 == 0 || startpos >= size1
 			  ? size2 + size1 - startpos
 			  : size1 - startpos);
+#endif
 
 	      buf_ch = STRING_CHAR (d, room);
 	      if (RE_TRANSLATE_P (translate))
@@ -3882,10 +3894,12 @@
 	  /* Update STARTPOS to the next character boundary.  */
 	  if (multibyte)
 	    {
+#ifdef emacs
 	      const unsigned char *p
 		= (const unsigned char *) POS_ADDR_VSTRING (startpos);
 	      const unsigned char *pend
 		= (const unsigned char *) STOP_ADDR_VSTRING (startpos);
+#endif
 	      int len = MULTIBYTE_FORM_LENGTH (p, pend - p);
 
 	      range -= len;
@@ -4156,9 +4170,11 @@
   unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
 #endif
 
+#if defined (REL_ALLOC) && defined (REGEX_MALLOC)
   /* This holds the pointer to the failure stack, when
      it is allocated relocatably.  */
   fail_stack_elt_t *failure_stack_ptr;
+#endif
 
   /* We fill all the registers internally, independent of what we
      return, for use in backreferences.	 The number here includes
@@ -5388,8 +5404,10 @@
 	      /* C1 is the character before D, S1 is the syntax of C1, C2
 		 is the character at D, and S2 is the syntax of C2.  */
 	      int c1, c2, s1, s2;
+#ifdef emacs
 	      int pos1 = PTR_TO_OFFSET (d - 1);
 	      int charpos;
+#endif
 
 	      GET_CHAR_BEFORE_2 (c1, d, string1, end1, string2, end2);
 	      GET_CHAR_AFTER_2 (c2, d, string1, end1, string2, end2);
@@ -5425,8 +5443,10 @@
 	      /* C1 is the character before D, S1 is the syntax of C1, C2
 		 is the character at D, and S2 is the syntax of C2.  */
 	      int c1, c2, s1, s2;
+#ifdef emacs
 	      int pos1 = PTR_TO_OFFSET (d - 1);
 	      int charpos;
+#endif
 
 	      GET_CHAR_BEFORE_2 (c1, d, string1, end1, string2, end2);
 	      GET_CHAR_AFTER_2 (c2, d, string1, end1, string2, end2);
@@ -5462,8 +5482,10 @@
 	      /* C1 is the character before D, S1 is the syntax of C1, C2
 		 is the character at D, and S2 is the syntax of C2.  */
 	      int c1, c2, s1, s2;
+#ifdef emacs
 	      int pos1 = PTR_TO_OFFSET (d);
 	      int charpos;
+#endif
 
 	      GET_CHAR_AFTER_2 (c2, d, string1, end1, string2, end2);
 #ifdef emacs
@@ -5506,8 +5528,10 @@
 	      /* C1 is the character before D, S1 is the syntax of C1, C2
 		 is the character at D, and S2 is the syntax of C2.  */
 	      int c1, c2, s1, s2;
+#ifdef emacs
 	      int pos1 = PTR_TO_OFFSET (d);
 	      int charpos;
+#endif
 
 	      GET_CHAR_BEFORE_2 (c1, d, string1, end1, string2, end2);
 #ifdef emacs
diff -ur cvs-1.11.5.orig/src/add.c cvs-1.11.5/src/add.c
--- cvs-1.11.5.orig/src/add.c	Thu Oct 24 18:38:36 2002
+++ cvs-1.11.5/src/add.c	Mon Apr 28 23:20:07 2003
@@ -295,6 +295,7 @@
 #endif
 
 	memset (&finfo, 0, sizeof finfo);
+	found_name = NULL;
 
 	if (save_cwd (&cwd))
 	    error_exit ();
diff -ur cvs-1.11.5.orig/src/buffer.c cvs-1.11.5/src/buffer.c
--- cvs-1.11.5.orig/src/buffer.c	Fri Dec  6 19:47:58 2002
+++ cvs-1.11.5/src/buffer.c	Mon Apr 28 23:22:15 2003
@@ -1809,6 +1809,8 @@
     char *outbuf;
     int size, status, translated;
 
+    outdata = NULL; /* never used */
+
     if (have > BUFFER_DATA_SIZE)
     {
 	/* It would be easy to xmalloc a buffer, but I don't think this
diff -ur cvs-1.11.5.orig/src/client.c cvs-1.11.5/src/client.c
--- cvs-1.11.5.orig/src/client.c	Thu Jan 16 15:10:55 2003
+++ cvs-1.11.5/src/client.c	Mon Apr 28 23:24:39 2003
@@ -3953,6 +3953,8 @@
     char *username;			/* the username we use to connect */
     char no_passwd = 0;			/* gets set if no password found */
 
+    username = "NONE";
+
     /* FIXME!!!!!!!!!!!!!!!!!!
      *
      * THIS IS REALLY UGLY!
diff -ur cvs-1.11.5.orig/src/lock.c cvs-1.11.5/src/lock.c
--- cvs-1.11.5.orig/src/lock.c	Sat Dec 28 18:01:30 2002
+++ cvs-1.11.5/src/lock.c	Mon Apr 28 23:29:13 2003
@@ -155,8 +155,7 @@
     char *p;
     char *q;
     char *short_repos;
-    mode_t save_umask;
-    int saved_umask = 0;
+    int saved_umask = -1;
 
     if (lock_dir == NULL)
     {
@@ -229,8 +228,7 @@
 	if (CVS_STAT (lock_dir, &sb) < 0)
 	    error (1, errno, "cannot stat %s", lock_dir);
 	new_mode = sb.st_mode;
-	save_umask = umask (0000);
-	saved_umask = 1;
+	saved_umask = umask (0002);
 
 	p = short_repos;
 	while (1)
@@ -270,11 +268,8 @@
 	strcat (retval, "/");
 	strcat (retval, name);
 
-	if (saved_umask)
-	{
-	    assert (umask (save_umask) == 0000);
-	    saved_umask = 0;
-	}
+	if (saved_umask >= 0)
+	    assert (umask (saved_umask) == 0002);
     }
     return retval;
 }
diff -ur cvs-1.11.5.orig/src/login.c cvs-1.11.5/src/login.c
--- cvs-1.11.5.orig/src/login.c	Mon Jun 17 23:39:00 2002
+++ cvs-1.11.5/src/login.c	Mon Apr 28 23:32:32 2003
@@ -291,7 +291,7 @@
     char *cvsroot_canonical = NULL;
     char *password = NULL;
     int line_length;
-    long line;
+    long line = 0;
     char *linebuf = NULL;
     size_t linebuf_len;
     char *p;
diff -ur cvs-1.11.5.orig/src/modules.c cvs-1.11.5/src/modules.c
--- cvs-1.11.5.orig/src/modules.c	Thu Jun 21 21:23:09 2001
+++ cvs-1.11.5/src/modules.c	Mon Apr 28 23:33:25 2003
@@ -121,7 +121,7 @@
     char *line;
     int modargc;
     int xmodargc;
-    char **modargv;
+    char **modargv = NULL;
     char **xmodargv = NULL;
     /* Found entry from modules file, including options and such.  */
     char *value = NULL;
diff -ur cvs-1.11.5.orig/src/patch.c cvs-1.11.5/src/patch.c
--- cvs-1.11.5.orig/src/patch.c	Sat Dec 28 18:01:30 2002
+++ cvs-1.11.5/src/patch.c	Mon Apr 28 23:34:50 2003
@@ -373,7 +373,7 @@
     struct file_info *finfo;
 {
     struct utimbuf t;
-    char *vers_tag, *vers_head;
+    char *vers_tag = NULL, *vers_head = NULL;
     char *rcs = NULL;
     RCSNode *rcsfile;
     FILE *fp1, *fp2, *fp3;
diff -ur cvs-1.11.5.orig/src/rcs.c cvs-1.11.5/src/rcs.c
--- cvs-1.11.5.orig/src/rcs.c	Thu Jan 16 15:10:55 2003
+++ cvs-1.11.5/src/rcs.c	Mon Apr 28 23:35:59 2003
@@ -4073,7 +4073,7 @@
 {
     int free_rev = 0;
     enum kflag expand;
-    FILE *fp, *ofp;
+    FILE *fp, *ofp = NULL;
     struct stat sb;
     struct rcsbuffer rcsbuf;
     char *key;
diff -ur cvs-1.11.5.orig/src/run.c cvs-1.11.5/src/run.c
--- cvs-1.11.5.orig/src/run.c	Tue Aug  6 22:03:23 2002
+++ cvs-1.11.5/src/run.c	Tue Apr 29 00:06:28 2003
@@ -119,6 +119,14 @@
 #endif
 #endif
 
+    /* Avoid warnings about vfork() possibly clobbering these.  In reality,
+     * they aren't modified by the child and thus can't be clobbered.  */
+    (void) &shin;
+    (void) &shout;
+    (void) &sherr;
+    (void) &rc;
+    (void) &rerrno;
+
     if (trace)
     {
 #ifdef SERVER_SUPPORT

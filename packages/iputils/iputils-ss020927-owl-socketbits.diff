--- iputils/include-glibc/socketbits.h.orig	Wed Feb 27 21:34:18 2002
+++ iputils/include-glibc/socketbits.h	Fri Oct 17 00:21:37 2003
@@ -1,5 +1,5 @@
 /* System-specific socket constants and types.  Linux version.
-   Copyright (C) 1991, 92, 94, 95, 96, 97, 98 Free Software Foundation, Inc.
+   Copyright (C) 1991,92,94,95,96,97,98,99 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,42 +17,32 @@
    write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.  */
 
-#ifndef	_SOCKETBITS_H
+#ifndef __BITS_SOCKET_H
+#define __BITS_SOCKET_H
 
-#define	_SOCKETBITS_H	1
-#include <features.h>
+#if !defined _SYS_SOCKET_H && !defined _NETINET_IN_H
+# error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
+#endif
 
 #define	__need_size_t
 #define __need_NULL
 #include <stddef.h>
 
-
-__BEGIN_DECLS
+#include <limits.h>
+#include <sys/types.h>
 
 /* Type for length arguments in socket calls.  */
-#ifndef __socklen_t_defined
 typedef unsigned int socklen_t;
-# define __socklen_t_defined
-#endif
 
 /* Types of sockets.  */
 enum __socket_type
 {
-#ifndef __mips__
   SOCK_STREAM = 1,		/* Sequenced, reliable, connection-based
 				   byte streams.  */
 #define SOCK_STREAM SOCK_STREAM
   SOCK_DGRAM = 2,		/* Connectionless, unreliable datagrams
 				   of fixed maximum length.  */
 #define SOCK_DGRAM SOCK_DGRAM
-#else
-  SOCK_STREAM = 2,		/* Sequenced, reliable, connection-based
-				   byte streams.  */
-#define SOCK_STREAM SOCK_STREAM
-  SOCK_DGRAM = 1,		/* Connectionless, unreliable datagrams
-				   of fixed maximum length.  */
-#define SOCK_DGRAM SOCK_DGRAM
-#endif
   SOCK_RAW = 3,			/* Raw protocol interface.  */
 #define SOCK_RAW SOCK_RAW
   SOCK_RDM = 4,			/* Reliably-delivered messages.  */
@@ -70,25 +60,30 @@
 #define	PF_UNSPEC	0	/* Unspecified.  */
 #define	PF_LOCAL	1	/* Local to host (pipes and file-domain).  */
 #define	PF_UNIX		PF_LOCAL /* Old BSD name for PF_LOCAL.  */
-#define	PF_FILE		PF_LOCAL /* POSIX name for PF_LOCAL.  */
+#define	PF_FILE		PF_LOCAL /* Another non-standard name for PF_LOCAL.  */
 #define	PF_INET		2	/* IP protocol family.  */
 #define	PF_AX25		3	/* Amateur Radio AX.25.  */
 #define	PF_IPX		4	/* Novell Internet Protocol.  */
-#define	PF_APPLETALK	5	/* Don't use this.  */
+#define	PF_APPLETALK	5	/* Appletalk DDP.  */
 #define	PF_NETROM	6	/* Amateur radio NetROM.  */
 #define	PF_BRIDGE	7	/* Multiprotocol bridge.  */
-#define	PF_AAL5		8	/* Reserved for Werner's ATM.  */
+#define	PF_ATMPVC	8	/* ATM PVCs.  */
 #define	PF_X25		9	/* Reserved for X.25 project.  */
 #define	PF_INET6	10	/* IP version 6.  */
-#define	PF_ROSE		11	/* Amateur Radio X.25 PLP       */
-#define	PF_DECnet	12	/* Reserved for DECnet project  */
-#define	PF_NETBEUI	13	/* Reserved for 802.2LLC project*/
-#define	PF_SECURITY	14	/* Security callback pseudo AF */
-#define	PF_KEY		15	/* PF_KEY key management API */
+#define	PF_ROSE		11	/* Amateur Radio X.25 PLP.  */
+#define	PF_DECnet	12	/* Reserved for DECnet project.  */
+#define	PF_NETBEUI	13	/* Reserved for 802.2LLC project.  */
+#define	PF_SECURITY	14	/* Security callback pseudo AF.  */
+#define	PF_KEY		15	/* PF_KEY key management API.  */
 #define	PF_NETLINK	16
-#define	PF_ROUTE	PF_NETLINK /* Alias to emulate 4.4BSD */
-#define	PF_PACKET	17	/* Packet family                */
-#define	PF_MAX		32	/* For now.. */
+#define	PF_ROUTE	PF_NETLINK /* Alias to emulate 4.4BSD.  */
+#define	PF_PACKET	17	/* Packet family.  */
+#define	PF_ASH		18	/* Ash.  */
+#define	PF_ECONET	19	/* Acorn Econet.  */
+#define	PF_ATMSVC	20	/* ATM SVCs.  */
+#define	PF_SNA		22	/* Linux SNA Project */
+#define PF_IRDA		23	/* IRDA sockets.  */
+#define	PF_MAX		32	/* For now..  */
 
 /* Address families.  */
 #define	AF_UNSPEC	PF_UNSPEC
@@ -101,42 +96,45 @@
 #define	AF_APPLETALK	PF_APPLETALK
 #define	AF_NETROM	PF_NETROM
 #define	AF_BRIDGE	PF_BRIDGE
-#define	AF_AAL5		PF_AAL5
+#define	AF_ATMPVC	PF_ATMPVC
 #define	AF_X25		PF_X25
 #define	AF_INET6	PF_INET6
 #define	AF_ROSE		PF_ROSE
 #define	AF_DECnet	PF_DECnet
 #define	AF_NETBEUI	PF_NETBEUI
 #define	AF_SECURITY	PF_SECURITY
-#define	pseudo_AF_KEY	pseudo_PF_KEY
+#define	AF_KEY		PF_KEY
 #define	AF_NETLINK	PF_NETLINK
 #define	AF_ROUTE	PF_ROUTE
 #define	AF_PACKET	PF_PACKET
+#define	AF_ASH		PF_ASH
+#define	AF_ECONET	PF_ECONET
+#define	AF_ATMSVC	PF_ATMSVC
+#define	AF_SNA		PF_SNA
+#define AF_IRDA		PF_IRDA
 #define	AF_MAX		PF_MAX
 
 /* Socket level values.  Others are defined in the appropriate headers.
 
    XXX These definitions also should go into the appropriate headers as
    far as they are available.  */
+
+/* Socket level values for IPv6.  */
 #define SOL_IPV6        41
-#define SOL_ICMPV6	58
+#define SOL_ICMPV6      58
 #define SOL_RAW		255
-#define SOL_AX25        257
-#define SOL_ATALK	258
-#define SOL_NETROM	259
-#define SOL_ROSE	260
-#define SOL_DECNET	261
-#define SOL_X25		262
+#define SOL_DECNET      261
+#define SOL_X25         262
+#define SOL_PACKET	263
+#define SOL_ATM		264	/* ATM layer (cell level).  */
+#define SOL_AAL		265	/* ATM Adaption Layer (packet level).  */
+#define SOL_IRDA	266
 
 /* Maximum queue length specifiable by listen.  */
 #define SOMAXCONN	128
 
 /* Get the definition of the macro to define the common sockaddr members.  */
-#if __GLIBC_MINOR__  >= 1
 #include <bits/sockaddr.h>
-#else
-#include <sockaddrcom.h>
-#endif
 
 /* Structure describing a generic socket address.  */
 struct sockaddr
@@ -146,6 +144,24 @@
   };
 
 
+/* Structure large enough to hold any socket address (with the historical
+   exception of AF_UNIX).  We reserve 128 bytes.  */
+#if ULONG_MAX > 0xffffffff
+# define __ss_aligntype	__uint64_t
+#else
+# define __ss_aligntype	__uint32_t
+#endif
+#define _SS_SIZE	128
+#define _SS_PADSIZE	(_SS_SIZE - (2 * sizeof (__ss_aligntype)))
+
+struct sockaddr_storage
+  {
+    __SOCKADDR_COMMON (__ss_);	/* Address family, etc.  */
+    __ss_aligntype __ss_align;	/* Force desired alignment.  */
+    char __ss_padding[_SS_PADSIZE];
+  };
+
+
 /* Bits in the FLAGS argument to `send', `recv', et al.  */
 enum
   {
@@ -155,24 +171,38 @@
 #define MSG_PEEK	MSG_PEEK
     MSG_DONTROUTE	= 0x04,	/* Don't use local routing.  */
 #define MSG_DONTROUTE	MSG_DONTROUTE
+#ifdef __USE_GNU
+    /* DECnet uses a different name.  */
+    MSG_TRYHARD		= MSG_DONTROUTE,
+# define MSG_TRYHARD	MSG_DONTROUTE
+#endif
     MSG_CTRUNC		= 0x08,	/* Control data lost before delivery.  */
 #define MSG_CTRUNC	MSG_CTRUNC
-    MSG_PROBE		= 0x10,
-#define MSG_PROBE	MSG_PROBE
+    MSG_PROXY		= 0x10,	/* Supply or ask second address.  */
+#define MSG_PROXY	MSG_PROXY
     MSG_TRUNC		= 0x20,
-#define MSG_TRUNC	MSG_TRUNC
-    MSG_DONTWAIT	= 0x40,
-#define MSG_DONTWAIT	MSG_DONTWAIT
-    MSG_WAITALL		= 0x100,
-#define MSG_WAITALL	MSG_WAITALL
-    MSG_CONFIRM		= 0x800,
-#define MSG_CONFIRM	MSG_CONFIRM
-    MSG_ERRQUEUE	= 0x2000,
-#define MSG_ERRQUEUE	MSG_ERRQUEUE
-    MSG_NOSIGNAL	= 0x4000,
-#define MSG_NOSIGNAL	MSG_NOSIGNAL
+#define	MSG_TRUNC	MSG_TRUNC
+    MSG_DONTWAIT	= 0x40, /* Nonblocking IO.  */
+#define	MSG_DONTWAIT	MSG_DONTWAIT
+    MSG_EOR		= 0x80, /* End of record.  */
+#define	MSG_EOR		MSG_EOR
+    MSG_WAITALL		= 0x100, /* Wait for a full request.  */
+#define	MSG_WAITALL	MSG_WAITALL
+    MSG_FIN		= 0x200,
+#define	MSG_FIN		MSG_FIN
+    MSG_SYN		= 0x400,
+#define	MSG_SYN		MSG_SYN
+    MSG_URG		= 0x800,
+#define	MSG_URG		MSG_URG
+    MSG_RST		= 0x1000,
+#define	MSG_RST		MSG_RST
+    MSG_ERRQUEUE	= 0x2000, /* Fetch message from error queue.  */
+#define	MSG_ERRQUEUE	MSG_ERRQUEUE
+    MSG_NOSIGNAL	= 0x4000  /* Do not generate SIGPIPE.  */
+#define	MSG_NOSIGNAL	MSG_NOSIGNAL
   };
 
+
 /* Structure describing messages sent by
    `sendmsg' and received by `recvmsg'.  */
 struct msghdr
@@ -198,6 +228,7 @@
     int cmsg_type;		/* Protocol specific type.  */
 #if !defined __STRICT_ANSI__ && defined __GNUC__ && __GNUC__ >= 2
     unsigned char __cmsg_data[0]; /* Ancillary data.  */
+    /* XXX Perhaps this should be removed.  */
 #endif
   };
 
@@ -211,62 +242,62 @@
 #define CMSG_FIRSTHDR(mhdr) \
   ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)		      \
    ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) NULL)
-#define CMSG_ALIGN(len) ( ((len)+sizeof(long)-1) & ~(sizeof(long)-1) )
-#define CMSG_SPACE(len) (CMSG_ALIGN(sizeof(struct cmsghdr)) + CMSG_ALIGN(len))
-#define CMSG_LEN(len) (CMSG_ALIGN(sizeof(struct cmsghdr)) + (len))
+#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) \
+			 & ~(sizeof (size_t) - 1))
+#define CMSG_SPACE(len) (CMSG_ALIGN (len) \
+			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
+#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
 
-
-#ifndef _EXTERN_INLINE
-# define _EXTERN_INLINE extern __inline
-#endif
 extern struct cmsghdr *__cmsg_nxthdr __P ((struct msghdr *__mhdr,
 					   struct cmsghdr *__cmsg));
+#ifdef __USE_EXTERN_INLINES
+# ifndef _EXTERN_INLINE
+#  define _EXTERN_INLINE extern __inline
+# endif
 _EXTERN_INLINE struct cmsghdr *
-__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg)
+__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg) __THROW
 {
   if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
-	  /* The kernel header does this so there may be a reason.  */
-	  return NULL;
+    /* The kernel header does this so there may be a reason.  */
+    return 0;
 
-  __cmsg = (struct cmsghdr *) 
-	  ((unsigned char *) __cmsg + CMSG_ALIGN(__cmsg->cmsg_len));  
-
-  if ( (unsigned char *) (__cmsg + 1) >= 
-	   (unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)
-	  /* No more entries.  */
-	  return NULL;
+  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
+			       + CMSG_ALIGN (__cmsg->cmsg_len));
+  if ((unsigned char *) (__cmsg + 1) >= ((unsigned char *) __mhdr->msg_control
+					 + __mhdr->msg_controllen)
+      || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
+	  >= ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
+    /* No more entries.  */
+    return 0;
   return __cmsg;
 }
+#endif	/* Use `extern inline'.  */
 
 /* Socket level message types.  This must match the definitions in
    <linux/socket.h>.  */
 enum
   {
-    SCM_RIGHTS = 0x01,         /* Data array contains access rights.  */
+    SCM_RIGHTS = 0x01,		/* Transfer file descriptors.  */
 #define SCM_RIGHTS SCM_RIGHTS
-    SCM_CREDENTIALS = 0x02,  /* Data array is `struct ucred'.  */
-#define SCM_CREDENTIALS SCM_CREDENTIALS
-  };
-
-
-
-/* Get socket manipulation related informations from kernel headers.  */
-#ifdef THIS_IS_CRAP
-#ifndef _LINUX_TYPES_H
-# define _LINUX_TYPES_H
-#endif
+#ifdef __USE_BSD
+    SCM_CREDENTIALS = 0x02,     /* Credentials passing.  */
+# define SCM_CREDENTIALS SCM_CREDENTIALS
 #endif
+    __SCM_CONNECT = 0x03	/* Data array is `struct scm_connect'.  */
+  };
 
-#include <asm/socket.h>
-#include <asm/types.h>
+/* User visible structure for SCM_CREDENTIALS message */
 
 struct ucred
 {
-	__u32	pid;
-	__u32	uid;
-	__u32	gid;
+  pid_t pid;			/* PID of sending process.  */
+  uid_t uid;			/* UID of sending process.  */
+  gid_t gid;			/* GID of sending process.  */
 };
 
+/* Get socket manipulation related informations from kernel headers.  */
+#include <asm/socket.h>
+
 
 /* Structure used to manipulate the SO_LINGER option.  */
 struct linger
@@ -275,6 +306,4 @@
     int l_linger;		/* Time to linger.  */
   };
 
-__END_DECLS
-
-#endif /* socketbits.h */
+#endif	/* bits/socket.h */

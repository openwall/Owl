--- cpio-2.4.2.orig/rmt.h
+++ cpio-2.4.2/rmt.h
@@ -1,19 +1,19 @@
 /* Definitions for communicating with a remote tape drive.
-   Copyright (C) 1988, 1992 Free Software Foundation, Inc.
+Copyright (C) 1988, 1992 Free Software Foundation, Inc.
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
 
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
@@ -67,10 +67,10 @@
 #define _remdev(path)	(!f_force_local && (__rmt_path=index(path, ':')))
 #define _isrmt(fd)		((fd) >= __REM_BIAS)
 
-#define rmtopen(path,oflag,mode) (_remdev(path) ? __rmt_open(path, oflag, mode, __REM_BIAS) : open(path, oflag, mode))
+#define rmtopen(path,oflag,mode,rsh) (_remdev(path) ? __rmt_open(path, oflag, mode, __REM_BIAS,rsh) : open(path, oflag, mode))
 #define rmtaccess(path, amode)	(_remdev(path) ? 0 : access(path, amode))
 #define rmtstat(path, buf)	(_remdev(path) ? (errno = EOPNOTSUPP), -1 : stat(path, buf))
-#define rmtcreat(path, mode)	(_remdev(path) ? __rmt_open (path, 1 | O_CREAT, mode, __REM_BIAS) : creat(path, mode))
+#define rmtcreat(path, mode, rsh)	(_remdev(path) ? __rmt_open (path, 1 | O_CREAT, mode, __REM_BIAS, rsh) : creat(path, mode))
 #define rmtlstat(path,buf)	(_remdev(path) ? (errno = EOPNOTSUPP), -1 : lstat(path,buf))
 
 #define rmtread(fd, buf, n)	(_isrmt(fd) ? __rmt_read(fd - __REM_BIAS, buf, n) : read(fd, buf, n))
--- cpio-2.4.2.orig/rmt.c
+++ cpio-2.4.2/rmt.c
@@ -45,9 +45,9 @@
 #endif
 #include <errno.h>
 
-#if defined (_I386) && defined (_AIX)
+/* Debian hack: gcc has exhibited problems loading fcntl.h.  Therefore,
+   I removed the preprocessor conditionals here - BEM */
 #include <fcntl.h>
-#endif
 
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
@@ -83,6 +105,30 @@
 #define	DEBUG1(f,a)	if (debug) fprintf(debug, f, a)
 #define	DEBUG2(f,a1,a2)	if (debug) fprintf(debug, f, a1, a2)
 
+/*
+ * Support for Sun's extended RMT protocol
+ */
+#define RMTI_VERSION	-1
+#define RMT_VERSION	1
+
+/* Extended 'i' commands */
+#define RMTI_CACHE	0
+#define RMTI_NOCACHE	1
+#define RMTI_RETEN	2
+#define RMTI_ERASE	3
+#define RMTI_EOM	4
+#define RMTI_NBSF	5
+
+/* Extended 's' commands */
+#define MTS_TYPE	'T'
+#define MTS_DSREG	'D'
+#define MTS_ERREG	'E'
+#define MTS_RESID	'R'
+#define MTS_FILENO	'F'
+#define MTS_BLKNO	'B'
+#define MTS_FLAGS	'f'
+#define MTS_BF		'b'
+
 int
 main (argc, argv)
      int argc;
@@ -196,7 +242,12 @@
       getstring (op);
       getstring (count);
       DEBUG2 ("rmtd: I %s %s\n", op, count);
+      if (atoi(op) == RMTI_VERSION)
+      {
+	  rval = RMT_VERSION;
+      }
 #ifdef MTIOCTOP
+      else
       {
 	struct mtop mtop;
 	mtop.mt_op = atoi (op);
@@ -208,6 +259,58 @@
 #endif
       goto respond;
 
+    case 'i':
+      {
+	struct mtop mtop;
+	
+	getstring (op);
+	getstring (count);
+	DEBUG2 ("rmtd: i %s %s\n", op, count);
+	switch (atoi(op))
+	{
+#ifdef MTCACHE
+	  case RMTI_CACHE:
+	    mtop.mt_op = MTCACHE;
+	    break;
+#endif
+#ifdef MTNOCACHE
+	  case RMTI_NOCACHE:
+	    mtop.mt_op = MTNOCACHE;
+	    break;
+#endif
+#ifdef MTRETEN
+	  case RMTI_RETEN:
+	    mtop.mt_op = MTRETEN;
+	    break;
+#endif
+#ifdef MTERASE
+	  case RMTI_ERASE:
+	    mtop.mt_op = MTERASE;
+	    break;
+#endif
+#ifdef MTEOM
+	  case RMTI_EOM:
+	    mtop.mt_op = MTEOM;
+	    break;
+#endif
+#ifdef MTNBSF
+	  case RMTI_NBSF:
+	    mtop.mt_op = MTNBSF;
+	    break;
+#endif
+	  default:
+	    errno = EINVAL;
+	    goto ioerror;
+	}
+#ifdef MTIOCTOP
+	mtop.mt_count = atoi (count);
+	if (ioctl (tape, MTIOCTOP, (char *) &mtop) < 0)
+	  goto ioerror;
+	rval = mtop.mt_count;
+      }
+#endif
+      goto respond;
+
     case 'S':			/* status */
       DEBUG ("rmtd: S\n");
       {
@@ -223,6 +326,59 @@
 	goto top;
       }
 
+    case 's':
+      {
+	char s;
+	struct mtget mtget;
+
+	if (read (0, &s, 1) != 1)
+	  goto top;
+	
+#ifdef MTIOCGET
+	if (ioctl (tape, MTIOCGET, (char *) &mtget) < 0)
+	  goto ioerror;
+#endif
+	switch (s)
+	{
+	  case MTS_TYPE:
+	    rval = mtget.mt_type;
+	    break;
+
+	  case MTS_DSREG:
+	    rval = mtget.mt_dsreg;
+	    break;
+
+	  case MTS_ERREG:
+	    rval = mtget.mt_erreg;
+	    break;
+
+	  case MTS_RESID:
+	    rval = mtget.mt_resid;
+	    break;
+
+	  case MTS_FILENO:
+	    rval = mtget.mt_fileno;
+	    break;
+
+	  case MTS_BLKNO:
+	    rval = mtget.mt_blkno;
+	    break;
+
+	  case MTS_FLAGS:
+	    rval = mtget.mt_gstat;
+	    break;
+
+	  case MTS_BF:
+	    rval = 0;
+	    break;
+
+	  default:
+	    errno = EINVAL;
+	    goto ioerror;
+	}
+	goto respond;
+      }
+
     default:
       DEBUG1 ("rmtd: garbage command %c\n", c);
       exit (3);
@@ -285,7 +441,11 @@
      int num;
 {
 
-  DEBUG2 ("rmtd: E %d (%s)\n", num, sys_errlist[num]);
-  (void) sprintf (resp, "E%d\n%s\n", num, sys_errlist[num]);
+/* Debian hack: rmt has problems on systems (such as the Hurd) where
+   sys_errlist is not available therefore I borrowed some code from
+   error.c to fix this problem.  This has been reported to the upstream
+   maintainers.  (7/22/99) - BEM */
+  DEBUG2 ("rmtd: E %d (%s)\n", num, strerror (num));
+  (void) sprintf (resp, "E%d\n%s\n", num, strerror (num));
   (void) write (1, resp, strlen (resp));
 }

--- cpio-2.4.2.orig/copyin.c
+++ cpio-2.4.2/copyin.c
@@ -33,6 +33,10 @@
 #define lchown chown
 #endif
 
+/* Debian hack to fix a bug in the --sparse option.  This bug has been
+   reported to "bug-gnu-utils@prep.ai.mit.edu".  (96/7/10) -BEM */
+extern int delayed_seek_count;
+
 static void read_pattern_file ();
 static void tape_skip_padding ();
 static void defer_copyin ();
@@ -494,12 +498,13 @@
 	    }
 	  else
 	    {
-	      char *non_abs_name;
-
-	      non_abs_name = (char *) xmalloc (strlen (p) + 1);
-	      strcpy (non_abs_name, p);
-	      free (file_hdr.c_name);
-	      file_hdr.c_name = non_abs_name;
+              /* Debian hack: file_hrd.c_name is sometimes set to
+                 point to static memory by code in tar.c.  This
+                 causes a segfault.  Therefore, memmove is used
+                 instead of freeing and reallocating.  (Reported by
+                 Horst Knobloch.)  This bug has been reported to
+                 "bug-gnu-utils@prep.ai.mit.edu". (99/1/6) -BEM */
+	      (void)memmove (file_hdr.c_name, p, (size_t)(strlen (p) + 1));
 	    }
 	}
 
@@ -550,7 +555,11 @@
 		long_format (&file_hdr, (char *) 0);
 	    }
 	  else
-	    printf ("%s\n", file_hdr.c_name);
+	    /* Debian hack: Modified to print a list of filenames
+               terminiated by a null character when the -t and -0
+               flags are used.  This has been submitted as a
+               suggestion to "bug-gnu-utils@prep.ai.mit.edu".  -BEM */
+	    printf ("%s%c", file_hdr.c_name, name_end);
 
 	  crc = 0;
 	  tape_toss_input (in_file_des, file_hdr.c_filesize);
@@ -590,6 +599,12 @@
 	    if (crc != file_hdr.c_chksum)
 	      error (0, 0, "%s: checksum error (0x%x, should be 0x%x)",
 		     file_hdr.c_name, crc, file_hdr.c_chksum);
+         /* Debian hack: -v and -V now work with --only-verify-crc.
+            (99/11/10) -BEM */
+	    if (verbose_flag)
+	      fprintf (stderr, "%s\n", file_hdr.c_name);
+	    if (dot_flag)
+	      fputc ('.', stderr);
 	}
       else
 	{
@@ -615,7 +630,28 @@
 		  continue;
 		}
 	      else
-		file_hdr.c_name = xstrdup (new_name.ds_string);
+              /* Debian hack: file_hrd.c_name is sometimes set to
+                 point to static memory by code in tar.c.  This
+                 causes a segfault.  This has been fixed and an
+                 additional check to ensure that the file name
+                 is not too long has been added.  (Reported by
+                 Horst Knobloch.)  This bug has been reported to
+                 "bug-gnu-utils@prep.ai.mit.edu". (99/1/6) -BEM */
+		{
+		  if (archive_format != arf_tar && archive_format != arf_ustar)
+		    {
+		      free (file_hdr.c_name);
+		      file_hdr.c_name = xstrdup (new_name.ds_string);
+		    }
+		  else
+		    {
+		      if (is_tar_filename_too_long (new_name.ds_string))
+			error (0, 0, "%s: file name too long",
+			       new_name.ds_string);
+		      else
+			strcpy (file_hdr.c_name, new_name.ds_string);
+		    }
+		}
 	    }
 
 	  /* See if the file already exists.  */
@@ -686,8 +722,10 @@
 		     but GNU cpio version 2.0-2.2 didn't do that, so we
 		     still have to check for links here (and also in case
 		     the archive was created and later appeneded to). */
+		  /* Debian hack: (97/1/2) This was reported by Ronald
+		     F. Guilmette to the upstream maintainers. -BEM */
 		  link_res = link_to_maj_min_ino (file_hdr.c_name, 
-				file_hdr.c_dev_maj, file_hdr.c_dev_maj,
+				file_hdr.c_dev_maj, file_hdr.c_dev_min,
 				file_hdr.c_ino);
 		  if (link_res == 0)
 		    {
@@ -700,8 +738,10 @@
 		  && archive_format != arf_ustar)
 		{
 		  int link_res;
+		  /* Debian hack: (97/1/2) This was reported by Ronald
+		     F. Guilmette to the upstream maintainers. -BEM */
 		  link_res = link_to_maj_min_ino (file_hdr.c_name, 
-				file_hdr.c_dev_maj, file_hdr.c_dev_maj,
+				file_hdr.c_dev_maj, file_hdr.c_dev_min,
 				file_hdr.c_ino);
 		  if (link_res == 0)
 		    {
@@ -765,6 +805,15 @@
 		    }
 		  copy_files_tape_to_disk (in_file_des, out_file_des, file_hdr.c_filesize);
 		  disk_empty_output_buffer (out_file_des);
+		  /* Debian hack to fix a bug in the --sparse option.
+                     This bug has been reported to
+                     "bug-gnu-utils@prep.ai.mit.edu".  (96/7/10) -BEM */
+		  if (delayed_seek_count > 0)
+		    {
+		      lseek (out_file_des, delayed_seek_count-1, SEEK_CUR);
+		      write (out_file_des, "", 1);
+		      delayed_seek_count = 0;
+		    }
 		  if (close (out_file_des) < 0)
 		    error (0, errno, "%s", file_hdr.c_name);
 
@@ -894,8 +943,11 @@
 		  && archive_format != arf_ustar)
 		{
 		  int link_res;
+                  /* Debian hack:  This was reported by Horst
+                     Knobloch. This bug has been reported to
+                     "bug-gnu-utils@prep.ai.mit.edu". (99/1/6) -BEM */
 		  link_res = link_to_maj_min_ino (file_hdr.c_name, 
-				file_hdr.c_dev_maj, file_hdr.c_dev_maj,
+				file_hdr.c_dev_maj, file_hdr.c_dev_min,
 				file_hdr.c_ino);
 		  if (link_res == 0)
 		    break;
@@ -1306,9 +1358,14 @@
   
   for (d = deferments; d != NULL; d = d->next)
     {
-      d = deferments;
+      /* Debian hack: A line, which could cause an endless loop, was
+         removed (97/1/2).  It was reported by Ronald F. Guilmette to
+         the upstream maintainers. -BEM */
+      /* Debian hack:  This was reported by Horst Knobloch. This bug has
+         been reported to "bug-gnu-utils@prep.ai.mit.edu". (99/1/6) -BEM
+         */
       link_res = link_to_maj_min_ino (d->header.c_name, 
-		    d->header.c_dev_maj, d->header.c_dev_maj,
+		    d->header.c_dev_maj, d->header.c_dev_min,
 		    d->header.c_ino);
       if (link_res == 0)
 	{
--- cpio-2.4.2.orig/copyout.c
+++ cpio-2.4.2/copyout.c
@@ -35,6 +35,7 @@
 static void writeout_other_defers ();
 static void writeout_final_defers();
 static void writeout_defered_file ();
+static void check_for_changed_file ();
 
 /* Write out header FILE_HDR, including the file name, to file
    descriptor OUT_DES.  */
@@ -111,12 +112,15 @@
       if ((file_hdr->c_ino >> 16) != 0)
 	error (0, 0, "%s: truncating inode number", file_hdr->c_name);
 
+      /* Debian hack: The type of dev_t has changed in glibc.  Fixed output
+         to ensure that a long int is passed to sprintf.  This has been
+         reported to "bug-gnu-utils@prep.ai.mit.edu". (1998/5/26) -BEM */
       sprintf (ascii_header,
-	       "%06o%06o%06lo%06lo%06lo%06lo%06lo%06o%011lo%06lo%011lo",
-	       file_hdr->c_magic & 0xFFFF, dev & 0xFFFF,
+	       "%06ho%06lo%06lo%06lo%06lo%06lo%06lo%06lo%011lo%06lo%011lo",
+	       file_hdr->c_magic & 0xFFFF, (long) dev & 0xFFFF,
 	       file_hdr->c_ino & 0xFFFF, file_hdr->c_mode & 0xFFFF,
 	       file_hdr->c_uid & 0xFFFF, file_hdr->c_gid & 0xFFFF,
-	       file_hdr->c_nlink & 0xFFFF, rdev & 0xFFFF,
+	       file_hdr->c_nlink & 0xFFFF, (long) rdev & 0xFFFF,
 	       file_hdr->c_mtime, file_hdr->c_namesize & 0xFFFF,
 	       file_hdr->c_filesize);
       tape_buffered_write (ascii_header, out_des, 76L);
@@ -384,6 +388,7 @@
 
 	      write_out_header (&file_hdr, out_file_des);
 	      copy_files_disk_to_tape (in_file_des, out_file_des, file_hdr.c_filesize, input_name.ds_string);
+	      check_for_changed_file(input_name.ds_string, &file_hdr);
 
 #ifndef __MSDOS__
 	      if (archive_format == arf_tar || archive_format == arf_ustar)
@@ -399,7 +404,13 @@
 		{
 		  times.actime = file_stat.st_atime;
 		  times.modtime = file_stat.st_mtime;
-		  if (utime (file_hdr.c_name, &times) < 0)
+		  /* Debian hack: Silently ignore EROFS because
+                     reading the file won't have upset its timestamp
+                     if it's on a read-only filesystem.  This has been
+                     submitted as a suggestion to
+                     "bug-gnu-utils@prep.ai.mit.edu".  -BEM */
+		  if (utime (file_hdr.c_name, &times) < 0
+		      && errno != EROFS)
 		    error (0, errno, "%s", file_hdr.c_name);
 		}
 	      break;
@@ -562,6 +573,8 @@
 	error (1, errno, "cannot read checksum for %s", file_name);
       if (bytes_read == 0)
 	break;
+      if (bytes_left < bytes_read)
+        bytes_read = bytes_left;
       for (i = 0; i < bytes_read; ++i)
 	crc += buf[i] & 0xff;
     }
@@ -785,6 +798,7 @@
 
   write_out_header (&file_hdr, out_file_des);
   copy_files_disk_to_tape (in_file_des, out_file_des, file_hdr.c_filesize, header->c_name);
+  check_for_changed_file(header->c_name, &file_hdr);
 
 #ifndef __MSDOS__
   if (archive_format == arf_tar || archive_format == arf_ustar)
@@ -800,8 +814,33 @@
     {
       times.actime = file_hdr.c_mtime;
       times.modtime = file_hdr.c_mtime;
-      if (utime (file_hdr.c_name, &times) < 0)
+      /* Debian hack: Silently ignore EROFS because reading the file
+         won't have upset its timestamp if it's on a read-only
+         filesystem.  This has been submitted as a suggestion to
+         "bug-gnu-utils@prep.ai.mit.edu".  -BEM */
+      if (utime (file_hdr.c_name, &times) < 0
+	  && errno != EROFS)
 	error (0, errno, "%s", file_hdr.c_name);
     }
   return;
+}
+
+static void
+check_for_changed_file (name, header)
+     char *name;
+     struct new_cpio_header *header;
+{
+  struct stat new_file_stat;
+
+  if ((*xstat) (name, &new_file_stat) < 0)
+    {
+      error (0, errno, "%s", name);
+      return;
+    }
+  if (header->c_filesize != new_file_stat.st_size)
+    error (0, 0, "%s: size changed from %ld to %ld during copy-out",
+	name, header->c_filesize, new_file_stat.st_size);
+  if (header->c_mtime != new_file_stat.st_mtime)
+    error (0, 0, "%s: mtime changed during copy-out",
+	name, header->c_filesize, new_file_stat.st_size);
 }
--- cpio-2.4.2.orig/copypass.c
+++ cpio-2.4.2/copypass.c
@@ -28,6 +28,10 @@
 #define lchown chown
 #endif
 
+/* Debian hack to fix a bug in the --sparse option.  This bug has been
+   reported to "bug-gnu-utils@prep.ai.mit.edu".  (96/7/10) -BEM */
+extern int delayed_seek_count;
+
 /* Copy files listed on the standard input into directory `directory_name'.
    If `link_flag', link instead of copying.  */
 
@@ -171,6 +175,15 @@
 
 	      copy_files_disk_to_disk (in_file_des, out_file_des, in_file_stat.st_size, input_name.ds_string);
 	      disk_empty_output_buffer (out_file_des);
+	      /* Debian hack to fix a bug in the --sparse option.
+                 This bug has been reported to
+                 "bug-gnu-utils@prep.ai.mit.edu".  (96/7/10) -BEM */
+	      if (delayed_seek_count > 0)
+		{
+		  lseek (out_file_des, delayed_seek_count-1, SEEK_CUR);
+		  write (out_file_des, "", 1);
+		  delayed_seek_count = 0;
+		}
 	      if (close (in_file_des) < 0)
 		error (0, errno, "%s", input_name.ds_string);
 	      if (close (out_file_des) < 0)
@@ -190,9 +203,16 @@
 		{
 		  times.actime = in_file_stat.st_atime;
 		  times.modtime = in_file_stat.st_mtime;
-		  if (utime (input_name.ds_string, &times) < 0)
+		  /* Debian hack: Silently ignore EROFS because
+                     reading the file won't have upset its timestamp
+                     if it's on a read-only filesystem.  This has been
+                     submitted as a suggestion to
+                     "bug-gnu-utils@prep.ai.mit.edu".  -BEM */
+		  if (utime (input_name.ds_string, &times) < 0
+		      && errno != EROFS)
 		    error (0, errno, "%s", input_name.ds_string);
-		  if (utime (output_name.ds_string, &times) < 0)
+		  if (utime (output_name.ds_string, &times) < 0
+		      && errno != EROFS)
 		    error (0, errno, "%s", output_name.ds_string);
 		}
 	      if (retain_time_flag)
--- cpio-2.4.2.orig/global.c
+++ cpio-2.4.2/global.c
@@ -134,6 +134,9 @@
 /* Name of file containing the archive, if known; NULL if stdin/out.  */
 char *archive_name = NULL;
 
+/* Name of the remote shell command, if known; NULL otherwise.  */
+char *rsh_command_option = NULL;
+
 /* CRC checksum.  */
 unsigned long crc;
 
--- cpio-2.4.2.orig/main.c
+++ cpio-2.4.2/main.c
@@ -59,6 +59,7 @@
   {"preserve-modification-time", 0, &retain_time_flag, TRUE},
   {"rename", 0, &rename_flag, TRUE},
   {"rename-batch-file", 1, 0, 137},
+  {"rsh-command", 1, 0, 140},
   {"quiet", 0, 0, 138},
   {"sparse", 0, 0, 135},
   {"swap", 0, 0, 'b'},
@@ -87,7 +88,8 @@
        [--file=[[user@]host:]archive] [--format=format] [--message=message]\n\
        [--null] [--reset-access-time] [--verbose] [--dot] [--append]\n\
        [--block-size=blocks] [--dereference] [--io-size=bytes] [--quiet]\n\
-       [--force-local] [--help] [--version] < name-list [> archive]\n", program_name);
+       [--force-local] [--rsh-command=command] [--help] [--version] < name-list\n\
+       [> archive]\n", program_name);
   fprintf (fp, "\
        %s {-i|--extract} [-bcdfmnrtsuvBSV] [-C bytes] [-E file] [-H format]\n\
        [-M message] [-R [user][:.][group]] [-I [[user@]host:]archive]\n\
@@ -98,7 +100,8 @@
        [--io-size=bytes] [--pattern-file=file] [--format=format]\n\
        [--owner=[user][:.][group]] [--no-preserve-owner] [--message=message]\n\
        [--force-local] [--no-absolute-filenames] [--sparse] [--only-verify-crc]\n\
-       [--quiet] [--help] [--version] [pattern...] [< archive]\n",
+       [--quiet] [--rsh-command=command] [--help] [--version] [pattern...]\n\
+       [< archive]\n",
 	   program_name);
   fprintf (fp, "\
        %s {-p|--pass-through} [-0adlmuvLV] [-R [user][:.][group]]\n\
@@ -288,6 +291,10 @@
 	  copy_function = process_copy_pass;
 	  break;
 
+	case 140:
+	  rsh_command_option = optarg;
+	  break;
+
 	case 'r':		/* Interactively rename.  */
 	  rename_flag = TRUE;
 	  break;
@@ -376,8 +383,9 @@
 	usage (stderr, 2);
     }
 
-  if ((!table_flag || !verbose_flag) && numeric_uid)
-    usage (stderr, 2);
+  /* Debian hack: This version of cpio uses the -n flag also to extract
+     tar archives using the numeric UID/GID instead of the user/group
+     names in /etc/passwd and /etc/groups.  (98/10/15) -BEM */
 
   /* Work around for pcc bug.  */
   copy_in = process_copy_in;
@@ -387,7 +395,9 @@
     {
       archive_des = 0;
       if (link_flag || reset_time_flag || xstat != lstat || append_flag
-	  || sparse_flag
+	  /* Debian hack: The sparse option is used with copy-in not
+             copy-out.  This bug has been reported to
+             "bug-gnu-utils@prep.ai.mit.edu".  (96/7/10) -BEM */
 	  || output_archive_name
 	  || (archive_name && input_archive_name))
 	usage (stderr, 2);
@@ -407,6 +417,10 @@
 	  || set_group_flag || swap_bytes_flag || swap_halfwords_flag
 	  || (append_flag && !(archive_name || output_archive_name))
 	  || rename_batch_file || no_abs_paths_flag
+	  /* Debian hack: The sparse option is used with copy-in not
+             copy-out.  This bug has been reported to
+             "bug-gnu-utils@prep.ai.mit.edu".  (96/7/10) -BEM */
+	  || sparse_flag
 	  || input_archive_name || (archive_name && output_archive_name))
 	usage (stderr, 2);
       if (archive_format == arf_unknown)
--- cpio-2.4.2.orig/tar.c
+++ cpio-2.4.2/tar.c
@@ -261,15 +261,18 @@
       file_hdr->c_nlink = 1;
       otoa (tar_hdr->mode, &file_hdr->c_mode);
       file_hdr->c_mode = file_hdr->c_mode & 07777;
+  /* Debian hack: This version of cpio uses the -n flag also to extract
+     tar archives using the numeric UID/GID instead of the user/group
+     names in /etc/passwd and /etc/groups.  (98/10/15) -BEM */
 #ifndef __MSDOS__
-      if (archive_format == arf_ustar
+      if (archive_format == arf_ustar && !numeric_uid
 	  && (uidp = getuidbyname (tar_hdr->uname)))
 	file_hdr->c_uid = *uidp;
       else
 #endif
 	otoa (tar_hdr->uid, &file_hdr->c_uid);
 #ifndef __MSDOS__
-      if (archive_format == arf_ustar
+      if (archive_format == arf_ustar && !numeric_uid
 	  && (gidp = getgidbyname (tar_hdr->gname)))
 	file_hdr->c_gid = *gidp;
       else
--- cpio-2.4.2.orig/util.c
+++ cpio-2.4.2/util.c
@@ -489,7 +489,9 @@
   while (num_bytes > 0)
     {
       if (input_size == 0)
-	if (rc = disk_fill_input_buffer (in_des, DISK_IO_BLOCK_SIZE))
+	if (rc = disk_fill_input_buffer (in_des,
+	  num_bytes < DISK_IO_BLOCK_SIZE ?
+	  num_bytes : DISK_IO_BLOCK_SIZE))
 	  {
 	    if (rc > 0)
 	      error (0, 0, "File %s shrunk by %ld bytes, padding with zeros",
@@ -808,13 +810,14 @@
   copy_in = process_copy_in;
 
   if (copy_function == copy_in)
-    fd = rmtopen (file, O_RDONLY | O_BINARY, 0666);
+    fd = rmtopen (file, O_RDONLY | O_BINARY, 0666, rsh_command_option);
   else
     {
       if (!append_flag)
-	fd = rmtopen (file, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);
+	fd = rmtopen (file, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666,
+			rsh_command_option);
       else
-	fd = rmtopen (file, O_RDWR | O_BINARY, 0666);
+	fd = rmtopen (file, O_RDWR | O_BINARY, 0666, rsh_command_option);
     }
 
   return fd;
--- cpio-2.4.2.orig/rtapelib.c
+++ cpio-2.4.2/rtapelib.c
@@ -264,11 +264,12 @@
    On error, return -1.  */
 
 int
-__rmt_open (path, oflag, mode, bias)
+__rmt_open (path, oflag, mode, bias, remote_shell)
      char *path;
      int oflag;
      int mode;
      int bias;
+     const char *remote_shell;
 {
   int i, rc;
   char buffer[CMDBUFSIZE];	/* Command buffer.  */
@@ -372,29 +373,43 @@
 
       if (*login)
 	{
-	  execl ("/usr/ucb/rsh", "rsh", system, "-l", login,
+	  /* Debian hack: added remote shell command line option.
+	     (98/5/20) -BEM */
+	  if (remote_shell) {
+	    const char *remote_shell_basename;
+	    remote_shell_basename = strrchr (remote_shell, '/');
+	    if (remote_shell_basename)
+	      remote_shell_basename++;
+	    else
+	      remote_shell_basename = remote_shell;
+	    execl (remote_shell, remote_shell_basename, system, "-l", login,
 		 "/etc/rmt", (char *) 0);
-	  execl ("/usr/bin/remsh", "remsh", system, "-l", login,
+	  } else {
+	  execl ("/usr/bin/ssh", "ssh", system, "-l", login,
 		 "/etc/rmt", (char *) 0);
 	  execl ("/usr/bin/rsh", "rsh", system, "-l", login,
 		 "/etc/rmt", (char *) 0);
-	  execl ("/usr/bsd/rsh", "rsh", system, "-l", login,
-		 "/etc/rmt", (char *) 0);
-	  execl ("/usr/bin/nsh", "nsh", system, "-l", login,
-		 "/etc/rmt", (char *) 0);
+	  }
 	}
       else
 	{
-	  execl ("/usr/ucb/rsh", "rsh", system,
+	  /* Debian hack: added remote shell command line option.
+	     (98/5/20) -BEM */
+	  if (remote_shell) {
+	    const char *remote_shell_basename;
+	    remote_shell_basename = strrchr (remote_shell, '/');
+	    if (remote_shell_basename)
+	      remote_shell_basename++;
+	    else
+	      remote_shell_basename = remote_shell;
+	    execl (remote_shell, remote_shell_basename, system,
 		 "/etc/rmt", (char *) 0);
-	  execl ("/usr/bin/remsh", "remsh", system,
+	  } else {
+	  execl ("/usr/bin/ssh", "ssh", system,
 		 "/etc/rmt", (char *) 0);
 	  execl ("/usr/bin/rsh", "rsh", system,
 		 "/etc/rmt", (char *) 0);
-	  execl ("/usr/bsd/rsh", "rsh", system,
-		 "/etc/rmt", (char *) 0);
-	  execl ("/usr/bin/nsh", "nsh", system,
-		 "/etc/rmt", (char *) 0);
+	  }
 	}
 
       /* Bad problems if we get here.  */
--- cpio-2.4.2.orig/extern.h
+++ cpio-2.4.2/extern.h
@@ -57,6 +57,7 @@
 extern char *new_media_message_after_number;
 extern int archive_des;
 extern char *archive_name;
+extern char *rsh_command_option;
 extern unsigned long crc;
 #ifdef DEBUG_CPIO
 extern int debug_flag;


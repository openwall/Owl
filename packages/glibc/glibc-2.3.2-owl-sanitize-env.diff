diff -uNrp glibc-2.3.2.orig/elf/dl-support.c glibc-2.3.2/elf/dl-support.c
--- glibc-2.3.2.orig/elf/dl-support.c	2004-03-08 02:34:09 +0000
+++ glibc-2.3.2/elf/dl-support.c	2004-03-08 05:15:51 +0000
@@ -189,32 +189,64 @@ _dl_non_dynamic_init (void)
 
   /* Initialize the data structures for the search paths for shared
      objects.  */
-  _dl_init_paths (getenv ("LD_LIBRARY_PATH"));
+  _dl_init_paths (INTUSE(__libc_enable_secure) ? NULL : getenv ("LD_LIBRARY_PATH"));
 
-  _dl_lazy = *(getenv ("LD_BIND_NOW") ?: "") == '\0';
+  _dl_lazy = INTUSE(__libc_enable_secure) || *(getenv ("LD_BIND_NOW") ?: "") == '\0';
 
   _dl_bind_not = *(getenv ("LD_BIND_NOT") ?: "") != '\0';
 
   _dl_dynamic_weak = *(getenv ("LD_DYNAMIC_WEAK") ?: "") == '\0';
 
-  if (__libc_enable_secure)
+  /*
+   * (GM): It is weird to have different code for the same functionality
+   */
+  /* Extra security for SUID binaries.  Remove all dangerous environment
+     variables.  */
+  if (__builtin_expect (INTUSE(__libc_enable_secure), 0))
     {
-      static const char *unsecure_envvars[] =
-      {
-	UNSECURE_ENVVARS,
+      static const char unsecure_envvars[] =
 #ifdef EXTRA_UNSECURE_ENVVARS
 	EXTRA_UNSECURE_ENVVARS
 #endif
-      };
-      size_t cnt;
+	UNSECURE_ENVVARS;
 
-      for (cnt = 0;
-	   cnt < sizeof (unsecure_envvars) / sizeof (unsecure_envvars[0]);
-	   ++cnt)
-	unsetenv (unsecure_envvars[cnt]);
+      static const char restricted_envvars[] =
+#ifdef EXTRA_RESTRICTED_ENVVARS
+	EXTRA_RESTRICTED_ENVVARS
+#endif
+	RESTRICTED_ENVVARS;
+
+      const char *nextp;
+      char *value;
 
+      nextp = unsecure_envvars;
+      do
+	{
+	  unsetenv (nextp);
+	  /* We could use rawmemchr but this need not be fast.  */
+	  nextp = (char *) (strchr) (nextp, '\0') + 1;
+	}
+      while (*nextp != '\0');
+
+      nextp = restricted_envvars;
+      do
+	{
+	  if ((value = getenv(nextp))
+	      && (*value == '.' || strchr(value, '/')))
+	    unsetenv (nextp);
+	  /* We could use rawmemchr but this need not be fast.  */
+	  nextp = (char *) (strchr) (nextp, '\0') + 1;
+	}
+      while (*nextp != '\0');
+
+#if 0
+      /*
+       * XXX: (GM): Should we left this glibc's behaviour? For now, we
+       *            are dropping all MALLOC_* unconditionally.
+       */
       if (__access ("/etc/suid-debug", F_OK) != 0)
 	unsetenv ("MALLOC_CHECK_");
+#endif
     }
 
 #ifdef DL_PLATFORM_INIT
diff -uNrp glibc-2.3.2.orig/elf/rtld.c glibc-2.3.2/elf/rtld.c
--- glibc-2.3.2.orig/elf/rtld.c	2004-03-08 02:34:09 +0000
+++ glibc-2.3.2/elf/rtld.c	2004-03-08 04:59:09 +0000
@@ -1907,7 +1907,8 @@ process_envvars (enum mode *modep)
 
 	case 5:
 	  /* Debugging of the dynamic linker?  */
-	  if (memcmp (envline, "DEBUG", 5) == 0)
+	  if (!INTUSE(__libc_enable_secure)
+	      && memcmp (envline, "DEBUG", 5) == 0)
 	    process_dl_debug (&envline[6]);
 	  break;
 
@@ -1920,20 +1921,23 @@ process_envvars (enum mode *modep)
 	    }
 
 	  /* List of objects to be preloaded.  */
-	  if (memcmp (envline, "PRELOAD", 7) == 0)
+	  if (!INTUSE(__libc_enable_secure)
+	      && memcmp (envline, "PRELOAD", 7) == 0)
 	    {
 	      preloadlist = &envline[8];
 	      break;
 	    }
 
 	  /* Which shared object shall be profiled.  */
-	  if (memcmp (envline, "PROFILE", 7) == 0 && envline[8] != '\0')
+	  if (!INTUSE(__libc_enable_secure)
+	      && memcmp (envline, "PROFILE", 7) == 0 && envline[8] != '\0')
 	    GL(dl_profile) = &envline[8];
 	  break;
 
 	case 8:
 	  /* Do we bind early?  */
-	  if (memcmp (envline, "BIND_NOW", 8) == 0)
+	  if (!INTUSE(__libc_enable_secure)
+	      && memcmp (envline, "BIND_NOW", 8) == 0)
 	    {
 	      GL(dl_lazy) = envline[9] == '\0';
 	      break;
@@ -1945,13 +1949,15 @@ process_envvars (enum mode *modep)
 	case 9:
 	  /* Test whether we want to see the content of the auxiliary
 	     array passed up from the kernel.  */
-	  if (memcmp (envline, "SHOW_AUXV", 9) == 0)
+	  if (!INTUSE(__libc_enable_secure)
+	      && memcmp (envline, "SHOW_AUXV", 9) == 0)
 	    _dl_show_auxv ();
 	  break;
 
 	case 10:
 	  /* Mask for the important hardware capabilities.  */
-	  if (memcmp (envline, "HWCAP_MASK", 10) == 0)
+	  if (!INTUSE(__libc_enable_secure)
+	      && memcmp (envline, "HWCAP_MASK", 10) == 0)
 	    GL(dl_hwcap_mask) = __strtoul_internal (&envline[11], NULL, 0, 0);
 	  break;
 
@@ -1964,7 +1970,8 @@ process_envvars (enum mode *modep)
 
 	case 12:
 	  /* The library search path.  */
-	  if (memcmp (envline, "LIBRARY_PATH", 12) == 0)
+	  if (!INTUSE(__libc_enable_secure)
+	      && memcmp (envline, "LIBRARY_PATH", 12) == 0)
 	    {
 	      library_path = &envline[13];
 	      break;
@@ -2002,7 +2009,8 @@ process_envvars (enum mode *modep)
 
 	case 20:
 	  /* The mode of the dynamic linker can be set.  */
-	  if (memcmp (envline, "TRACE_LOADED_OBJECTS", 20) == 0)
+	  if (!INTUSE(__libc_enable_secure)
+	      && memcmp (envline, "TRACE_LOADED_OBJECTS", 20) == 0)
 	    mode = trace;
 	  break;
 
@@ -2023,12 +2031,29 @@ process_envvars (enum mode *modep)
      variables.  */
   if (__builtin_expect (INTUSE(__libc_enable_secure), 0))
     {
+      /* These lists include both environment variables specific to the
+        dynamic linker and generic ones used by various parts of glibc.
+	They should be (partially?) moved to libc initialization in order
+	to provide the same protection for statically-linked programs.
+	Note that glibc itself tries to be careful to not trust these
+	variables when running SUID/SGID, and it remains the responsibility
+	of SUID/SGID programs to sanitize environment before executing
+	other programs with matching real and effective IDs.  This is a
+	"hardening" measure only, -- noone is supposed to rely on it.  */
       static const char unsecure_envvars[] =
 #ifdef EXTRA_UNSECURE_ENVVARS
 	EXTRA_UNSECURE_ENVVARS
 #endif
 	UNSECURE_ENVVARS;
+
+      static const char restricted_envvars[] =
+#ifdef EXTRA_RESTRICTED_ENVVARS
+	EXTRA_RESTRICTED_ENVVARS
+#endif
+	RESTRICTED_ENVVARS;
+
       const char *nextp;
+      char *value;
 
       nextp = unsecure_envvars;
       do
@@ -2039,8 +2064,25 @@ process_envvars (enum mode *modep)
 	}
       while (*nextp != '\0');
 
+      nextp = restricted_envvars;
+      do
+	{
+	  if ((value = getenv(nextp))
+	      && (*value == '.' || strchr(value, '/')))
+	    unsetenv (nextp);
+	  /* We could use rawmemchr but this need not be fast.  */
+	  nextp = (char *) (strchr) (nextp, '\0') + 1;
+	}
+      while (*nextp != '\0');
+
+#if 0
+      /*
+       * XXX: (GM): Should we left this glibc's behaviour? For now, we
+       *            are dropping all MALLOC_* unconditionally.
+       */
       if (__access ("/etc/suid-debug", F_OK) != 0)
 	unsetenv ("MALLOC_CHECK_");
+#endif
     }
   /* If we have to run the dynamic linker in debugging mode and the
      LD_DEBUG_OUTPUT environment variable is given, we write the debug
diff -uNrp glibc-2.3.2.orig/io/getdirname.c glibc-2.3.2/io/getdirname.c
--- glibc-2.3.2.orig/io/getdirname.c	2001-07-07 19:21:03 +0000
+++ glibc-2.3.2/io/getdirname.c	2004-03-08 05:20:08 +0000
@@ -31,7 +31,9 @@ get_current_dir_name (void)
   char *pwd;
   struct stat64 dotstat, pwdstat;
 
-  pwd = getenv ("PWD");
+  /* A plain getenv() could let one check for subdirectories of a directory
+     only accessible to the effective privileges of the program.  */
+  pwd = __secure_getenv ("PWD");
   if (pwd != NULL
       && stat64 (".", &dotstat) == 0
       && stat64 (pwd, &pwdstat) == 0
diff -uNrp glibc-2.3.2.orig/malloc/arena.c glibc-2.3.2/malloc/arena.c
--- glibc-2.3.2.orig/malloc/arena.c	2002-12-27 23:22:15 +0000
+++ glibc-2.3.2/malloc/arena.c	2004-03-08 05:23:31 +0000
@@ -492,7 +492,7 @@ ptmalloc_init __MALLOC_P((void))
       if((s = getenv("MALLOC_MMAP_MAX_")))
 	mALLOPt(M_MMAP_MAX, atoi(s));
     }
-  s = getenv("MALLOC_CHECK_");
+  s = __secure_getenv("MALLOC_CHECK_");
 #endif
   if(s) {
     if(s[0]) mALLOPt(M_CHECK_ACTION, (int)(s[0] - '0'));
diff -uNrp glibc-2.3.2.orig/resolv/res_hconf.c glibc-2.3.2/resolv/res_hconf.c
--- glibc-2.3.2.orig/resolv/res_hconf.c	2002-11-02 02:15:53 +0000
+++ glibc-2.3.2/resolv/res_hconf.c	2004-03-08 03:30:31 +0000
@@ -443,30 +443,30 @@ do_init (void)
       fclose (fp);
     }
 
-  envval = getenv (ENV_SERVORDER);
+  envval = __secure_getenv (ENV_SERVORDER);
   if (envval)
     {
       _res_hconf.num_services = 0;
       arg_service_list (ENV_SERVORDER, 1, envval, 0);
     }
 
-  envval = getenv (ENV_SPOOF);
+  envval = __secure_getenv (ENV_SPOOF);
   if (envval)
     arg_spoof (ENV_SPOOF, 1, envval, 0);
 
-  envval = getenv (ENV_MULTI);
+  envval = __secure_getenv (ENV_MULTI);
   if (envval)
     arg_bool (ENV_MULTI, 1, envval, HCONF_FLAG_MULTI);
 
-  envval = getenv (ENV_REORDER);
+  envval = __secure_getenv (ENV_REORDER);
   if (envval)
     arg_bool (ENV_REORDER, 1, envval, HCONF_FLAG_REORDER);
 
-  envval = getenv (ENV_TRIM_ADD);
+  envval = __secure_getenv (ENV_TRIM_ADD);
   if (envval)
     arg_trimdomain_list (ENV_TRIM_ADD, 1, envval, 0);
 
-  envval = getenv (ENV_TRIM_OVERR);
+  envval = __secure_getenv (ENV_TRIM_OVERR);
   if (envval)
     {
       _res_hconf.num_trimdomains = 0;
diff -uNrp glibc-2.3.2.orig/sysdeps/generic/glob.c glibc-2.3.2/sysdeps/generic/glob.c
--- glibc-2.3.2.orig/sysdeps/generic/glob.c	2004-03-08 02:34:13 +0000
+++ glibc-2.3.2/sysdeps/generic/glob.c	2004-03-08 03:30:31 +0000
@@ -171,7 +171,7 @@ extern int errno;
 # define	ANSI_STRING
 #else	/* No standard headers.  */
 
-extern char *getenv ();
+extern char *__secure_getenv ();
 
 # ifdef HAVE_STRING_H
 #  include <string.h>
@@ -691,7 +691,7 @@ glob (pattern, flags, errfunc, pglob)
       if (dirname[1] == '\0' || dirname[1] == '/')
 	{
 	  /* Look up home directory.  */
-	  const char *home_dir = getenv ("HOME");
+	  const char *home_dir = __secure_getenv ("HOME");
 # ifdef _AMIGA
 	  if (home_dir == NULL || home_dir[0] == '\0')
 	    home_dir = "SYS:";
diff -uNrp glibc-2.3.2.orig/sysdeps/generic/segfault.c glibc-2.3.2/sysdeps/generic/segfault.c
--- glibc-2.3.2.orig/sysdeps/generic/segfault.c	2002-11-03 08:36:55 +0000
+++ glibc-2.3.2/sysdeps/generic/segfault.c	2004-03-08 03:30:31 +0000
@@ -254,7 +254,7 @@ install_handler (void)
     }
 
   /* Preserve the output file name if there is any given.  */
-  name = getenv ("SEGFAULT_OUTPUT_NAME");
+  name = __secure_getenv ("SEGFAULT_OUTPUT_NAME");
   if (name != NULL && name[0] != '\0')
     {
       int ret = access (name, R_OK | W_OK);
diff -uNrp glibc-2.3.2.orig/sysdeps/generic/unsecvars.h glibc-2.3.2/sysdeps/generic/unsecvars.h
--- glibc-2.3.2.orig/sysdeps/generic/unsecvars.h	2001-11-05 23:42:49 +0000
+++ glibc-2.3.2/sysdeps/generic/unsecvars.h	2004-03-08 05:03:11 +0000
@@ -2,18 +2,52 @@
    all stuffed in a single string which means they have to be terminated
    with a '\0' explicitly.  */
 #define UNSECURE_ENVVARS \
+  "LD_DEBUG\0"								      \
   "LD_PRELOAD\0"							      \
-  "LD_LIBRARY_PATH\0"							      \
+  "LD_PROFILE\0"							      \
+  "LD_BIND_NOW\0"							      \
+  "LD_SHOW_AUX\0"							      \
+  "LD_HWCAP_MASK\0"							      \
   "LD_ORIGIN_PATH\0"							      \
   "LD_DEBUG_OUTPUT\0"							      \
-  "LD_PROFILE\0"							      \
-  "GCONV_PATH\0"							      \
-  "HOSTALIASES\0"							      \
+  "LD_LIBRARY_PATH\0"							      \
+  "LD_PROFILE_OUTPUT\0"							      \
+  "LD_TRACE_LOADED_OBJECTS\0"						      \
+  "RESOLV_HOST_CONF\0"							      \
+  "RESOLV_SERV_ORDER\0"							      \
+  "RESOLV_SPOOF_CHECK\0"						      \
+  "RESOLV_OVERRIDE_TRIM_DOMAINS\0"					      \
+  "RESOLV_ADD_TRIM_DOMAINS\0"						      \
+  "RESOLV_MULTI\0"							      \
+  "RESOLV_REORDER\0"							      \
+  "RES_OPTIONS\0"							      \
   "LOCALDOMAIN\0"							      \
-  "LOCPATH\0"								      \
+  "HOSTALIASES\0"							      \
+  "MALLOC_TRIM_THRESHOLD_\0"						      \
+  "MALLOC_TOP_PAD_\0"							      \
+  "MALLOC_MMAP_THRESHOLD_\0"						      \
+  "MALLOC_MMAP_MAX_\0"							      \
+  "MALLOC_CHECK_\0"							      \
   "MALLOC_TRACE\0"							      \
+  "HESIOD_CONFIG\0"							      \
+  "HES_DOMAIN\0"							      \
+  "GCONV_PATH\0"							      \
+  "LOCPATH\0"								      \
   "NLSPATH\0"								      \
-  "RESOLV_HOST_CONF\0"							      \
-  "RES_OPTIONS\0"							      \
   "TMPDIR\0"								      \
-  "TZDIR\0"
+  "TZ\0"								      \
+  "TZDIR\0"								      \
+  "SEGFAULT_OUTPUT_NAME\0"
+
+/* XXX: (GM): Place a description here */
+#define RESTRICTED_ENVVARS \
+  "LANGUAGE\0"								      \
+  "LANG\0"								      \
+  "LC_ALL\0"								      \
+  "LC_COLLATE\0"							      \
+  "LC_CTYPE\0"								      \
+  "LC_MESSAGES\0"							      \
+  "LC_MONETARY\0"							      \
+  "LC_NUMERIC\0"							      \
+  "LC_TIME\0"								      \
+  "LC_XXX\0"
diff -uNrp glibc-2.3.2.orig/sysdeps/unix/sysv/linux/i386/dl-librecon.h glibc-2.3.2/sysdeps/unix/sysv/linux/i386/dl-librecon.h
--- glibc-2.3.2.orig/sysdeps/unix/sysv/linux/i386/dl-librecon.h	2002-12-10 19:47:16 +0000
+++ glibc-2.3.2/sysdeps/unix/sysv/linux/i386/dl-librecon.h	2004-03-08 03:47:48 +0000
@@ -51,13 +51,15 @@
 #undef EXTRA_LD_ENVVARS
 #define EXTRA_LD_ENVVARS EXTRA_LD_ENVVARS_LINUX \
   case 15:								      \
-    if (memcmp (envline, "LIBRARY_VERSION", 15) == 0)			      \
+    if (!INTUSE(__libc_enable_secure)					      \
+       && memcmp (envline, "LIBRARY_VERSION", 15) == 0)			      \
       GL(dl_correct_cache_id) = envline[16] == '5' ? 2 : 3;		      \
     break;								      \
 
 /* Extra unsecure variables.  The names are all stuffed in a single
    string which means they have to be terminated with a '\0' explicitly.  */
 #define EXTRA_UNSECURE_ENVVARS \
+  "LD_LIBRARY_VERSION\0"						      \
   "LD_AOUT_LIBRARY_PATH\0"						      \
   "LD_AOUT_PRELOAD\0"
 
diff -uNrp glibc-2.3.2.orig/time/tzset.c glibc-2.3.2/time/tzset.c
--- glibc-2.3.2.orig/time/tzset.c	2003-02-01 20:47:35 +0000
+++ glibc-2.3.2/time/tzset.c	2004-03-08 03:30:31 +0000
@@ -157,8 +157,11 @@ tzset_internal (always)
     return;
   is_initialized = 1;
 
-  /* Examine the TZ environment variable.  */
-  tz = getenv ("TZ");
+  /* Examine the TZ environment variable.  This doesn't really have to be
+     a __secure_getenv() call as __tzfile_read() tries to only read files
+     found under a trusted directory, but this helps reduce the amount of
+     security-critical code.  */
+  tz = __secure_getenv ("TZ");
   if (tz == NULL)
     /* No user specification; use the site-wide default.  */
     tz = TZDEFAULT;

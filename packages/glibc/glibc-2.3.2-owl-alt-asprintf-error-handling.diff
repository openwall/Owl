diff -uNrp glibc-2.3.2.orig/libio/vasprintf.c glibc-2.3.2/libio/vasprintf.c
--- glibc-2.3.2.orig/libio/vasprintf.c	2004-03-09 09:39:02 +0000
+++ glibc-2.3.2/libio/vasprintf.c	2004-03-09 09:21:50 +0000
@@ -48,7 +48,10 @@ _IO_vasprintf (result_ptr, format, args)
   _IO_size_t allocated;
   string = (char *) malloc (init_string_size);
   if (string == NULL)
-    return -1;
+    {
+      *result_ptr = NULL;
+      return -1;
+    }
 #ifdef _IO_MTSAFE_IO
   sf._sbf._f._lock = NULL;
 #endif
@@ -61,7 +64,9 @@ _IO_vasprintf (result_ptr, format, args)
   ret = INTUSE(_IO_vfprintf) (&sf._sbf._f, format, args);
   if (ret < 0)
     {
-      free (sf._sbf._f._IO_buf_base);
+      if (sf._sbf._f._IO_buf_base != NULL)
+       free (sf._sbf._f._IO_buf_base);
+      *result_ptr = NULL;
       return ret;
     }
   /* Only use realloc if the size we need is of the same order of
diff -uNrp glibc-2.3.2.orig/login/programs/pt_chown.c glibc-2.3.2/login/programs/pt_chown.c
--- glibc-2.3.2.orig/login/programs/pt_chown.c	2004-03-09 09:39:02 +0000
+++ glibc-2.3.2/login/programs/pt_chown.c	2004-03-09 08:53:03 +0000
@@ -71,6 +71,7 @@ more_help (int key, const char *text, vo
   switch (key)
     {
     case ARGP_KEY_HELP_PRE_DOC:
+      /* XXX: possible allocation errors */
       asprintf (&cp, gettext ("\
 Set the owner, group and access permission of the slave pseudo\
  terminal corresponding to the master pseudo terminal passed on\
@@ -81,6 +82,7 @@ Set the owner, group and access permissi
       return cp;
     case ARGP_KEY_HELP_EXTRA:
       /* We print some extra information.  */
+      /* XXX: possible allocation errors */
       asprintf (&cp, gettext ("\
 The owner is set to the current user, the group is set to `%s',\
  and the access permission is set to `%o'.\n\n\
diff -uNrp glibc-2.3.2.orig/manual/stdio.texi glibc-2.3.2/manual/stdio.texi
--- glibc-2.3.2.orig/manual/stdio.texi	2004-03-09 09:39:02 +0000
+++ glibc-2.3.2/manual/stdio.texi	2004-03-09 08:53:03 +0000
@@ -2393,7 +2393,11 @@ allocates a string (as with @code{malloc
 Allocation}) to hold the output, instead of putting the output in a
 buffer you allocate in advance.  The @var{ptr} argument should be the
 address of a @code{char *} object, and @code{asprintf} stores a pointer
-to the newly allocated string at that location.
+to the newly allocated string at that location.  Unlike the official
+glibc implementation of @code{asprintf}, this one has been modified to
+reset the pointer to NULL on any error.  This is also the behavior
+documented for @code{asprintf} on FreeBSD, NetBSD, and OpenBSD.  The
+official glibc @code{asprintf} leaves the pointer undefined on errors.
 
 The return value is the number of characters allocated for the buffer, or
 less than zero if an error occurred. Usually this means that the buffer
diff -uNrp glibc-2.3.2.orig/resolv/res_hconf.c glibc-2.3.2/resolv/res_hconf.c
--- glibc-2.3.2.orig/resolv/res_hconf.c	2004-03-09 05:54:11 +0000
+++ glibc-2.3.2/resolv/res_hconf.c	2004-03-09 09:53:31 +0000
@@ -144,35 +144,38 @@ arg_service_list (const char *fname, int
 	{
 	  char *buf;
 
-	  __asprintf (&buf, _("%s: line %d: expected service, found `%s'\n"),
-		      fname, line_num, start);
-
+	  if (__asprintf (&buf, _("%s: line %d: expected service, found `%s'\n"),
+		      fname, line_num, start) >= 0)
+	    {
 #ifdef USE_IN_LIBIO
-	  if (_IO_fwide (stderr, 0) > 0)
-	    __fwprintf (stderr, L"%s", buf);
-	  else
+	      if (_IO_fwide (stderr, 0) > 0)
+	        __fwprintf (stderr, L"%s", buf);
+	      else
 #endif
-	    fputs (buf, stderr);
+	        fputs (buf, stderr);
 
-	  free (buf);
+	      free (buf);
+	    }
 	  return 0;
 	}
       if (_res_hconf.num_services >= SERVICE_MAX)
 	{
 	  char *buf;
 
-	  __asprintf (&buf,
+	  if (__asprintf (&buf,
 		      _("%s: line %d: cannot specify more than %d services"),
-		      fname, line_num, SERVICE_MAX);
+		      fname, line_num, SERVICE_MAX) >= 0)
+	    {
 
 #ifdef USE_IN_LIBIO
-	  if (_IO_fwide (stderr, 0) > 0)
-	    __fwprintf (stderr, L"%s", buf);
-	  else
+	      if (_IO_fwide (stderr, 0) > 0)
+	        __fwprintf (stderr, L"%s", buf);
+	      else
 #endif
-	    fputs (buf, stderr);
+	        fputs (buf, stderr);
 
-	  free (buf);
+	      free (buf);
+	    }
 	  return 0;
 	}
       _res_hconf.service[_res_hconf.num_services++] = service;
@@ -188,18 +191,19 @@ arg_service_list (const char *fname, int
 	    {
 	      char *buf;
 
-	      __asprintf (&buf, _("\
+	      if (__asprintf (&buf, _("\
 %s: line %d: list delimiter not followed by keyword"),
-			  fname, line_num);
-
+			  fname, line_num) >= 0)
+		{
 #ifdef USE_IN_LIBIO
-	      if (_IO_fwide (stderr, 0) > 0)
-		__fwprintf (stderr, L"%s", buf);
-	      else
+	          if (_IO_fwide (stderr, 0) > 0)
+		    __fwprintf (stderr, L"%s", buf);
+	          else
 #endif
-		fputs (buf, stderr);
+		    fputs (buf, stderr);
 
-	      free (buf);
+		    free (buf);
+		}
 	      return 0;
 	    }
 	default:
@@ -228,10 +232,10 @@ arg_trimdomain_list (const char *fname, 
 	{
 	  char *buf;
 
-	  __asprintf (&buf, _("\
+	  if (__asprintf (&buf, _("\
 %s: line %d: cannot specify more than %d trim domains"),
-		      fname, line_num, TRIMDOMAINS_MAX);
-
+		      fname, line_num, TRIMDOMAINS_MAX) >= 0)
+	    {
 #ifdef USE_IN_LIBIO
 	      if (_IO_fwide (stderr, 0) > 0)
 		__fwprintf (stderr, L"%s", buf);
@@ -240,6 +244,7 @@ arg_trimdomain_list (const char *fname, 
 		fputs (buf, stderr);
 
 	      free (buf);
+	    }
 	  return 0;
 	}
       _res_hconf.trimdomain[_res_hconf.num_trimdomains++] =
@@ -253,18 +258,19 @@ arg_trimdomain_list (const char *fname, 
 	    {
 	      char *buf;
 
-	      __asprintf (&buf, _("\
+	      if (__asprintf (&buf, _("\
 %s: line %d: list delimiter not followed by domain"),
-			  fname, line_num);
-
+			  fname, line_num) >= 0)
+		{
 #ifdef USE_IN_LIBIO
-	      if (_IO_fwide (stderr, 0) > 0)
-		__fwprintf (stderr, L"%s", buf);
-	      else
+	          if (_IO_fwide (stderr, 0) > 0)
+		    __fwprintf (stderr, L"%s", buf);
+	          else
 #endif
-		fputs (buf, stderr);
+		    fputs (buf, stderr);
 
-	      free (buf);
+		  free (buf);
+		}
 	      return 0;
 	    }
 	default:
@@ -315,18 +321,19 @@ arg_bool (const char *fname, int line_nu
     {
       char *buf;
 
-      __asprintf (&buf,
+      if (__asprintf (&buf,
 		  _("%s: line %d: expected `on' or `off', found `%s'\n"),
-		  fname, line_num, args);
-
+		  fname, line_num, args) >= 0)
+	{
 #ifdef USE_IN_LIBIO
-      if (_IO_fwide (stderr, 0) > 0)
-	__fwprintf (stderr, L"%s", buf);
-      else
+	    if (_IO_fwide (stderr, 0) > 0)
+	      __fwprintf (stderr, L"%s", buf);
+	    else
 #endif
-	fputs (buf, stderr);
+	      fputs (buf, stderr);
 
-      free (buf);
+	    free (buf);
+	}
       return 0;
     }
   return args;
@@ -363,17 +370,18 @@ parse_line (const char *fname, int line_
     {
       char *buf;
 
-      __asprintf (&buf, _("%s: line %d: bad command `%s'\n"),
-		  fname, line_num, start);
-
+      if (__asprintf (&buf, _("%s: line %d: bad command `%s'\n"),
+		  fname, line_num, start) >= 0)
+	{
 #ifdef USE_IN_LIBIO
-      if (_IO_fwide (stderr, 0) > 0)
-	__fwprintf (stderr, L"%s", buf);
-      else
+	    if (_IO_fwide (stderr, 0) > 0)
+	      __fwprintf (stderr, L"%s", buf);
+	    else
 #endif
-	fputs (buf, stderr);
+	      fputs (buf, stderr);
 
-      free (buf);
+	    free (buf);
+	}
       return;
     }
 
@@ -391,18 +399,19 @@ parse_line (const char *fname, int line_
 	  {
 	    char *buf;
 
-	    __asprintf (&buf,
+	    if (__asprintf (&buf,
 			_("%s: line %d: ignoring trailing garbage `%s'\n"),
-			fname, line_num, str);
-
+			fname, line_num, str) >= 0)
+	      {
 #ifdef USE_IN_LIBIO
-	    if (_IO_fwide (stderr, 0) > 0)
-	      __fwprintf (stderr, L"%s", buf);
-	    else
+	        if (_IO_fwide (stderr, 0) > 0)
+	          __fwprintf (stderr, L"%s", buf);
+	        else
 #endif
-	      fputs (buf, stderr);
+	          fputs (buf, stderr);
 
-	    free (buf);
+		free (buf);
+	      }
 	  }
 	break;
       }
diff -uNrp glibc-2.3.2.orig/stdio-common/psignal.c glibc-2.3.2/stdio-common/psignal.c
--- glibc-2.3.2.orig/stdio-common/psignal.c	2002-08-04 22:17:42 +0000
+++ glibc-2.3.2/stdio-common/psignal.c	2004-03-09 09:55:37 +0000
@@ -60,15 +60,16 @@ psignal (int sig, const char *s)
     {
       char *buf;
 
-      (void) __asprintf (&buf, _("%s%sUnknown signal %d\n"), s, colon, sig);
-
+      if (__asprintf (&buf, _("%s%sUnknown signal %d\n"), s, colon, sig) >= 0)
+	{
 #ifdef USE_IN_LIBIO
-      if (_IO_fwide (stderr, 0) > 0)
-	(void) __fwprintf (stderr, L"%s",  buf);
-      else
+	  if (_IO_fwide (stderr, 0) > 0)
+	    (void) __fwprintf (stderr, L"%s",  buf);
+	  else
 #endif
-	(void) fputs (buf, stderr);
+	    (void) fputs (buf, stderr);
 
-      free (buf);
+	  free (buf);
+	}
     }
 }
diff -uNrp glibc-2.3.2.orig/sunrpc/svc_simple.c glibc-2.3.2/sunrpc/svc_simple.c
--- glibc-2.3.2.orig/sunrpc/svc_simple.c	2002-08-08 02:08:23 +0000
+++ glibc-2.3.2/sunrpc/svc_simple.c	2004-03-09 10:00:32 +0000
@@ -122,12 +122,15 @@ registerrpc (u_long prognum, u_long vers
 
  err_out:
 #ifdef USE_IN_LIBIO
-  if (_IO_fwide (stderr, 0) > 0)
-    (void) __fwprintf (stderr, L"%s", buf);
-  else
+  if (buf != NULL)
+    {
+      if (_IO_fwide (stderr, 0) > 0)
+	(void) __fwprintf (stderr, L"%s", buf);
+      else
 #endif
-    (void) fputs (buf, stderr);
-  free (buf);
+	(void) fputs (buf, stderr);
+      free (buf);
+    }
   return -1;
 }
 
@@ -171,22 +174,33 @@ universal (struct svc_req *rqstp, SVCXPR
 	  return;
 	if (!INTUSE(svc_sendreply) (transp_l, pl->p_outproc, outdata))
 	  {
-	    (void) __asprintf (&buf,
+	    if (__asprintf (&buf,
 			       _("trouble replying to prog %d\n"),
-			       pl->p_prognum);
+			       pl->p_prognum) >= 0)
+	      {
+#ifdef USE_IN_LIBIO
+		if (_IO_fwide (stderr, 0) > 0)
+		  __fwprintf (stderr, L"%s", buf);
+		else
+#endif
+		  fputs (buf, stderr);
+		free (buf);
+	      }
 	    exit (1);
 	  }
 	/* free the decoded arguments */
 	(void) svc_freeargs (transp_l, pl->p_inproc, xdrbuf);
 	return;
       }
-  (void) __asprintf (&buf, _("never registered prog %d\n"), prog);
+  if (__asprintf (&buf, _("never registered prog %d\n"), prog) >= 0)
+    {
 #ifdef USE_IN_LIBIO
-  if (_IO_fwide (stderr, 0) > 0)
-    __fwprintf (stderr, L"%s", buf);
-  else
+      if (_IO_fwide (stderr, 0) > 0)
+	__fwprintf (stderr, L"%s", buf);
+      else
 #endif
-    fputs (buf, stderr);
-  free (buf);
+	fputs (buf, stderr);
+      free (buf);
+    }
   exit (1);
 }

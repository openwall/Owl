diff -urPX nopatch glibc-2.1.3.orig/resolv/Makefile glibc-2.1.3/resolv/Makefile
--- glibc-2.1.3.orig/resolv/Makefile	Fri Nov 20 17:26:41 1998
+++ glibc-2.1.3/resolv/Makefile	Mon Jun 12 17:12:12 2000
@@ -25,7 +25,8 @@
 distribute := ../conf/portability.h mapv4v6addr.h mapv4v6hostent.h \
 	      Banner res_hconf.h
 
-routines := herror inet_addr inet_ntop inet_pton nsap_addr res_init res_hconf
+routines := herror inet_addr inet_ntop inet_pton nsap_addr res_init res_hconf \
+	    shuffle
 
 tests = tst-aton
 
@@ -35,7 +36,8 @@
 extra-libs-others = $(extra-libs)
 libresolv-routines := gethnamaddr res_comp res_debug	\
 		      res_data res_mkquery res_query res_send		\
-		      inet_net_ntop inet_net_pton inet_neta base64
+		      inet_net_ntop inet_net_pton inet_neta base64 \
+		      shuffle
 
 subdir-dirs = nss_dns
 vpath %.c nss_dns
diff -urPX nopatch glibc-2.1.3.orig/resolv/res_init.c glibc-2.1.3/resolv/res_init.c
--- glibc-2.1.3.orig/resolv/res_init.c	Wed Apr 28 22:34:01 1999
+++ glibc-2.1.3/resolv/res_init.c	Mon Jun 12 15:55:05 2000
@@ -646,11 +646,12 @@
 }
 #endif	/* NeXT */
 
+extern unsigned int _shuffle_next();
+
 u_int
 res_randomid()
 {
-	struct timeval now;
-
-	__gettimeofday(&now, NULL);
-	return (0xffff & (now.tv_sec ^ now.tv_usec ^ __getpid()));
+/* We should probably randomize the port number as well, but this may be
+ * better done in the kernel */
+	return _shuffle_next();
 }
diff -urPX nopatch glibc-2.1.3.orig/resolv/res_mkquery.c glibc-2.1.3/resolv/res_mkquery.c
--- glibc-2.1.3.orig/resolv/res_mkquery.c	Wed Oct  2 01:37:29 1996
+++ glibc-2.1.3/resolv/res_mkquery.c	Mon Jun 12 15:56:05 2000
@@ -76,6 +76,8 @@
 # include <../conf/options.h>
 #endif
 
+extern unsigned int _shuffle_next();
+
 /*
  * Form all types of queries.
  * Returns the size of the result or -1.
@@ -112,7 +114,7 @@
 		return (-1);
 	bzero(buf, HFIXEDSZ);
 	hp = (HEADER *) buf;
-	hp->id = htons(++_res.id);
+	hp->id = htons(_res.id = _shuffle_next());
 	hp->opcode = op;
 	hp->rd = (_res.options & RES_RECURSE) != 0;
 	hp->rcode = NOERROR;
diff -urPX nopatch glibc-2.1.3.orig/resolv/shuffle.c glibc-2.1.3/resolv/shuffle.c
--- glibc-2.1.3.orig/resolv/shuffle.c	Thu Jan  1 00:00:00 1970
+++ glibc-2.1.3/resolv/shuffle.c	Mon Jun 12 15:48:32 2000
@@ -0,0 +1,224 @@
+/*
+ * Written by Solar Designer and placed in the public domain.
+ */
+
+#include <unistd.h>
+#include <fcntl.h>
+
+#ifdef __linux__
+#define DEVICE				"/dev/urandom"
+#else
+#undef DEVICE
+#endif
+
+#ifdef DEVICE
+#include <errno.h>
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <sys/time.h>
+#include <sys/times.h>
+
+#ifdef TEST
+#include <stdio.h>
+#endif
+
+#define DIV				0x8000
+
+static unsigned char pool[0x100];
+
+static struct {
+	unsigned int base, xor;
+	unsigned char s[0x80];
+} seed_c;
+static unsigned char seed_f[0x100];
+
+static struct {
+	unsigned int msb;
+	unsigned int a, b;
+	unsigned int n;
+} state;
+
+#ifdef DEVICE
+static int read_loop(int fd, char *buffer, int count)
+{
+	int offset, block;
+
+	offset = 0;
+	while (count > 0) {
+		block = read(fd, &buffer[offset], count);
+
+		if (block < 0) {
+			if (errno == EINTR) continue;
+			return block;
+		}
+		if (!block) return offset;
+
+		offset += block;
+		count -= block;
+	}
+
+	return offset;
+}
+#endif
+
+static void pool_update(unsigned int seed)
+{
+	int i, x;
+
+	srand(seed ^ rand());
+	for (i = 0; i < sizeof(pool); i++) {
+		x = rand();
+		pool[i] += (x >> 16) ^ x;
+	}
+}
+
+static void shuffle_init()
+{
+	struct timeval tv;
+#ifdef DEVICE
+	int fd;
+
+	if ((fd = open(DEVICE, O_RDONLY)) < 0 ||
+	    read_loop(fd, (char *)seed_f, sizeof(seed_f)) != sizeof(seed_f)) {
+#endif
+
+		memset(pool, 'X', sizeof(pool));
+		pool_update(getpid());
+		pool_update(getppid());
+		if (!gettimeofday(&tv, NULL)) {
+			pool_update(tv.tv_sec);
+			pool_update(tv.tv_usec);
+		}
+
+		memcpy(seed_f, pool, sizeof(seed_f));
+#ifdef DEVICE
+	}
+	if (fd >= 0) close(fd);
+#endif
+
+	state.msb = 0;
+	state.n = DIV;			/* force a reseed() */
+}
+
+static void reseed()
+{
+	struct tms buf;
+#ifdef DEVICE
+	int fd;
+
+	if ((fd = open(DEVICE, O_RDONLY)) < 0 ||
+	    read_loop(fd, (char *)&seed_c, sizeof(seed_c)) != sizeof(seed_c)) {
+#endif
+		pool_update(times(&buf));
+		pool_update(buf.tms_utime);
+		pool_update(buf.tms_stime);
+#ifdef DEVICE
+	}
+	if (fd >= 0) close(fd);
+#endif
+
+	seed_c.base &= 0x1fff;
+	seed_c.base <<= 3;
+	seed_c.base += DIV + 3;
+	seed_c.xor &= (DIV - 1);
+	state.msb ^= 0x8000;
+	state.a = 1;
+	state.b = 1;
+	state.n = 0;
+}
+
+/*
+ * Now, time for a puzzle.  Think of division by DIV in seed_c.base.
+ * This is not as slow as it might appear: the inner loop needs only
+ * a few iterations per call, on average.
+ */
+static unsigned int shuffle_1_next()
+{
+	if (state.n >= DIV - 1)
+		reseed();
+
+	if (state.n && state.b <= state.a) {
+		do {
+			state.b = ++state.a;
+			do {
+				state.b *= seed_c.base;
+				state.b %= DIV;
+			} while (state.b > state.a);
+		} while (state.a != state.b);
+	}
+
+	state.b *= seed_c.base;
+	state.b %= DIV;
+	state.n++;
+
+	return state.b ^ seed_c.xor;
+}
+
+/*
+ * The idea behind shuffle_2 is David Wagner's (any bugs are mine,
+ * of course).
+ */
+static unsigned int shuffle_2(unsigned int x)
+{
+	unsigned int i, sum;
+
+	sum = 0;
+	for (i = 0; i < 8; i++) {
+		sum += 0x79b9;
+		x ^= ((unsigned int)seed_c.s[(x ^ sum) & 0x7f]) << 7;
+		x = ((x & 0xff) << 7) | (x >> 8);
+	}
+
+	return x;
+}
+
+/*
+ * A full 16-bit permutation.  This one can't be re-seeded, but still
+ * makes some attacks quite a bit harder.
+ */
+static unsigned int shuffle_3(unsigned int x)
+{
+	unsigned int i, sum;
+
+	sum = 0;
+	for (i = 0; i < 8; i++) {
+		sum += 0x79b9;
+		x ^= ((unsigned int)seed_f[(x ^ sum) & 0xff]) << 8;
+		x = ((x & 0xff) << 8) | (x >> 8);
+	}
+
+	return x;
+}
+
+unsigned int _shuffle_next()
+{
+	static int initialized = 0;
+	unsigned int x;
+
+/* This isn't MT-safe, but the resolver itself isn't safe, anyway */
+	if (!initialized) {
+		shuffle_init();
+		initialized = 1;
+	}
+
+	x = shuffle_1_next();
+	x = shuffle_2(x);
+	x |= state.msb;
+	x = shuffle_3(x);
+
+	return x;
+}
+
+#ifdef TEST
+int main()
+{
+	int i;
+
+	for (i = 0; i < 0xfffe; i++)
+		printf("%u\n", _shuffle_next());
+
+	return 0;
+}
+#endif

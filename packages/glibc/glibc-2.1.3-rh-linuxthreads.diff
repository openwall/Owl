diff -urN glibc-2.1.3.orig/linuxthreads/ChangeLog glibc-2.1.3.rh/linuxthreads/ChangeLog
--- glibc-2.1.3.orig/linuxthreads/ChangeLog	Wed Feb 23 09:02:52 2000
+++ glibc-2.1.3.rh/linuxthreads/ChangeLog	Mon Mar 27 19:32:06 2000
@@ -1,3 +1,41 @@
+2000-03-23  Ulrich Drepper  <drepper@redhat.com>
+
+	* mutex.c (__pthread_reset_pthread_once): Reset once_masterlock.
+	* internals.h (__pthread_reset_pthread_once): Add prototype.
+	* ptfork.c (__fork): Call __pthread_reset_pthread_once.
+
+	* manager.c (pthread_handle_create): Store ID of new thread before
+	clone call.
+
+2000-03-21  Ulrich Drepper  <drepper@redhat.com>
+
+	* pthread.c (pthread_initialize): Test for address of __dso_handle
+	being NULL, not value.  Use __on_exit, not on_exit.
+	Patch by Andreas Jaeger <aj@suse.de>.
+
+2000-03-19  Ulrich Drepper  <drepper@redhat.com>
+
+	* pthread.c (pthread_initialize): Instead of on_exit use
+	__cxa_atexit if __dso_label is available to allow unloading the
+	libpthread shared library.
+
+2000-03-16  Ulrich Drepper  <drepper@redhat.com>
+
+	* mutex.c (__pthread_mutex_lock): Always initialize __m_owner.
+	(__pthread_mutex_trylock): Likewise.
+	(__pthread_mutex_unlock): Always clear __m_owner.
+
+2000-03-14  Ulrich Drepper  <drepper@redhat.com>
+
+	* condvar.c (pthread_cond_wait): Check whether mutex is owned by
+	current thread and return error if not.
+	(pthread_cond_timedwait_relative_old): Likewise.
+	(pthread_cond_timedwait_relative_new): Likewise.
+
+	* mutex.c (__pthread_once): Handle cancelled init function correctly.
+	(pthread_once_cancelhandler): New function.
+	Patch by Kaz Kylheku <kaz@ashi.footprints.net>.
+
 2000-02-22  Ulrich Drepper  <drepper@redhat.com>
 
 	* semaphore.h (SEM_FAILED): Use 0 not NULL.
diff -urN glibc-2.1.3.orig/linuxthreads/condvar.c glibc-2.1.3.rh/linuxthreads/condvar.c
--- glibc-2.1.3.orig/linuxthreads/condvar.c	Tue Feb 15 20:59:21 2000
+++ glibc-2.1.3.rh/linuxthreads/condvar.c	Wed Mar 15 18:57:07 2000
@@ -77,6 +77,10 @@
   pthread_extricate_if extr;
   int already_canceled = 0;
 
+  /* Check whether the mutex is locked and owned by this thread.  */
+  if (mutex->__m_owner != self)
+    return EINVAL;
+
   /* Set up extrication interface */
   extr.pu_object = cond;
   extr.pu_extricate_func = cond_extricate_func;
@@ -139,6 +143,10 @@
   sigjmp_buf jmpbuf;
   pthread_extricate_if extr;
 
+  /* Check whether the mutex is locked and owned by this thread.  */
+  if (mutex->__m_owner != self)
+    return EINVAL;
+
   /* Set up extrication interface */
   extr.pu_object = cond;
   extr.pu_extricate_func = cond_extricate_func;
@@ -265,6 +273,10 @@
   int was_signalled = 0;
   sigjmp_buf jmpbuf;
   pthread_extricate_if extr;
+
+  /* Check whether the mutex is locked and owned by this thread.  */
+  if (mutex->__m_owner != self)
+    return EINVAL;
 
   /* Set up extrication interface */
   extr.pu_object = cond;
diff -urN glibc-2.1.3.orig/linuxthreads/internals.h glibc-2.1.3.rh/linuxthreads/internals.h
--- glibc-2.1.3.orig/linuxthreads/internals.h	Fri Jan 21 03:40:19 2000
+++ glibc-2.1.3.rh/linuxthreads/internals.h	Mon Mar 27 19:32:06 2000
@@ -387,6 +387,7 @@
 int __pthread_manager_event(void *reqfd);
 void __pthread_manager_sighandler(int sig);
 void __pthread_reset_main_thread(void);
+void __pthread_reset_pthread_once(void);
 void __fresetlockfiles(void);
 void __pthread_manager_adjust_prio(int thread_prio);
 void __pthread_set_own_extricate_if(pthread_descr self, pthread_extricate_if *peif);
diff -urN glibc-2.1.3.orig/linuxthreads/lockfile.c glibc-2.1.3.rh/linuxthreads/lockfile.c
--- glibc-2.1.3.orig/linuxthreads/lockfile.c	Thu Jul  9 16:41:28 1998
+++ glibc-2.1.3.rh/linuxthreads/lockfile.c	Mon Dec 27 18:10:10 1999
@@ -80,7 +80,8 @@
   __pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE_NP);
 
   for (fp = _IO_list_all; fp != NULL; fp = fp->_chain)
-    __pthread_mutex_init (fp->_lock, &attr);
+      if (fp->_lock)
+	  __pthread_mutex_init (fp->_lock, &attr);
 
   __pthread_mutexattr_destroy (&attr);
 #endif
diff -urN glibc-2.1.3.orig/linuxthreads/manager.c glibc-2.1.3.rh/linuxthreads/manager.c
--- glibc-2.1.3.orig/linuxthreads/manager.c	Fri Jan 21 03:40:19 2000
+++ glibc-2.1.3.rh/linuxthreads/manager.c	Mon Mar 27 19:32:06 2000
@@ -412,6 +412,10 @@
   new_thread->p_start_args.start_routine = start_routine;
   new_thread->p_start_args.arg = arg;
   new_thread->p_start_args.mask = *mask;
+  /* Make the new thread ID available already now.  If any of the later
+     functions fail we return an error value and the caller must not use
+     the stored thread ID.  */
+  *thread = new_thread_id;
   /* Raise priority of thread manager if needed */
   __pthread_manager_adjust_prio(new_thread->p_priority);
   /* Do the cloning.  We have to use two different functions depending
@@ -484,8 +488,6 @@
   /* Set pid field of the new thread, in case we get there before the
      child starts. */
   new_thread->p_pid = pid;
-  /* We're all set */
-  *thread = new_thread_id;
   return 0;
 }
 
diff -urN glibc-2.1.3.orig/linuxthreads/mutex.c glibc-2.1.3.rh/linuxthreads/mutex.c
--- glibc-2.1.3.orig/linuxthreads/mutex.c	Wed Nov 18 18:59:53 1998
+++ glibc-2.1.3.rh/linuxthreads/mutex.c	Mon Mar 27 19:32:06 2000
@@ -50,6 +50,7 @@
   switch(mutex->__m_kind) {
   case PTHREAD_MUTEX_FAST_NP:
     retcode = __pthread_trylock(&mutex->__m_lock);
+    mutex->__m_owner = thread_self();
     return retcode;
   case PTHREAD_MUTEX_RECURSIVE_NP:
     self = thread_self();
@@ -77,31 +78,29 @@
 
 int __pthread_mutex_lock(pthread_mutex_t * mutex)
 {
-  pthread_descr self;
+  pthread_descr self = thread_self();
 
   switch(mutex->__m_kind) {
   case PTHREAD_MUTEX_FAST_NP:
     __pthread_lock(&mutex->__m_lock, NULL);
-    return 0;
+    break;
   case PTHREAD_MUTEX_RECURSIVE_NP:
-    self = thread_self();
     if (mutex->__m_owner == self) {
       mutex->__m_count++;
       return 0;
     }
     __pthread_lock(&mutex->__m_lock, self);
-    mutex->__m_owner = self;
     mutex->__m_count = 0;
-    return 0;
+    break;
   case PTHREAD_MUTEX_ERRORCHECK_NP:
-    self = thread_self();
     if (mutex->__m_owner == self) return EDEADLK;
     __pthread_lock(&mutex->__m_lock, self);
-    mutex->__m_owner = self;
-    return 0;
+    break;
   default:
     return EINVAL;
   }
+  mutex->__m_owner = self;
+  return 0;
 }
 strong_alias (__pthread_mutex_lock, pthread_mutex_lock)
 
@@ -110,6 +109,7 @@
   switch (mutex->__m_kind) {
   case PTHREAD_MUTEX_FAST_NP:
     __pthread_unlock(&mutex->__m_lock);
+    mutex->__m_owner = NULL;
     return 0;
   case PTHREAD_MUTEX_RECURSIVE_NP:
     if (mutex->__m_count > 0) {
@@ -173,11 +173,31 @@
 
 enum { NEVER = 0, IN_PROGRESS = 1, DONE = 2 };
 
+/* If a thread is canceled while calling the init_routine out of
+   pthread once, this handler will reset the once_control variable
+   to the NEVER state. */
+
+static void pthread_once_cancelhandler(void *arg)
+{
+    pthread_once_t *once_control = arg;
+
+    pthread_mutex_lock(&once_masterlock);
+    *once_control = NEVER;
+    pthread_mutex_unlock(&once_masterlock);
+    pthread_cond_broadcast(&once_finished);
+}
+
 int __pthread_once(pthread_once_t * once_control, void (*init_routine)(void))
 {
+  /* flag for doing the condition broadcast outside of mutex */
+  int state_changed;
+
   /* Test without locking first for speed */
   if (*once_control == DONE) return 0;
   /* Lock and test again */
+
+  state_changed = 0;
+
   pthread_mutex_lock(&once_masterlock);
   /* If init_routine is being called from another routine, wait until
      it completes. */
@@ -188,12 +208,30 @@
   if (*once_control == NEVER) {
     *once_control = IN_PROGRESS;
     pthread_mutex_unlock(&once_masterlock);
+    pthread_cleanup_push(pthread_once_cancelhandler, once_control);
     init_routine();
+    pthread_cleanup_pop(0);
     pthread_mutex_lock(&once_masterlock);
     *once_control = DONE;
-    pthread_cond_broadcast(&once_finished);
+    state_changed = 1;
   }
   pthread_mutex_unlock(&once_masterlock);
+
+  if (state_changed)
+    pthread_cond_broadcast(&once_finished);
+
   return 0;
 }
 strong_alias (__pthread_once, pthread_once)
+
+/*
+ * This is called in the child process after a fork to make
+ * sure that the global mutex pthread_once is not held,
+ * and that the condition variable is reset to an initial state.
+ */
+
+void __pthread_reset_pthread_once(void)
+{
+  pthread_mutex_init(&once_masterlock, NULL);
+  pthread_cond_init(&once_finished, NULL);
+}
diff -urN glibc-2.1.3.orig/linuxthreads/ptfork.c glibc-2.1.3.rh/linuxthreads/ptfork.c
--- glibc-2.1.3.orig/linuxthreads/ptfork.c	Mon Sep  6 22:32:07 1999
+++ glibc-2.1.3.rh/linuxthreads/ptfork.c	Mon Mar 27 19:32:06 2000
@@ -89,6 +89,7 @@
   pid = __libc_fork();
   if (pid == 0) {
     __pthread_reset_main_thread();
+    __pthread_reset_pthread_once();
     __fresetlockfiles();
     pthread_call_handlers(child);
   } else {
diff -urN glibc-2.1.3.orig/linuxthreads/pthread.c glibc-2.1.3.rh/linuxthreads/pthread.c
--- glibc-2.1.3.orig/linuxthreads/pthread.c	Fri Jan 21 03:40:19 2000
+++ glibc-2.1.3.rh/linuxthreads/pthread.c	Wed Mar 22 23:26:01 2000
@@ -298,6 +298,8 @@
 
 static void pthread_initialize(void) __attribute__((constructor));
 
+extern void *__dso_handle __attribute__ ((weak));
+
 static void pthread_initialize(void)
 {
   struct sigaction sa;
@@ -370,7 +372,13 @@
   /* Register an exit function to kill all other threads. */
   /* Do it early so that user-registered atexit functions are called
      before pthread_exit_process. */
-  __on_exit(pthread_exit_process, NULL);
+  if (&__dso_handle != NULL)
+    /* The cast is a bit unclean.  The function expects two arguments but
+       we can only pass one.  Fortunately this is not a problem since the
+       second argument of `pthread_exit_process' is simply ignored.  */
+    __cxa_atexit((void (*) (void *)) pthread_exit_process, NULL, __dso_handle);
+  else
+    __on_exit (pthread_exit_process, NULL);
 }
 
 void __pthread_initialize(void)
diff -urN glibc-2.1.3.orig/include/stdlib.h glibc-2.1.3.rh/include/stdlib.h
--- glibc-2.1.3.orig/include/stdlib.h	Mon Aug  2 01:07:46 1999
+++ glibc-2.1.3.rh/include/stdlib.h	Wed Mar 22 23:26:01 2000
@@ -49,6 +49,9 @@
 
 extern int __add_to_environ (const char *name, const char *value,
 			     const char *combines, int replace);
+
+extern int __cxa_atexit (void (*func) (void *), void *arg, void *d);
+
 #endif
 #undef __Need_M_And_C
 

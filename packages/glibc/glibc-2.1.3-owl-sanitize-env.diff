--- glibc-2.1.3/sysdeps/generic/segfault.c.orig	Thu Jan  6 04:45:41 2000
+++ glibc-2.1.3/sysdeps/generic/segfault.c	Thu Jan 11 17:35:27 2001
@@ -234,7 +234,7 @@
     }
 
   /* Preserve the output file name if there is any given.  */
-  name = getenv ("SEGFAULT_OUTPUT_NAME");
+  name = __secure_getenv ("SEGFAULT_OUTPUT_NAME");
   if (name != NULL && name[0] != '\0')
     fname = __strdup (name);
 }
--- glibc-2.1.3/sysdeps/generic/glob.c.orig	Wed Feb 23 10:03:08 2000
+++ glibc-2.1.3/sysdeps/generic/glob.c	Thu Jan 11 17:39:16 2001
@@ -135,7 +135,7 @@
 # define	ANSI_STRING
 #else	/* No standard headers.  */
 
-extern char *getenv ();
+extern char *__secure_getenv ();
 
 # ifdef HAVE_STRING_H
 #  include <string.h>
@@ -609,7 +609,7 @@
       if (dirname[1] == '\0' || dirname[1] == '/')
 	{
 	  /* Look up home directory.  */
-	  const char *home_dir = getenv ("HOME");
+	  const char *home_dir = __secure_getenv ("HOME");
 # ifdef _AMIGA
 	  if (home_dir == NULL || home_dir[0] == '\0')
 	    home_dir = "SYS:";
--- glibc-2.1.3/sysdeps/unix/sysv/linux/i386/dl-librecon.h.orig	Wed Feb 24 12:39:22 1999
+++ glibc-2.1.3/sysdeps/unix/sysv/linux/i386/dl-librecon.h	Thu Jan 11 19:35:20 2001
@@ -49,13 +49,17 @@
 /* Recognizing extra environment variables.  */
 #define EXTRA_LD_ENVVARS \
   case 15:								      \
-    if (memcmp (&envline[3], "LIBRARY_VERSION", 15) == 0)		      \
+    if (!__libc_enable_secure						      \
+	&& memcmp (&envline[3], "LIBRARY_VERSION", 15) == 0)		      \
       {									      \
 	_dl_correct_cache_id = envline[19] == '5' ? 2 : 3;		      \
 	break;								      \
       }
 
 /* Extra unsecure variables.  */
-#define EXTRA_UNSECURE_ENVVARS "LD_AOUT_LIBRARY_PATH", "LD_AOUT_PRELOAD"
+#define EXTRA_UNSECURE_ENVVARS \
+	"LD_LIBRARY_VERSION", \
+	"LD_AOUT_LIBRARY_PATH", \
+	"LD_AOUT_PRELOAD"
 
 #endif /* dl-librecon.h */
--- glibc-2.1.3/db/btree/bt_open.c.orig	Wed Sep 23 18:00:16 1998
+++ glibc-2.1.3/db/btree/bt_open.c	Thu Jan 11 17:49:53 2001
@@ -395,7 +395,7 @@
 	static const char fmt[] = "%s/bt.XXXXXX";
 	size_t n;
 
-	envtmp = getenv("TMPDIR");
+	envtmp = __secure_getenv("TMPDIR");
 	if (!envtmp)
 	  envtmp = "/tmp";
 	n = strlen (envtmp) + sizeof fmt;
--- glibc-2.1.3/db2/common/db_appinit.c.orig	Tue Jun  9 19:02:34 1998
+++ glibc-2.1.3/db2/common/db_appinit.c	Thu Jan 11 17:56:14 2001
@@ -417,7 +417,8 @@
 	if (0) {
 tmp:		if (dbenv == NULL || !F_ISSET(dbenv, DB_ENV_APPINIT)) {
 			memset(&etmp, 0, sizeof(etmp));
-			if ((ret = __db_tmp_dir(&etmp, DB_USE_ENVIRON)) != 0)
+			if ((ret = __db_tmp_dir(&etmp,
+			    __libc_enable_secure ? 0 : DB_USE_ENVIRON)) != 0)
 				return (ret);
 			tmp_free = 1;
 			a = etmp.db_tmp_dir;
--- glibc-2.1.3/elf/rtld.c.orig	Wed Feb 23 10:02:47 2000
+++ glibc-2.1.3/elf/rtld.c	Thu Jan 11 22:24:28 2001
@@ -1289,7 +1289,8 @@
 
 	case 5:
 	  /* Debugging of the dynamic linker?  */
-	  if (memcmp (&envline[3], "DEBUG", 5) == 0)
+	  if (!__libc_enable_secure
+	      && memcmp (&envline[3], "DEBUG", 5) == 0)
 	    process_dl_debug (&envline[9]);
 	  break;
 
@@ -1302,14 +1303,16 @@
 	    }
 
 	  /* List of objects to be preloaded.  */
-	  if (memcmp (&envline[3], "PRELOAD", 7) == 0)
+	  if (!__libc_enable_secure
+	      && memcmp (&envline[3], "PRELOAD", 7) == 0)
 	    {
 	      preloadlist = &envline[11];
 	      break;
 	    }
 
 	  /* Which shared object shall be profiled.  */
-	  if (memcmp (&envline[3], "PROFILE", 7) == 0)
+	  if (!__libc_enable_secure
+	      && memcmp (&envline[3], "PROFILE", 7) == 0)
 	    {
 	      _dl_profile = &envline[11];
 	      if (*_dl_profile == '\0')
@@ -1319,20 +1322,23 @@
 
 	case 8:
 	  /* Do we bind early?  */
-	  if (memcmp (&envline[3], "BIND_NOW", 8) == 0)
+	  if (!__libc_enable_secure
+	      && memcmp (&envline[3], "BIND_NOW", 8) == 0)
 	    bind_now = envline[12] != '\0';
 	  break;
 
 	case 9:
 	  /* Test whether we want to see the content of the auxiliary
 	     array passed up from the kernel.  */
-	  if (memcmp (&envline[3], "SHOW_AUXV", 9) == 0)
+	  if (!__libc_enable_secure
+	      && memcmp (&envline[3], "SHOW_AUXV", 9) == 0)
 	    _dl_show_auxv ();
 	  break;
 
 	case 10:
 	  /* Mask for the important hardware capabilities.  */
-	  if (memcmp (&envline[3], "HWCAP_MASK", 10) == 0)
+	  if (!__libc_enable_secure
+	      && memcmp (&envline[3], "HWCAP_MASK", 10) == 0)
 	    _dl_hwcap_mask = strtoul (&envline[14], NULL, 0);
 	  break;
 
@@ -1345,14 +1351,16 @@
 
 	case 12:
 	  /* Where to place the profiling data file.  */
-	  if (memcmp (&envline[3], "DEBUG_OUTPUT", 12) == 0)
+	  if (!__libc_enable_secure
+	      && memcmp (&envline[3], "DEBUG_OUTPUT", 12) == 0)
 	    {
 	      debug_output = &envline[16];
 	      break;
 	    }
 
 	  /* The library search path.  */
-	  if (memcmp (&envline[3], "LIBRARY_PATH", 12) == 0)
+	  if (!__libc_enable_secure
+	      && memcmp (&envline[3], "LIBRARY_PATH", 12) == 0)
 	    library_path = &envline[16];
 	  break;
 
@@ -1369,7 +1377,8 @@
 
 	case 20:
 	  /* The mode of the dynamic linker can be set.  */
-	  if (memcmp (&envline[3], "TRACE_LOADED_OBJECTS", 20) == 0)
+	  if (!__libc_enable_secure
+	      && memcmp (&envline[3], "TRACE_LOADED_OBJECTS", 20) == 0)
 	    mode = trace;
 	  break;
 
@@ -1387,23 +1396,90 @@
      variables.  */
   if (__libc_enable_secure)
     {
+      /* These lists include both environment variables specific to the
+	 dynamic linker and generic ones used by various parts of glibc.
+	 They should be (partially?) moved to libc initialization in order
+	 to provide the same protection for statically-linked programs.
+	 Note that glibc itself tries to be careful to not trust these
+	 variables when running SUID/SGID, and it remains the responsibility
+	 of SUID/SGID programs to sanitize environment before executing
+	 other programs with matching real and effective IDs.  This is a
+	 "hardening" measure only, -- noone is supposed to rely on it.  */
       static const char *unsecure_envvars[] =
       {
+	"LD_DEBUG",
+	"LD_PRELOAD",
+	"LD_PROFILE",
+	"LD_BIND_NOW",
+	"LD_SHOW_AUXV",
+	"LD_HWCAP_MASK",
+	"LD_ORIGIN_PATH",
+	"LD_DEBUG_OUTPUT",
+	"LD_LIBRARY_PATH",
+	"LD_PROFILE_OUTPUT",
+	"LD_TRACE_LOADED_OBJECTS",
+	"RESOLV_HOST_CONF",
+	"RESOLV_SERV_ORDER",
+	"RESOLV_SPOOF_CHECK",
+	"RESOLV_OVERRIDE_TRIM_DOMAINS",
+	"RESOLV_ADD_TRIM_DOMAINS",
+	"RESOLV_MULTI",
+	"RESOLV_REORDER",
+	"RES_OPTIONS",
+	"LOCALDOMAIN",
+	"HOSTALIASES",
+	"MALLOC_TRIM_THRESHOLD_",
+	"MALLOC_TOP_PAD_",
+	"MALLOC_MMAP_THRESHOLD_",
+	"MALLOC_MMAP_MAX_",
+	"MALLOC_CHECK_",
+	"MALLOC_TRACE",
+	"HESIOD_CONFIG",
+	"HES_DOMAIN",
+	"GCONV_PATH",
+	"LOCPATH",
+	"NLSPATH",
+	"TZDIR",
+	"TZ",
+	"SEGFAULT_OUTPUT_NAME"
 #ifdef EXTRA_UNSECURE_ENVVARS
+	,
 	EXTRA_UNSECURE_ENVVARS
 #endif
       };
+      static const char *restricted_envvars[] =
+      {
+	"LANGUAGE",
+	"LANG",
+	"LC_ALL",
+	"LC_COLLATE",
+	"LC_CTYPE",
+	"LC_MESSAGES",
+	"LC_MONETARY",
+	"LC_NUMERIC",
+	"LC_TIME",
+	"LC_XXX"
+      };
       size_t cnt;
-
-      if (preloadlist != NULL)
-	unsetenv ("LD_PRELOAD");
-      if (library_path != NULL)
-	unsetenv ("LD_LIBRARY_PATH");
+      char *value;
 
       for (cnt = 0;
 	   cnt < sizeof (unsecure_envvars) / sizeof (unsecure_envvars[0]);
 	   ++cnt)
 	unsetenv (unsecure_envvars[cnt]);
+
+      /* This loop is buggy: it will only check the first occurrence of each
+	 variable (but will correctly remove all in case of a match).  This
+	 may be a problem if the list is later re-ordered or accessed by an
+	 application with something other than the glibc getenv().  */
+      for (cnt = 0;
+	   cnt < sizeof (restricted_envvars) / sizeof (restricted_envvars[0]);
+	   ++cnt)
+	{
+	  if ((value = getenv(restricted_envvars[cnt]))
+	      && (value[0] == '.' || strchr(value, '/')))
+	    unsetenv (restricted_envvars[cnt]);
+	}
     }
 
   /* If we have to run the dynamic linker in debugging mode and the
--- glibc-2.1.3/elf/dl-support.c.orig	Tue May 11 16:59:16 1999
+++ glibc-2.1.3/elf/dl-support.c	Thu Jan 11 22:27:56 2001
@@ -89,9 +89,9 @@
 
   /* Initialize the data structures for the search paths for shared
      objects.  */
-  _dl_init_paths (getenv ("LD_LIBRARY_PATH"));
+  _dl_init_paths (__libc_enable_secure ? NULL : getenv ("LD_LIBRARY_PATH"));
 
-  _dl_lazy = *(getenv ("LD_BIND_NOW") ?: "") == '\0';
+  _dl_lazy = __libc_enable_secure || *(getenv ("LD_BIND_NOW") ?: "") == '\0';
 
 #ifdef DL_PLATFORM_INIT
   DL_PLATFORM_INIT;
--- glibc-2.1.3/io/getdirname.c.orig	Thu Jul 16 14:37:25 1998
+++ glibc-2.1.3/io/getdirname.c	Thu Jan 11 22:36:12 2001
@@ -31,7 +31,9 @@
   char *pwd;
   struct stat dotstat, pwdstat;
 
-  pwd = getenv ("PWD");
+  /* A plain getenv() could let one check for subdirectories of a directory
+     only accessible to the effective privileges of the program.  */
+  pwd = __secure_getenv ("PWD");
   if (pwd != NULL &&
       stat (".", &dotstat) == 0 &&
       stat (pwd, &pwdstat) == 0 &&
--- glibc-2.1.3/malloc/malloc.c.orig	Wed Feb 23 10:02:55 2000
+++ glibc-2.1.3/malloc/malloc.c	Thu Jan 11 17:13:12 2001
@@ -1717,7 +1717,7 @@
     mALLOPt(M_MMAP_THRESHOLD, atoi(s));
   if((s = __secure_getenv("MALLOC_MMAP_MAX_")))
     mALLOPt(M_MMAP_MAX, atoi(s));
-  s = getenv("MALLOC_CHECK_");
+  s = __secure_getenv("MALLOC_CHECK_");
 #ifndef NO_THREADS
   __malloc_hook = save_malloc_hook;
   __free_hook = save_free_hook;
--- glibc-2.1.3/resolv/res_hconf.c.orig	Thu Apr 29 14:10:29 1999
+++ glibc-2.1.3/resolv/res_hconf.c	Thu Jan 11 17:27:16 2001
@@ -340,30 +340,30 @@
       fclose (fp);
     }
 
-  envval = getenv (ENV_SERVORDER);
+  envval = __secure_getenv (ENV_SERVORDER);
   if (envval)
     {
       _res_hconf.num_services = 0;
       arg_service_list (ENV_SERVORDER, 1, envval, 0);
     }
 
-  envval = getenv (ENV_SPOOF);
+  envval = __secure_getenv (ENV_SPOOF);
   if (envval)
     arg_spoof (ENV_SPOOF, 1, envval, 0);
 
-  envval = getenv (ENV_MULTI);
+  envval = __secure_getenv (ENV_MULTI);
   if (envval)
     arg_bool (ENV_MULTI, 1, envval, HCONF_FLAG_MULTI);
 
-  envval = getenv (ENV_REORDER);
+  envval = __secure_getenv (ENV_REORDER);
   if (envval)
     arg_bool (ENV_REORDER, 1, envval, HCONF_FLAG_REORDER);
 
-  envval = getenv (ENV_TRIM_ADD);
+  envval = __secure_getenv (ENV_TRIM_ADD);
   if (envval)
     arg_trimdomain_list (ENV_TRIM_ADD, 1, envval, 0);
 
-  envval = getenv (ENV_TRIM_OVERR);
+  envval = __secure_getenv (ENV_TRIM_OVERR);
   if (envval)
     {
       _res_hconf.num_trimdomains = 0;
--- glibc-2.1.3/time/tzset.c.orig	Wed Feb 23 10:03:36 2000
+++ glibc-2.1.3/time/tzset.c	Thu Jan 11 22:46:41 2001
@@ -140,8 +140,11 @@
     return;
   is_initialized = 1;
 
-  /* Examine the TZ environment variable.  */
-  tz = getenv ("TZ");
+  /* Examine the TZ environment variable.  This doesn't really have to be
+     a __secure_getenv() call as __tzfile_read() tries to only read files
+     found under a trusted directory, but this helps reduce the amount of
+     security-critical code.  */
+  tz = __secure_getenv ("TZ");
   if (tz == NULL)
     /* No user specification; use the site-wide default.  */
     tz = TZDEFAULT;
